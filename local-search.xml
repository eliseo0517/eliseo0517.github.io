<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>String为什么设计成不可变的？</title>
    <link href="/2022/09/07/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/"/>
    <url>/2022/09/07/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA语言为什么把String类型设计成不可变？"><a href="#JAVA语言为什么把String类型设计成不可变？" class="headerlink" title="JAVA语言为什么把String类型设计成不可变？"></a>JAVA语言为什么把String类型设计成不可变？</h1><p>第一：在Java程序中String类型是使用最多的，这就牵扯到大量的增删改查，每次增删改差之前其实jvm需要检查一下这个String对象的安全性，就是通过hashcode，当设计成不可变对象时候，就保证了每次增删改查的hashcode的唯一性，也就可以放心的操作。</p><p>第二：网络连接地址URL,文件路径path通常情况下都是以String类型保存, 假若String不是固定不变的,将会引起各种安全隐患。就好比我们的密码不能以String的类型保存，，如果你将密码以明文的形式保存成字符串，那么它将一直留在内存中，直到垃圾收集器把它清除。而由于字符串被放在字符串缓冲池中以方便重复使用，所以它就可能在内存中被保留很长时间，而这将导致安全隐患</p><p>第三：字符串值是被保留在常量池中的，也就是说假若字符串对象允许改变,那么将会导致各种逻辑错误</p><h1 id="缓存和数据库一致性问题"><a href="#缓存和数据库一致性问题" class="headerlink" title="缓存和数据库一致性问题"></a>缓存和数据库一致性问题</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了 </a></p><p>最刚开始：</p><p>​    1、更新缓存之后更新数据库</p><p>​    2、更新数据库之后更新缓存</p><p>发现以上两者不论何时都会有问题，所以引入了删除缓存的操作。</p><p>更新成为：</p><p>​    1、删除缓存之后更新数据库</p><p>​    2、更新数据库之后删除缓存</p><p>一般来说，第二种情况的并发问题不可能出现。因为写数据库的数据的时候一般都会进行加锁，所以写数据会比读数据的时候要慢，</p><p>如果要使用第一种删除缓存之后更新数据库，然后还要保证一致性，那么就使用<strong>延迟双删</strong>；先删除缓存之后更新数据库，过1s以后再次删除缓存。这样就可以把脏数据删除。</p><hr><p>如果删除缓存失败了那么应该怎么办？ <strong>重试，</strong>无论是先操作缓存还是先操作数据库，但凡后者执行失败了，那么我们就可以发起重试。</p><p>那么如何重试呢？ <strong>异步重试</strong></p><p>​    1、重试请求写到消息队列中，然后由专门的消费者来重试，直到成功</p><blockquote><p>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功</p></blockquote><p>​    2、订阅数据库变更日志，在操作缓存</p><blockquote><p>流程如下</p><p> 所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7）重新从消息队列中获得该数据，重试操作。</p></blockquote><h1 id="Spring的循环依赖如何解决？"><a href="#Spring的循环依赖如何解决？" class="headerlink" title="Spring的循环依赖如何解决？"></a>Spring的循环依赖如何解决？</h1><p>set注入导致的循环依赖可以解决(使用三级缓存)，<strong>但是如果是由构造器导致的循环依赖没有解决的方法。</strong></p><p>Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（<code>singletonObjects</code>）,二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><p><img src="/2022/09/07/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p><h1 id="为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"><a href="#为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？" class="headerlink" title="为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"></a>为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？</h1><p>如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p><h1 id="Minor-GC触发条件"><a href="#Minor-GC触发条件" class="headerlink" title="Minor GC触发条件"></a>Minor GC触发条件</h1><p>当Eden区满时，触发Minor GC。</p><h1 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h1><p>（1）System.gc()方法的调用</p><blockquote><p>此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响性能，建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI（Java远程方法调用）调用System.gc。</p></blockquote><p>（2）老年代空间不足</p><blockquote><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space  为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></blockquote><p>（3）永久代(方法区)空间不足</p><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<br> java.lang.OutOfMemoryError: PermGen space<br> 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote><p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p><blockquote><p>如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC</p></blockquote><p>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p><h1 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h1><p><strong>作用：</strong></p><blockquote><p>1、防止指令重排</p><p>​        通过插入内存屏障的方式来防止指令重排，因为在创建对象的时候一般有三步，(1) 分配内存空间 (2) 初始化对象 (3) 将对象指向分配的内存地址 ，但是如果不防止指令重排就会出现 1 -&gt; 3 -&gt;2 这种情况，就会将一个没有初始化的对象暴露出来。</p><p>2、保证可见性(禁用CPU缓存)</p><p>​        由于每一个线程都拥有自己的一个告诉缓存区(线程的工作内存)，但是当你添加了volatile这个关键字的时候就会让所有线程读取这个参数的时候从主存中读取，保证元素的可见性。</p></blockquote><p>不使用<strong>volatile</strong>的多线程</p><p><img src="/2022/09/07/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/image-20220919101248662.png"></p><p>使用<strong>volatile</strong>的多线程</p><p><img src="/2022/09/07/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/image-20220919101344155.png"></p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><a href="https://zhuanlan.zhihu.com/p/127147909">HashMap原理详解</a></p><blockquote><p>如何获得key数组的下标？</p></blockquote><p>put的时候只对key进行hash运算</p><ol><li>获取到key的hashcode (32为的int值)</li><li>通过扰动函数（哈希函数）得到 newhash</li><li>下标 index = newhash &amp; ( table.length - 1) (逻辑与运算)</li></ol><blockquote><p><strong>newhash如何获得？</strong></p><p>​    通过传入的key的hashcode值的高16位与低16位进行异或(相同为0)运算</p></blockquote><p>hashmap的put操作是<strong>尾插法</strong></p><p><img src="/2022/09/07/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/image-20220920085449019.png" alt="put方法"></p><blockquote><p>hashmap 的put详解：</p></blockquote><p>1、先判断当前table是否为空，如果是空那么就进行初始化，让容器大小变成16。</p><p>2、根据key通过哈希算法与 与运算得到数组下标。</p><p>3、判断table[i]是否为空，如果是空那么就直接插入(1.7头插 1.8尾插)。</p><p>4、如果table[i]不是空，那么判断当前位置的node是什么node</p><p>​    a.如果是红黑树node则直接调用红黑树的方法插入键值对；</p><p>​    b.如果是链表node，那么先遍历链表node，判断一下链表node的key是不是与当前的key相等，是就替换旧值；如果链表中的key与当前key不相等，就直接插入链表(尾插法)，如果发现插入之后链表长度大于8，就转换为红黑树。</p><p>5、插入成功之后，令size++，如果元素个数(size)到达了(size = 容量 * 阈值)，就进行扩容。</p><p>6、扩容成功之后对元素的下标进行重新计算。</p><blockquote><p>hashmap的resize详解：</p></blockquote><p><img src="/2022/09/07/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85/image-20220920111625473.png"></p><ol><li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。</li><li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</li><li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。</li><li>对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。</li></ol><p><strong>扩展阅读</strong></p><p>例如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688931497/B7A9F3ADBA028FE6FDE22C94D566B4F1"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688954741/FB03BC4205AD26DC0210B12412AAC145"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688973970/C2928A93915A4AEF2709862EBAC8515C"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2022/08/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy_pattern</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//交班费方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;上交了班费&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//班长类 也就是代理类，代理学生完成上交班费</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//包含被代理类</span><br>    Student student;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Monitor</span><span class="hljs-params">(Person stu)</span> &#123;<br>        <span class="hljs-comment">//判断代理的是不是学生</span><br>        <span class="hljs-keyword">if</span> (stu.getClass() == Student.class) &#123;<br>            <span class="hljs-built_in">this</span>.student = (Student) stu;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//调用学生交班费方法</span><br>        student.giveMoney();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">stu1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;学生1&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Monitor</span>(stu1);<br>        monitor.giveMoney();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态代理（JDK代理模式）"><a href="#动态代理（JDK代理模式）" class="headerlink" title="动态代理（JDK代理模式）"></a>动态代理（JDK代理模式）</h1><p>动态代理其实就是在代理类的外部加了一层，每个代理方法都被一个固定方法代替。</p><p>实现动态代理需要 <strong>Proxy类和InvocationHandler接口</strong> 这个类可以理解成新加的那一层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.design_mode;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.design_mode</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: Proxy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/8/18 16:58</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy_model</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">//交班费方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//开会方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">metting</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">goout</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;上交了班费&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">metting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;到会&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goout</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;离会&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// StuInvocationHandler</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StuInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    Object user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StuInvocationHandler</span><span class="hljs-params">(Object user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.getClass().getClassLoader(), user.getClass().getInterfaces(), <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(user, args);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-keyword">new</span> <span class="hljs-title class_">StuInvocationHandler</span>(stu).getProxyInstance();<br>        proxyInstance.giveMoney();<br>        proxyInstance.metting();<br>        proxyInstance.goout();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要添加方法只需要在person类中添加相应接口，学生类实现即可。</p><p>我们可以看出，无论是静态代理还是上面的动态代理，被代理的对象都是接口，但有的时候被代理的对象只是一个对象，没有任何接口，这个时候就可以使用目标对象子类实现代理，也就是Cglib代理</p><h1 id="动态代理-Cglib代理模式"><a href="#动态代理-Cglib代理模式" class="headerlink" title="动态代理(Cglib代理模式)"></a>动态代理(Cglib代理模式)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy_2</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;交了班费&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">metting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;到会&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">getCglibProxy</span><span class="hljs-params">(Object targetObject)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = targetObject;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(targetObject.getClass());<br>        enhancer.setCallback(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> enhancer.create();<br>        <span class="hljs-keyword">return</span> (Person) res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(target, objects);<br>        <span class="hljs-keyword">return</span> invoke;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;student&quot;</span>);<br>        <span class="hljs-type">CglibProxy</span> <span class="hljs-variable">cglibProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibProxy</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">cglibProxy1</span> <span class="hljs-operator">=</span> cglibProxy.getCglibProxy(person);<br>        cglibProxy1.giveMoney();<br>        cglibProxy1.metting();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>CGLIB</strong>是针对类实现代理，主要是<strong>对指定的类生成一个子类，覆盖其中的方法 ，使用asm字节码框架实现，相关执行的过程比较高效，生成类的过程可以利用缓存弥补（不太懂），因为是继承，所以该类或方法最好不要声明成final</strong></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目总结</title>
    <link href="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h1><p>实现一个B2C模式的在线教育平台，拥有前台用户系统与后台运营。</p><p>要实现的功能：除了一些基础的功能以外，还要实现微信支付 微信登录 ，对于图片的存储采用了阿里云的oss，对于视频的存储以及播放 使用了阿里云点播，登录模块的发送验证码则是使用了阿里云的阿里云短信给手机发送一个短信验证码。</p><h1 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h1><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806202156218.png" alt="数据库的一些基本信息"></p><h1 id="三、项目基本结构"><a href="#三、项目基本结构" class="headerlink" title="三、项目基本结构"></a>三、项目基本结构</h1><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806205502916.png" alt="项目结构"></p><p><strong>guli-parent：在线教学根目录（父工程），管理四个子模块：</strong></p><ul><li><p><strong>canal-client：canal数据库表同步模块（统计同步数据）</strong></p></li><li><p><strong>common：公共模块父节点</strong></p><ul><li>common-util：工具类模块，所有模块都可以依赖于它</li><li>service-base：service服务的base包，包含service服务的公共配置类，所有service模块依赖于它</li><li>spring-security：认证与授权模块，需要认证授权的service服务依赖于它</li></ul></li><li><p><strong>infrastructure：基础服务模块父节点</strong></p><ul><li>api-gateway：api网关服务</li></ul></li><li><p><strong>service：api接口服务父节点</strong></p><ul><li>service-acl：用户权限管理api接口服务（用户管理、角色管理和权限管理等）</li><li>service-cms：cms api接口服务</li><li>service-edu：教学相关api接口服务</li><li>service-msm：短信api接口服务</li><li>service-order：订单相关api接口服务</li><li>service-oss：阿里云oss api接口服务</li><li>service-statistics：统计报表api接口服务</li><li>service-ucenter：会员api接口服务</li><li>service-vod：视频点播api接口服务</li></ul></li></ul><h2 id="3-1、common模块"><a href="#3-1、common模块" class="headerlink" title="3.1、common模块"></a>3.1、common模块</h2><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806205746603.png" alt="common"></p><hr><h3 id="3-1-1、common-utils"><a href="#3-1-1、common-utils" class="headerlink" title="3.1.1、common_utils"></a>3.1.1、common_utils</h3><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806205905785.png"></p><p><strong>最重要的是R类，是一个用于规范化全后端交互的数据传输的类。</strong>其中要定义处理状态码（前后端自行约定）</p><p>，处理结果（包含错误信息或者成功提示），数据三个条件。</p><p>整合了jwt的令牌的工具类</p><h3 id="3-1-2、service-base"><a href="#3-1-2、service-base" class="headerlink" title="3.1.2、service_base"></a>3.1.2、service_base</h3><p>添加了redis添加缓存的配置类</p><h2 id="3-2、service"><a href="#3-2、service" class="headerlink" title="3.2、service"></a>3.2、service</h2><p>该模块使用了mybatis-plus框架，每一个mapper接口都继承<strong>BaseMapper</strong>类来实现一些mp已经定义好的方法，以此来减少代码量。</p><p>基础框架都是使用mp自动生成代码实现。</p><h3 id="3-2-1、service-edu"><a href="#3-2-1、service-edu" class="headerlink" title="3.2.1、service_edu"></a>3.2.1、service_edu</h3><p>整体上使用@RestController注解用来返回一个json格式的字符串让前端接受，实现前后端交互。</p><p>实现方法：</p><hr><p><strong>后台：</strong></p><ul><li><p><strong><code>讲师模块</code></strong></p><ul><li>逻辑删除讲师信息。<ul><li>如何实现逻辑删除？ ——-&gt; 调用mp的按照id进行删除的方法，然后在配置逻辑删除的插件，并且在是否删除的实体类上加入**@TableLogic**注解来实现逻辑删除</li></ul></li><li>讲师分页功能<ul><li>使用了mp的分页插件，实现不带条件的分页功能的时候，使用mp自带的分页功能，没有条件的时候wrapper就为null，然后实现mp的自带的分页功能的方法</li></ul></li><li>条件查询带分页<ul><li>定义了一个用于返回带条件的查询分页的实体类，因为这次是带查询条件，所以定义了wrapper条件构造器，然后在wrapper中创建查询条件，其余与讲师分页功能的代码一致</li></ul></li><li>添加讲师</li><li>根据讲师id进行查询</li><li>修改讲师信息，都是使用了mp自带的功能。</li></ul></li><li><p><strong><code>课程分类管理</code></strong></p><ul><li><p>添加课程分类：使用easyexcel来实现从excel文件读取</p></li><li><p>获取课程分类列表：课程拥有一级二级目录</p><ul><li><p>如何实现拥有一级分类二级分类？ ——&gt; </p><ol><li><p>分别创建一级分类二级分类的实体类(一级分类的实体类中包含二级分类的实体类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个一级分类有多个二级分类</span><br><span class="hljs-keyword">private</span> List&lt;TwoSubject&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li><li><p>controller层中调用service接口中的方法</p></li><li><p>创建service对应的方法以及<strong>在实现类中实现这个方法</strong></p><p>思维：一级分类的pid == 0所以在wrapper条件构造器中定义所有pid == 0的就是一级分类；所以 pid != 0 的就是二级分类</p></li></ol></li></ul></li></ul></li><li><p><strong><code>课程模块</code></strong></p><ul><li><p>添加课程基本信息(前端用到富文本编辑器)</p><ul><li><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220807161956427.png" alt="课程信息流程"></li><li>1、创建了一个课程信息的实体类</li><li>2、controller层中调用service接口中的方法</li><li>3、完成service接口以及实现类</li></ul></li><li><p>当走到编辑课程大纲的时候，返回上一步的时候需要可以将信息返回，且可以修改信息(也就是所谓的数据回显)</p><ul><li>实现：通过查询id来实现</li><li><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220807234146208.png" alt="数据回显"></li></ul></li><li><p>更新课程信息（修改课程信息）</p><ul><li>使用mp的updateById方法</li></ul></li><li><p>课程列表大纲 </p><ul><li>获得课程列表大纲（和之前的一级分类二级分类代码基本一致） </li><li>新增章节<ul><li>添加小节</li><li>删除小节</li></ul></li><li>通过id查询章节信息</li><li>更新章节信息</li><li>删除章节信息<ul><li>删除章节信息的时候需要注意 如果该章节有小节的时候就会停止删除章节</li></ul></li></ul></li><li><p>课程的课时信息</p><ul><li><p>增加课时</p></li><li><p>根据小节id查询课时</p></li><li><p>修改小节     前三者都是用的是mp的方法</p></li><li><p>删除小节以及对应的阿里云视频</p><ul><li>1、根据小节id获取视频id，调用方法实现视频删除(调用方法的时候使用了nacos远程调用nacos服务中心的方法来实现对视频的删除)</li><li>2、利用nacos服务中心来调用service-vod中已经写好的删除视频的方法</li><li>3、删除小节的时候使用mp的方法</li></ul></li></ul></li><li><p>课程最终发布</p><ul><li>根据id查询课程发布信息，需要通过多张表进行查询（建议使用数据访问层进行关联查询也就是mapper）<ul><li>首先定义一个只有所需信息的实体类vo</li><li>在mapper层定义好方法，然后再mapper.xml中写入对应的sql语句</li><li>在业务层(service)层中写一个接口，实现类中调用mapper层中的方法。</li></ul></li><li>发布课程是需要改变课程的状态status表<ul><li>本质上是一个修改语句 修改状态表即可</li></ul></li></ul></li><li><p>课程列表的显示（分页查询带条件）</p><ul><li>直接在controller层中进行代码的写，利用wrapper条件构造器</li></ul></li><li><p>删除课程</p><ul><li>删除课程中 需要实现 先删除小节(删除小节的时候如果小节有视频 那么就要先删除视频 所有其中会调用删除视频以及删除多个视频) 删除章节 在删除课程描述 最后删除课程</li></ul></li></ul></li></ul><hr><p><strong>前台：</strong></p><ul><li><p>首页展示前八名热门课程以及前四名热门老师</p></li><li><p>分页查询讲师</p><ul><li>利用了分页查询插件 在wrapper条件构造器中进行条件的增加</li></ul></li><li><p>根据讲师id查询讲师所讲课程列表</p><ul><li>也就是查询了课程的讲师id == teacher_id 的课程</li></ul></li><li><p>分页查询显示课程信息</p><ul><li>创建了一个用于课程展示的vo实体类</li><li>剩下的就是利用wrapper条件构造器进行条件判断 判断用户查询的时候使用的是什么条件以及查询出来的结果按照什么进行分类</li></ul></li><li><p>课程详情</p><ul><li>创建了一个展示课程详情信息的vo实体类</li><li>然后通过课程id来查询课程相关信息以及课程讲师信息，由于需要查询的有课程信息以及课程讲师的信息，所以是一个多表查询的sql，不能使用mp的相关方法，只能自己手写sql然后实现</li><li>在controller层中要查询课程信息以及查询课程的章节以及小节还要通过nacos远程调用order模块中的查询课程是否被购买</li></ul></li></ul><h3 id="3-2-2、service-oss"><a href="#3-2-2、service-oss" class="headerlink" title="3.2.2、service_oss"></a>3.2.2、service_oss</h3><p><strong>后台：</strong></p><ul><li><p>用于后台集成oss(阿里云对象存储)</p><ul><li><p>配置oss的application.properties（根据阿里云oss指导文档）</p></li><li><p>当执行的时候会发现会报错，会报没有找到数据库的错误，但是这个部分是不会与数据库进行连接，所以使用<code>@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) </code>来不自动加载数据库</p><p>​    1.创建常量的配置文件，以便于读取数据</p><p>​    2.根据阿里云的oss使用指导，完成Service层的代码</p><p>​    3.在控制层调用</p></li></ul></li></ul><h3 id="3-2-3、service-vod"><a href="#3-2-3、service-vod" class="headerlink" title="3.2.3、service_vod"></a>3.2.3、service_vod</h3><p><strong>后台：</strong></p><ul><li>阿里云视频点播<ul><li>阿里云上传视频</li><li>删除阿里云云端视频（通过视频id删除以及删除多个视频）</li></ul></li></ul><p><strong>前台：</strong></p><ul><li>根据视频id获取视频的播放凭证传递给前端让前端根据视频凭证播放视频</li></ul><h3 id="3-2-4、service-cms"><a href="#3-2-4、service-cms" class="headerlink" title="3.2.4、service_cms"></a>3.2.4、service_cms</h3><p><strong>后台：</strong></p><ul><li>后台轮播图的图片管理以及分页查询<ul><li>轮播图(banner)的增删改查，调用mp的增删改查方法，分页查询使用mp.page();</li></ul></li></ul><hr><p><strong>前台：</strong></p><ul><li><p>前台首页轮播图的查询全部 也就是展示轮播图</p><ul><li><p>调用service层的查询所有轮播图的方法</p><ul><li><p>实质是根据id进行查询并且只展示两个轮播图</p></li><li><p>由于首页banner轮播图是经常访问并且不怎么改变的 所以使用redia缓存来进行存储，可以做到减少数据库压力的作用</p><ul><li><p>在banner的properties中添加了redis的相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">192.168.44.132</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment">#最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure></li><li><p>在banner的service的实现类中添加了加入缓存的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(key = &quot;&#x27;selectIndexList&#x27;&quot;,value = &quot;banner&quot;)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="3-2-5、service-msm"><a href="#3-2-5、service-msm" class="headerlink" title="3.2.5、service_msm"></a>3.2.5、service_msm</h3><ul><li><p>短信微服务</p><ul><li><p>运用了阿里云短信服务</p><ul><li><p>引入pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/edumsm/msm&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsmController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsmService msmService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;<br><br>    <span class="hljs-comment">// 发送短信的方法</span><br>    <span class="hljs-meta">@GetMapping(&quot;send/&#123;phone&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">sendMsm</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String phone)</span>&#123;<br><br>        <span class="hljs-comment">//先从redis中获取，如果获取到直接返回</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(phone);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(code))&#123;<br>            System.out.println(code);<br>            <span class="hljs-keyword">return</span> R.ok();<br>        &#125;<br>        <span class="hljs-comment">//如果取不到，进行阿里云发送</span><br><br>        <span class="hljs-comment">//生成随机验证码，传递给阿里云进行发送</span><br>        code = RandomUtil.getFourBitRandom();<br>        Map&lt;String,Object&gt; param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        param.put(<span class="hljs-string">&quot;code&quot;</span>,code);<br>        <span class="hljs-comment">//调用service发送短信</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSend</span> <span class="hljs-operator">=</span> msmService.send(param,phone);<br>        <span class="hljs-keyword">if</span> (isSend)&#123;<br>            <span class="hljs-comment">//发送成功，将发送成功的验证码放到redis里面</span><br>            redisTemplate.opsForValue().set(phone,code,<span class="hljs-number">5</span>, TimeUnit.MINUTES);<br>            <span class="hljs-comment">//设置有效时间</span><br>            <span class="hljs-keyword">return</span> R.ok();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> R.error().message(<span class="hljs-string">&quot;短信发送失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsmServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsmService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送短信</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String PhoneNumbers, String templateCode, Map&lt;String,Object&gt; param)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(PhoneNumbers)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">DefaultProfile</span> <span class="hljs-variable">profile</span> <span class="hljs-operator">=</span><br>                DefaultProfile.getProfile(<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;LTAIq6nIPY09VROj&quot;</span>, <span class="hljs-string">&quot;FQ7UcixT9wEqMv9F35nORPqKr8XkTF&quot;</span>);<br>        <span class="hljs-type">IAcsClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultAcsClient</span>(profile);<br><br>        <span class="hljs-type">CommonRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonRequest</span>();<br>        <span class="hljs-comment">//request.setProtocol(ProtocolType.HTTPS);</span><br>        request.setMethod(MethodType.POST);<br>        request.setDomain(<span class="hljs-string">&quot;dysmsapi.aliyuncs.com&quot;</span>);<br>        request.setVersion(<span class="hljs-string">&quot;2017-05-25&quot;</span>);<br>        request.setAction(<span class="hljs-string">&quot;SendSms&quot;</span>);<br><br>        request.putQueryParameter(<span class="hljs-string">&quot;PhoneNumbers&quot;</span>, PhoneNumbers);<br>        request.putQueryParameter(<span class="hljs-string">&quot;SignName&quot;</span>, <span class="hljs-string">&quot;我的谷粒在线教育网站&quot;</span>);<br>        request.putQueryParameter(<span class="hljs-string">&quot;TemplateCode&quot;</span>, templateCode);<br>        request.putQueryParameter(<span class="hljs-string">&quot;TemplateParam&quot;</span>, JSONObject.toJSONString(param));<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">CommonResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.getCommonResponse(request);<br>            System.out.println(response.getData());<br>            <span class="hljs-keyword">return</span> response.getHttpResponse().isSuccess();<br>        &#125; <span class="hljs-keyword">catch</span> (ServerException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClientException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="3-2-6、service-ucenter"><a href="#3-2-6、service-ucenter" class="headerlink" title="3.2.6、service_ucenter"></a>3.2.6、service_ucenter</h3><ul><li>前台登录模块<ul><li>登录功能<ul><li>在controller层中调用service层的登录login方法</li><li>service层的实现类中写login方法的实现<ul><li>其中运用了wrapper条件构造器对手机号以及密码进行非空的判断，判断手机号是否正确，手机号是否存在以及判断密码是否正确，但是判断密码的时候需要使用MD5进行判断，因为数据库不会存密码 而是会存入MD5加密之后的密码</li><li>当用户登录成功之后会利用之前common_utils之中jwt工具类的getJwtToken方法将你的登录信息变成token存储实现单点登录。</li></ul></li></ul></li><li>注册功能<ul><li>controller层中调用service层的注册register方法</li><li>service层中实现register方法<ul><li>注册的时候需要判断账号密码验证码以及昵称是否为空，判断验证码与redis中的验证码是否一样以及手机号是否重复，最后将用户信息写进数据库中。</li></ul></li></ul></li><li>根据token获取用户信息<ul><li>用处：为了前台的前端的右上角展示你自己的头像以及姓名    </li><li>实现：调用jwt的方法来获得request中的用户id，然后根据这个id在数据库中查询数据</li></ul></li><li>统计某天注册人数<ul><li>实质上就是一个sql语句 通过前端传来的day与数据库ucenter_member表中的gmt_create对比 一样的就 count。</li></ul></li></ul></li></ul><h3 id="3-2-7、service-order"><a href="#3-2-7、service-order" class="headerlink" title="3.2.7、service_order"></a>3.2.7、service_order</h3><ul><li><p>前台支付模块</p><ul><li><p>创建订单</p><ul><li><p>对于订单而言 你要是想要生成订单 就会需要课程信息以及用户信息</p><ul><li>所以 需要在edu模块下编写根据课程id获得课程信息以及在ucenter模块下根据用户id获取用户信息 然后将这些信息设置到order中 其中生成订单号的相关信息运用了一个工具类(生成随机数)</li></ul><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220810192754575.png"></p></li></ul></li><li><p>查询订单是否支付(如果没有支付 那么就前往支付页面)</p></li><li><p>生成支付二维码</p><ul><li>根据订单号查询订单状态</li><li>使用map集合设置生成二维码需要的参数**(固定值)**</li><li>发送httpclient请求，传递参数使用xml格式，微信支付提供的地址**(利用HttpClient，参数是固定的)**</li><li>得到发送请求返回的结果</li><li>将xml格式转换成map集合(将订单号 课程id 价格 返回二维码操作的状态码  二维码地址)</li></ul></li><li><p>获取支付状态</p><ul><li>根据订单号查询订单支付状态(固定格式)</li><li>并且更新订单表的支付状态(通过传来的map集合 获取订单号 查询订单是否支付 更新订单信息 向支付表中添加信息)</li></ul></li><li><p>通过课程id和用户id查询课程是否被购买</p></li></ul></li></ul><h3 id="3-2-8、service-statistics"><a href="#3-2-8、service-statistics" class="headerlink" title="3.2.8、service_statistics"></a>3.2.8、service_statistics</h3><ul><li>统计分析模块<ul><li>统计某一天注册的人数<ul><li>注册人数相关  所以在ucenter模块中书写代码 然后通过nacos远程调用。</li><li>1、添加记录之前删除表相同日期的数据</li><li>2、远程调用得到某一天注册人数</li><li>3、把获取数据添加数据库，统计分析表里面</li><li>4、生成随机数(视频播放数 登录人数 课程播放数量)</li><li><strong>思考：</strong>何时让这个方法运行？<ul><li>起码不能每天自己运行一次吧？ 于是使用了定时任务(cron表达式)</li><li>写好日期工具类之后在启动类之上添加注解：<code>@EnableScheduling</code></li></ul></li></ul></li><li>数据图表的显示<ul><li>controller层调用service方法</li><li>service层中 现根据条件查询对应数据(起始时间以及统计日期) 然后创建日期 和 日期对应数量的list集合  遍历所有list集合(就是之前的查询出来的数据) 然后封装对应的日期list集合，封装各个时间的数量(登录人数 注册人数 每日新增课程数 每日视频播放数) 最后将这两个list即可放到一个map集合中 最后返回</li></ul></li></ul></li></ul><h3 id="3-2-9、service-acl"><a href="#3-2-9、service-acl" class="headerlink" title="3.2.9、service-acl"></a>3.2.9、service-acl</h3><ul><li>权限管理服务</li><li><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220811135031947.png"><ul><li>获取全部权限菜单（递归查询所有菜单）<ul><li>先查询所有菜单</li><li>然后查询一级菜单</li><li>然后根据一级菜单.id == 当前菜单.pid 得到2 ~ n 级菜单</li></ul></li><li>递归删除菜单<ul><li><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220811170108610.png"></li></ul></li><li>给角色分配权限<br>+ </li></ul></li></ul><h2 id="3-3、infrastructure"><a href="#3-3、infrastructure" class="headerlink" title="3.3、infrastructure"></a>3.3、infrastructure</h2><h3 id="3-3-1、api-gateway"><a href="#3-3-1、api-gateway" class="headerlink" title="3.3.1、api-gateway"></a>3.3.1、api-gateway</h3><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 服务端口</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8222</span><br><span class="hljs-comment"># 服务名</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">service-gateway</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># nacos服务地址</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#使用服务发现路由</span><br><span class="hljs-attr">spring.cloud.gateway.discovery.locator.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#服务路由名小写</span><br><span class="hljs-comment">#spring.cloud.gateway.discovery.locator.lower-case-service-id=true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#设置路由id</span><br><span class="hljs-attr">spring.cloud.gateway.routes[0].id</span>=<span class="hljs-string">service-acl</span><br><span class="hljs-comment">#设置路由的uri</span><br><span class="hljs-attr">spring.cloud.gateway.routes[0].uri</span>=<span class="hljs-string">lb://service-acl</span><br><span class="hljs-comment">#设置路由断言,代理servicerId为auth-service的/auth/路径</span><br><span class="hljs-attr">spring.cloud.gateway.routes[0].predicates</span>= <span class="hljs-string">Path=/*/acl/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#配置service-edu服务</span><br><span class="hljs-attr">spring.cloud.gateway.routes[1].id</span>=<span class="hljs-string">service-edu</span><br><span class="hljs-attr">spring.cloud.gateway.routes[1].uri</span>=<span class="hljs-string">lb://service-edu</span><br><span class="hljs-attr">spring.cloud.gateway.routes[1].predicates</span>= <span class="hljs-string">Path=/eduservice/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#配置service-ucenter服务</span><br><span class="hljs-attr">spring.cloud.gateway.routes[2].id</span>=<span class="hljs-string">service-ucenter</span><br><span class="hljs-attr">spring.cloud.gateway.routes[2].uri</span>=<span class="hljs-string">lb://service-ucenter</span><br><span class="hljs-attr">spring.cloud.gateway.routes[2].predicates</span>= <span class="hljs-string">Path=/ucenterservice/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#配置service-ucenter服务</span><br><span class="hljs-attr">spring.cloud.gateway.routes[3].id</span>=<span class="hljs-string">service-cms</span><br><span class="hljs-attr">spring.cloud.gateway.routes[3].uri</span>=<span class="hljs-string">lb://service-cms</span><br><span class="hljs-attr">spring.cloud.gateway.routes[3].predicates</span>= <span class="hljs-string">Path=/cmsservice/**</span><br><br><span class="hljs-attr">spring.cloud.gateway.routes[4].id</span>=<span class="hljs-string">service-msm</span><br><span class="hljs-attr">spring.cloud.gateway.routes[4].uri</span>=<span class="hljs-string">lb://service-msm</span><br><span class="hljs-attr">spring.cloud.gateway.routes[4].predicates</span>= <span class="hljs-string">Path=/edumsm/**</span><br><br><span class="hljs-attr">spring.cloud.gateway.routes[5].id</span>=<span class="hljs-string">service-order</span><br><span class="hljs-attr">spring.cloud.gateway.routes[5].uri</span>=<span class="hljs-string">lb://service-order</span><br><span class="hljs-attr">spring.cloud.gateway.routes[5].predicates</span>= <span class="hljs-string">Path=/orderservice/**</span><br><br><span class="hljs-attr">spring.cloud.gateway.routes[6].id</span>=<span class="hljs-string">service-order</span><br><span class="hljs-attr">spring.cloud.gateway.routes[6].uri</span>=<span class="hljs-string">lb://service-order</span><br><span class="hljs-attr">spring.cloud.gateway.routes[6].predicates</span>= <span class="hljs-string">Path=/orderservice/**</span><br><br><span class="hljs-attr">spring.cloud.gateway.routes[7].id</span>=<span class="hljs-string">service-oss</span><br><span class="hljs-attr">spring.cloud.gateway.routes[7].uri</span>=<span class="hljs-string">lb://service-oss</span><br><span class="hljs-attr">spring.cloud.gateway.routes[7].predicates</span>= <span class="hljs-string">Path=/eduoss/**</span><br><br><span class="hljs-attr">spring.cloud.gateway.routes[8].id</span>=<span class="hljs-string">service-statistic</span><br><span class="hljs-attr">spring.cloud.gateway.routes[8].uri</span>=<span class="hljs-string">lb://service-statistic</span><br><span class="hljs-attr">spring.cloud.gateway.routes[8].predicates</span>= <span class="hljs-string">Path=/staservice/**</span><br><br><span class="hljs-attr">spring.cloud.gateway.routes[9].id</span>=<span class="hljs-string">service-vod</span><br><span class="hljs-attr">spring.cloud.gateway.routes[9].uri</span>=<span class="hljs-string">lb://service-vod</span><br><span class="hljs-attr">spring.cloud.gateway.routes[9].predicates</span>= <span class="hljs-string">Path=/eduvod/**</span><br><br><span class="hljs-attr">spring.cloud.gateway.routes[10].id</span>=<span class="hljs-string">service-edu</span><br><span class="hljs-attr">spring.cloud.gateway.routes[10].uri</span>=<span class="hljs-string">lb://service-edu</span><br><span class="hljs-attr">spring.cloud.gateway.routes[10].predicates</span>= <span class="hljs-string">Path=/eduuser/**</span><br></code></pre></td></tr></table></figure><p>1、配置网关解决跨域问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        config.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br><br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PathPatternParser</span>());<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsWebFilter</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、配置filter过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 全局Filter，统一处理会员登录与外部不允许访问的服务</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> qy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2019-11-21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">antPathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getURI().getPath();<br>        <span class="hljs-comment">//谷粒学院api接口，校验用户必须登录</span><br>        <span class="hljs-keyword">if</span>(antPathMatcher.match(<span class="hljs-string">&quot;/api/**/auth/**&quot;</span>, path)) &#123;<br>            List&lt;String&gt; tokenList = request.getHeaders().get(<span class="hljs-string">&quot;token&quot;</span>);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> == tokenList) &#123;<br>                <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>                <span class="hljs-keyword">return</span> out(response);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//                Boolean isCheck = JwtUtils.checkToken(tokenList.get(0));</span><br><span class="hljs-comment">//                if(!isCheck) &#123;</span><br>                    <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>                    <span class="hljs-keyword">return</span> out(response);<br><span class="hljs-comment">//                &#125;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//内部服务接口，不允许外部访问</span><br>        <span class="hljs-keyword">if</span>(antPathMatcher.match(<span class="hljs-string">&quot;/**/inner/**&quot;</span>, path)) &#123;<br>            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>            <span class="hljs-keyword">return</span> out(response);<br>        &#125;<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Mono&lt;Void&gt; <span class="hljs-title function_">out</span><span class="hljs-params">(ServerHttpResponse response)</span> &#123;<br>        <span class="hljs-type">JsonObject</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObject</span>();<br>        message.addProperty(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>        message.addProperty(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">28004</span>);<br>        message.addProperty(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;鉴权失败&quot;</span>);<br>        <span class="hljs-type">byte</span>[] bits = message.toString().getBytes(StandardCharsets.UTF_8);<br>        <span class="hljs-type">DataBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> response.bufferFactory().wrap(bits);<br>        <span class="hljs-comment">//response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br>        <span class="hljs-comment">//指定编码，否则在浏览器中会中文乱码</span><br>        response.getHeaders().add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        <span class="hljs-keyword">return</span> response.writeWith(Mono.just(buffer));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、自定义异常处理</p><p><strong>ErrorHandlerConfig：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 覆盖默认的异常处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinjihuan</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;ServerProperties.class, ResourceProperties.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorHandlerConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerProperties serverProperties;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ResourceProperties resourceProperties;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ErrorHandlerConfig</span><span class="hljs-params">(ServerProperties serverProperties,</span><br><span class="hljs-params">                                     ResourceProperties resourceProperties,</span><br><span class="hljs-params">                                     ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,</span><br><span class="hljs-params">                                        ServerCodecConfigurer serverCodecConfigurer,</span><br><span class="hljs-params">                                     ApplicationContext applicationContext)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serverProperties = serverProperties;<br>        <span class="hljs-built_in">this</span>.applicationContext = applicationContext;<br>        <span class="hljs-built_in">this</span>.resourceProperties = resourceProperties;<br>        <span class="hljs-built_in">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);<br>        <span class="hljs-built_in">this</span>.serverCodecConfigurer = serverCodecConfigurer;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br>    <span class="hljs-keyword">public</span> ErrorWebExceptionHandler <span class="hljs-title function_">errorWebExceptionHandler</span><span class="hljs-params">(ErrorAttributes errorAttributes)</span> &#123;<br>        <span class="hljs-type">JsonExceptionHandler</span> <span class="hljs-variable">exceptionHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonExceptionHandler</span>(<br>                errorAttributes,<br>                <span class="hljs-built_in">this</span>.resourceProperties,<br>                <span class="hljs-built_in">this</span>.serverProperties.getError(),<br>                <span class="hljs-built_in">this</span>.applicationContext);<br>        exceptionHandler.setViewResolvers(<span class="hljs-built_in">this</span>.viewResolvers);<br>        exceptionHandler.setMessageWriters(<span class="hljs-built_in">this</span>.serverCodecConfigurer.getWriters());<br>        exceptionHandler.setMessageReaders(<span class="hljs-built_in">this</span>.serverCodecConfigurer.getReaders());<br>        <span class="hljs-keyword">return</span> exceptionHandler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>JsonExceptionHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义异常处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;异常时用JSON代替HTML异常信息&lt;p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultErrorWebExceptionHandler</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsonExceptionHandler</span><span class="hljs-params">(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,</span><br><span class="hljs-params">                                ErrorProperties errorProperties, ApplicationContext applicationContext)</span> &#123;<br>        <span class="hljs-built_in">super</span>(errorAttributes, resourceProperties, errorProperties, applicationContext);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取异常属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getErrorAttributes</span><span class="hljs-params">(ServerRequest request, <span class="hljs-type">boolean</span> includeStackTrace)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>        map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">20005</span>);<br>        map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;网关失败&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定响应处理方法为JSON处理的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> errorAttributes</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="hljs-title function_">getRoutingFunction</span><span class="hljs-params">(ErrorAttributes errorAttributes)</span> &#123;<br>        <span class="hljs-keyword">return</span> RouterFunctions.route(RequestPredicates.all(), <span class="hljs-built_in">this</span>::renderErrorResponse);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据code获取对应的HttpStatus</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> errorAttributes</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> HttpStatus <span class="hljs-title function_">getHttpStatus</span><span class="hljs-params">(Map&lt;String, Object&gt; errorAttributes)</span> &#123;<br>        <span class="hljs-keyword">return</span> HttpStatus.OK;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、新增技术"><a href="#四、新增技术" class="headerlink" title="四、新增技术"></a>四、新增技术</h1><h2 id="4-1、跨域"><a href="#4-1、跨域" class="headerlink" title="4.1、跨域"></a>4.1、跨域</h2><p>跨域问题的解决方法：加入**@CrossOrigin**注解。</p><h2 id="4-2、Swagger"><a href="#4-2、Swagger" class="headerlink" title="4.2、Swagger"></a>4.2、Swagger</h2><p>一个可以迅速帮我们编写一个可视化的api接口文档，使用时需要添加一些注解以及配文件。</p><p>由于是项目所有模块都要使用的东西，所以一般配置在一个common模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">webApiConfig</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;webApi&quot;</span>)<br>                .apiInfo(webApiInfo())<br>                .select()<br>                .paths(Predicates.not(PathSelectors.regex(<span class="hljs-string">&quot;/admin/.*&quot;</span>)))<br>                .paths(Predicates.not(PathSelectors.regex(<span class="hljs-string">&quot;/error.*&quot;</span>)))<br>                .build();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">webApiInfo</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;网站-课程中心API文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;本文档描述了课程中心微服务接口定义&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;Helen&quot;</span>, <span class="hljs-string">&quot;http://atguigu.com&quot;</span>, <span class="hljs-string">&quot;55317332@qq.com&quot;</span>))<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后再在其他要使用swagger的模块中写入swagger的相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>service-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-3、OSS"><a href="#4-3、OSS" class="headerlink" title="4.3、OSS"></a>4.3、OSS</h2><p>使用阿里云的OSS来存储头像。</p><p><strong>如何使用：</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 阿里云oss依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 日期工具栏依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>joda-time<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>joda-time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#服务端口</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8002</span><br><span class="hljs-comment">#服务名</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">service-oss</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#环境设置：dev、test、prod</span><br><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">dev</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">#阿里云 OSS</span><br><span class="hljs-comment">#不同的服务器，地址不同</span><br><span class="hljs-attr">aliyun.oss.file.endpoint</span>=<span class="hljs-string">your endpoint</span><br><span class="hljs-attr">aliyun.oss.file.keyid</span>=<span class="hljs-string">your accessKeyId</span><br><span class="hljs-attr">aliyun.oss.file.keysecret</span>=<span class="hljs-string">your accessKeySecret</span><br><span class="hljs-comment">#bucket可以在控制台创建，也可以使用java代码创建</span><br><span class="hljs-attr">aliyun.oss.file.bucketname</span>=<span class="hljs-string">guli-file</span><br></code></pre></td></tr></table></figure></li><li><p>写一个配置类用于拿到所需要的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 常量类，读取配置文件application.properties中的配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-comment">//@PropertySource(&quot;classpath:application.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantPropertiesUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String endpoint;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String keyId;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String keySecret;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.filehost&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String fileHost;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String bucketName;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String END_POINT;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String ACCESS_KEY_ID;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String ACCESS_KEY_SECRET;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String BUCKET_NAME;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String FILE_HOST ;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>END_POINT = endpoint;<br>ACCESS_KEY_ID = keyId;<br>ACCESS_KEY_SECRET = keySecret;<br>BUCKET_NAME = bucketName;<br>FILE_HOST = fileHost;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过io流来上传文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileService</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span> &#123;<br><br><span class="hljs-comment">//获取阿里云存储相关常量</span><br><span class="hljs-type">String</span> <span class="hljs-variable">endPoint</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.END_POINT;<br><span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.ACCESS_KEY_ID;<br><span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.ACCESS_KEY_SECRET;<br><span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.BUCKET_NAME;<br><span class="hljs-type">String</span> <span class="hljs-variable">fileHost</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.FILE_HOST;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">uploadUrl</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//判断oss实例是否存在：如果不存在则创建，如果存在则获取</span><br><span class="hljs-type">OSSClient</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClient</span>(endPoint, accessKeyId, accessKeySecret);<br><span class="hljs-keyword">if</span> (!ossClient.doesBucketExist(bucketName)) &#123;<br><span class="hljs-comment">//创建bucket</span><br>ossClient.createBucket(bucketName);<br><span class="hljs-comment">//设置oss实例的访问权限：公共读</span><br>ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead);<br>&#125;<br><br><span class="hljs-comment">//获取上传文件流</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();<br><br><span class="hljs-comment">//构建日期路径：avatar/2019/02/26/文件名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>().toString(<span class="hljs-string">&quot;yyyy/MM/dd&quot;</span>);<br><br><span class="hljs-comment">//文件名：uuid.扩展名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br><span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><span class="hljs-type">String</span> <span class="hljs-variable">fileType</span> <span class="hljs-operator">=</span> original.substring(original.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> fileName + fileType;<br><span class="hljs-type">String</span> <span class="hljs-variable">fileUrl</span> <span class="hljs-operator">=</span> fileHost + <span class="hljs-string">&quot;/&quot;</span> + filePath + <span class="hljs-string">&quot;/&quot;</span> + newName;<br><br><span class="hljs-comment">//文件上传至阿里云</span><br>ossClient.putObject(bucketName, fileUrl, inputStream);<br><br><span class="hljs-comment">// 关闭OSSClient。</span><br>ossClient.shutdown();<br><br><span class="hljs-comment">//获取url地址</span><br>uploadUrl = <span class="hljs-string">&quot;http://&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endPoint + <span class="hljs-string">&quot;/&quot;</span> + fileUrl;<br><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuliException</span>(ResultCodeEnum.FILE_UPLOAD_ERROR);<br>&#125;<br><br><span class="hljs-keyword">return</span> uploadUrl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-4、EasyExcel导入"><a href="#4-4、EasyExcel导入" class="headerlink" title="4.4、EasyExcel导入"></a>4.4、EasyExcel导入</h2><ul><li><p>读：</p><ul><li><p>1、创建一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadData</span> &#123;<br>    <span class="hljs-comment">//设置列对应的属性</span><br>    <span class="hljs-meta">@ExcelProperty(index = 0)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sid;<br>    <br>    <span class="hljs-comment">//设置列对应的属性</span><br>    <span class="hljs-meta">@ExcelProperty(index = 1)</span><br>    <span class="hljs-keyword">private</span> String sname;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSid</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sid;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSid</span><span class="hljs-params">(<span class="hljs-type">int</span> sid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sid = sid;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSname</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sname;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSname</span><span class="hljs-params">(String sname)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sname = sname;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ReadData&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;sid=&quot;</span> + sid +<br>                <span class="hljs-string">&quot;, sname=&#x27;&quot;</span> + sname + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>2、创建读取操作的监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> com.alibaba.excel.context.AnalysisContext;<br><span class="hljs-keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;<br><span class="hljs-keyword">import</span> com.alibaba.excel.exception.ExcelDataConvertException;<br><span class="hljs-keyword">import</span> com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">//创建读取excel监听器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExcelListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AnalysisEventListener</span>&lt;ReadData&gt; &#123;<br><br>    <span class="hljs-comment">//创建list集合封装最终的数据</span><br>    List&lt;ReadData&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ReadData&gt;();<br><br>    <span class="hljs-comment">//一行一行去读取excle内容</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(ReadData user, AnalysisContext analysisContext)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;***&quot;</span>+user);<br>        list.add(user);<br>    &#125;<br><br>    <span class="hljs-comment">//读取excel表头信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeHeadMap</span><span class="hljs-params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;表头信息：&quot;</span>+headMap);<br>    &#125;<br><br>    <span class="hljs-comment">//读取完成后执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext analysisContext)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3、调用实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 写法1：</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;F:\\01.xlsx&quot;</span>;<br>        <span class="hljs-comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span><br>        EasyExcel.read(fileName, ReadData.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExcelListener</span>()).sheet().doRead();<br><br>        <span class="hljs-comment">// 写法2：</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;F:\\01.xlsx&quot;</span>));<br>        <span class="hljs-type">ExcelReader</span> <span class="hljs-variable">excelReader</span> <span class="hljs-operator">=</span> EasyExcel.read(in, ReadData.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExcelListener</span>()).build();<br>        <span class="hljs-type">ReadSheet</span> <span class="hljs-variable">readSheet</span> <span class="hljs-operator">=</span> EasyExcel.readSheet(<span class="hljs-number">0</span>).build();<br>        excelReader.read(readSheet);<br>        <span class="hljs-comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span><br>        excelReader.finish();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-5、阿里云视频点播"><a href="#4-5、阿里云视频点播" class="headerlink" title="4.5、阿里云视频点播"></a>4.5、阿里云视频点播</h2><h2 id="4-6、nacos服务调用"><a href="#4-6、nacos服务调用" class="headerlink" title="4.6、nacos服务调用"></a>4.6、nacos服务调用</h2><p><strong>注册nacos步骤：</strong></p><p>1、配置nacos 的pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在application.properties中添加服务配置信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># nacos服务地址</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span><br></code></pre></td></tr></table></figure><p>3、在启动类上加入一个注解 <code>@EnableDiscoveryClient</code></p><p>4、启动nacos</p><p><strong>调用nacos中心的服务：</strong></p><p>1、配置fegin的pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在调用端的启动类加入注解 <code>@EnableFeignClients</code></p><p>3、创建client包，接口和实现类</p><p>@FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。</p><p>@GetMapping注解用于对被调用的微服务进行地址映射。</p><p>@PathVariable注解一定要指定参数名称，否则出错</p><p>@Component注解防止，在其他位置注入CodClient时idea报错</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220808180548031.png"></p><p>从此以后就可以直接调用方法进行使用。</p><p><strong>Hystrix熔断机制：</strong></p><p>1、在properties中添加一个配置信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#开启熔断机制</span><br><span class="hljs-attr">feign.hystrix.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 设置hystrix超时时间，默认1000ms</span><br><span class="hljs-comment"># hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000</span><br></code></pre></td></tr></table></figure><p>在feign的注释上加上一个回调的注释</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220808184025041.png"></p><p>当超过properties配置文件中规定的时间之后就会回调fallback中的函数</p><h2 id="4-7、redis缓存"><a href="#4-7、redis缓存" class="headerlink" title="4.7、redis缓存"></a>4.7、redis缓存</h2><p>首先要清除三个注解：</p><p>1、缓存<code>@Cacheable</code></p><p>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</p><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><p>2、缓存<code>@CachePut</code></p><p>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</p><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><p>3、缓存<code>@CacheEvict</code></p><p>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上</p><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr><tr><td>allEntries</td><td>是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存</td></tr><tr><td>beforeInvocation</td><td>是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存</td></tr></tbody></table><p><strong>操作步骤：</strong></p><p>1、导入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、导入配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">//key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>        <span class="hljs-comment">//value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>              .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在对应的模块下面的配置文件添加redis的相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">192.168.44.132</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment">#最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><p>4、在实现类上添加注解：  <code>@Cacheable(value = &quot;xxx&quot;, key = &quot;&#39;xxx&#39;&quot;)</code></p><h2 id="4-8、用户登录"><a href="#4-8、用户登录" class="headerlink" title="4.8、用户登录"></a>4.8、用户登录</h2><p>使用oss单点登录，SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809110530617.png"></p><p>用户的单点登录有三个途径：</p><p>​    1、session广播机制</p><p>​    2、使用cookie + redis实现</p><p>​    3、使用token实现(推荐使用)</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809112726252.png" alt="单点登录的三个途径"></p><h3 id="4-8-1、使用JWT进行跨域身份验证"><a href="#4-8-1、使用JWT进行跨域身份验证" class="headerlink" title="4.8.1、使用JWT进行跨域身份验证"></a>4.8.1、使用JWT进行跨域身份验证</h3><p>token就是按照一定规则生成字符串，字符串可以包含用户信息</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809113508132.png"></p><p>1.在项目某个模块进行登录，登录之后，按照规则生成字符串，把登陆之后用户包含到生成字符串里面，把字符串返回</p><p>(1)可以把字符串通过cookie返回</p><p>(2)把字符串通过地址栏返回</p><p>2.再去访问项目其他模块，每次访问在地址栏带着生成的字符串，在访问模块里面获取地址字符串，根据字符串获取用户信息。如果可以获取到，就是登录</p><h2 id="4-9、阿里云短信服务"><a href="#4-9、阿里云短信服务" class="headerlink" title="4.9、阿里云短信服务"></a>4.9、阿里云短信服务</h2><p>参考 3.2.5、service-msm</p><h2 id="4-10、OAuth2实现第三方登陆"><a href="#4-10、OAuth2实现第三方登陆" class="headerlink" title="4.10、OAuth2实现第三方登陆"></a>4.10、OAuth2实现第三方登陆</h2><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809175038617.png"></p><p>1、添加相关的配置类</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 微信开放平台 appid</span><br><span class="hljs-attr">wx.open.app_id</span>=<span class="hljs-string">你的appid</span><br><span class="hljs-comment"># 微信开放平台 appsecret</span><br><span class="hljs-attr">wx.open.app_secret</span>=<span class="hljs-string">你的appsecret</span><br><span class="hljs-comment"># 微信开放平台 重定向url</span><br><span class="hljs-attr">wx.open.redirect_url</span>=<span class="hljs-string">http://你的服务器名称/api/ucenter/wx/callback</span><br></code></pre></td></tr></table></figure><p>2、创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantWxUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;wx.open.app_id&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String appId;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;wx.open.app_secret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String appSecret;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;wx.open.redirect_url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String redirectUrl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String WX_OPEN_APP_ID;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String WX_OPEN_APP_SECRET;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String WX_OPEN_REDIRECT_URL;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        WX_OPEN_APP_ID = appId;<br>        WX_OPEN_APP_SECRET = appSecret;<br>        WX_OPEN_REDIRECT_URL = redirectUrl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在controller层中写一个生成二维码的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、生成微信扫描二维码</span><br><span class="hljs-meta">@GetMapping(&quot;login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWxCode</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 微信开放平台授权baseUrl  %s相当于?代表占位符</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">baseUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://open.weixin.qq.com/connect/qrconnect&quot;</span> +<br>        <span class="hljs-string">&quot;?appid=%s&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;redirect_uri=%s&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;response_type=code&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;scope=snsapi_login&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;state=%s&quot;</span> +<br>        <span class="hljs-string">&quot;#wechat_redirect&quot;</span>;<br><br>    <span class="hljs-comment">//对redirect_url进行URLEncoder编码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">redirectUrl</span> <span class="hljs-operator">=</span> ConstantWxUtils.WX_OPEN_REDIRECT_URL;<br>    <span class="hljs-keyword">try</span> &#123;<br>        redirectUrl = URLEncoder.encode(redirectUrl, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>    &#125;<br>    <span class="hljs-comment">//设置%s里面值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> String.format(<br>        baseUrl,<br>        ConstantWxUtils.WX_OPEN_APP_ID,<br>        redirectUrl,<br>        <span class="hljs-string">&quot;atguigu&quot;</span><br>    );<br><br>    <span class="hljs-comment">//重定向到请求微信地址里面</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:&quot;</span>+url;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会产生一个二维码，然后当你扫描二维码之后点击登录，然后微信的服务器就会向项目的服务器发起回调。</p><p>当扫描登录之后会自动跳转到这个地址。</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809182729284.png"></p><p>所以需要将本地服务器端口号改为 8150 本地方法为callback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2、获取扫描人信息，添加数据</span><br><span class="hljs-meta">@GetMapping(&quot;callback&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">callCallback</span><span class="hljs-params">(String code,String state)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1、获取code值，临时票据，类似于验证码</span><br><br>        <span class="hljs-comment">// 2、拿着code请求微信固定的地址，得到两个值access_token和openid</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">baseAccessTokenUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;</span> +<br>            <span class="hljs-string">&quot;?appid=%s&quot;</span> +<br>            <span class="hljs-string">&quot;&amp;secret=%s&quot;</span> +<br>            <span class="hljs-string">&quot;&amp;code=%s&quot;</span> +<br>            <span class="hljs-string">&quot;&amp;grant_type=authorization_code&quot;</span>;<br>        <span class="hljs-comment">// 拼接三个参数：id，密钥 和 code值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessTokenUrl</span> <span class="hljs-operator">=</span> String.format(<br>            baseAccessTokenUrl,<br>            ConstantWxUtils.WX_OPEN_APP_ID,<br>            ConstantWxUtils.WX_OPEN_APP_SECRET,<br>            code);<br>        <span class="hljs-comment">// 请求这个拼接好的地址，得到返回两个值 access_token 和 openid</span><br>        <span class="hljs-comment">// 使用httpclient发送请求，得到返回结果</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessTokenInfo</span>  <span class="hljs-operator">=</span> HttpClientUtils.get(accessTokenUrl);<br><br>        <span class="hljs-comment">// 从accessTokenInfo字符串中获取出来 access_token 和 openid</span><br>        <span class="hljs-comment">// 把accessTokenInfo字符串转换为map集合，根据map里面key获取对应值</span><br>        <span class="hljs-comment">// 使用json转换工具 Gson</span><br>        <span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">mapAccessToken</span>  <span class="hljs-operator">=</span> gson.fromJson(accessTokenInfo, HashMap.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">access_token</span> <span class="hljs-operator">=</span> (String) mapAccessToken.get(<span class="hljs-string">&quot;access_token&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">openid</span> <span class="hljs-operator">=</span> (String) mapAccessToken.get(<span class="hljs-string">&quot;openid&quot;</span>);<br><br>        <span class="hljs-comment">// 把扫描人信息添加到数据库里面</span><br>        <span class="hljs-comment">// 判断数据库里面是否存在相同的微信信息，根据openid做判断</span><br>        <span class="hljs-type">UcenterMember</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> memberService.getOpenIdMember(openid);<br>        <span class="hljs-keyword">if</span> (member == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// member是空，表没有相同微信数据，进行添加</span><br>            <span class="hljs-comment">// 3、拿着得到的两个值access_token和openid,再去请求微信提供的固定地址从而得到扫码人的信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">baseUserInfoUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/userinfo&quot;</span> +<br>                <span class="hljs-string">&quot;?access_token=%s&quot;</span> +<br>                <span class="hljs-string">&quot;&amp;openid=%s&quot;</span>;<br>            <span class="hljs-comment">//拼接两个参数</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">userInfoUrl</span> <span class="hljs-operator">=</span> String.format(<br>                baseUserInfoUrl,<br>                access_token,<br>                openid<br>            );<br>            <span class="hljs-comment">// 发送请求</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> HttpClientUtils.get(userInfoUrl);<br>            <span class="hljs-comment">// 获取返回的userinfo字符串扫码人信息</span><br>            <span class="hljs-type">HashMap</span> <span class="hljs-variable">userInfoMap</span> <span class="hljs-operator">=</span> gson.fromJson(userInfo, HashMap.class);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">nickname</span> <span class="hljs-operator">=</span> (String)userInfoMap.get(<span class="hljs-string">&quot;nickname&quot;</span>); <span class="hljs-comment">// 昵称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">headimgurl</span> <span class="hljs-operator">=</span> (String)userInfoMap.get(<span class="hljs-string">&quot;headimgurl&quot;</span>); <span class="hljs-comment">// 头像</span><br><br><br>            member = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UcenterMember</span>();<br>            member.setOpenid(openid);<br>            member.setNickname(nickname);<br>            member.setAvatar(headimgurl);<br>            memberService.save(member); <span class="hljs-comment">// 添加</span><br>        &#125;<br>        <span class="hljs-comment">// 使用jwt根据member对象生成toekn字符串,返回首页面之后通过路径传递token字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jwtToken</span> <span class="hljs-operator">=</span> JwtUtils.getJwtToken(member.getId(), member.getNickname());<br><br>        <span class="hljs-comment">// 最后返回首页面，通过路径传递token字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:http://localhost:3000?token=&quot;</span>+jwtToken;<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuliException</span>(<span class="hljs-number">20001</span>,<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码逻辑：</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809183909441.png" alt="逻辑"></p><p>然后获取微信扫码人的信息 并将这些放到jwt中。</p><h2 id="4-11、Gateway网关"><a href="#4-11、Gateway网关" class="headerlink" title="4.11、Gateway网关"></a>4.11、Gateway网关</h2><p>替代nginx (可以同时启动多个服务) 在微服务架构中，一个动作有时候需要启动多个服务，</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220811110044213.png" alt="工作流程"></p><h2 id="4-12、spring-sercurity权限管理"><a href="#4-12、spring-sercurity权限管理" class="headerlink" title="4.12、spring-sercurity权限管理"></a>4.12、spring-sercurity权限管理</h2><h1 id="五、项目难点"><a href="#五、项目难点" class="headerlink" title="五、项目难点"></a>五、项目难点</h1><p>5.1、数据回显</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组底层</title>
    <link href="/2022/07/27/%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82/"/>
    <url>/2022/07/27/%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="hashmap的底层原理"><a href="#hashmap的底层原理" class="headerlink" title="hashmap的底层原理"></a>hashmap的底层原理</h1><p>jdk1.8之后，底层是红黑树+数组+链表。</p><p><strong>扩容：</strong>当 hashmap 中node的数量大于 初始值(16) * 0.75 (12) 之后开始扩容，扩容的时候将初始值 * 2，当链表的长度 &gt;= 8 &amp;&amp; 数组大小 &gt;= 64的时候开始树形化。但是当链表长度&gt;=8而数组大小 &lt;64 的时候就会先进行扩容解决。当数据的长度退化成6时，红黑树转化为链表。</p><p><strong>hashput()的put()方法：</strong> </p><p><img src="/2022/07/27/%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82/image-20220727230001464.png" alt="image-20220727230001464"></p><h1 id="arraylist"><a href="#arraylist" class="headerlink" title="arraylist"></a>arraylist</h1><p><strong>arraylist与linkedlist区别</strong></p><p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p><p><strong>增加和删除用linkedlist  查找用arraylist</strong></p><p>ArrayList的最大容量为Integer.MAX_VALUE。</p><p><strong>扩容：</strong>在没放进元素的时候，数组大小是0；当放进去元素 &lt;10 的时候 数组大小为10；当放进去元素 &gt;10 的时候，先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容；大于最低容量要求进行扩容时 *1.5；大于MAX_ARRAY_SIZE，则取值为Integer.MAX_VALUE。</p><h1 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h1><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>ConcurrentHashMap在JDK1.8中使用的是数组 加 链表 加 红黑树的方式实现，它是通过 CAS 或者 synchronized 来保证线程安全的，并且缩小了锁的粒度，查询性能也更高。</p><h1 id="集合的Fail-Fast机制-乐观锁"><a href="#集合的Fail-Fast机制-乐观锁" class="headerlink" title="集合的Fail-Fast机制(乐观锁)"></a>集合的Fail-Fast机制(乐观锁)</h1><p>出现在不能并发的集合上：ArrayList，HashMap等。</p><p>会抛出并发修改异常(ConcurrentModificationException)</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/07/19/Git/"/>
    <url>/2022/07/19/Git/</url>
    
    <content type="html"><![CDATA[<p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3S3N1OFVsSVR3TWxiWDNrTUd0WjlwME5KNEw5T1BJOWlhMU1taWJwdkRkNmNTZGRCZHZybGJkRXR5RU9yaDRDS25XVmlieWZDSGEzbHpYdy82NDA?x-oss-process=image/format,png" alt="img"></p><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；  ==<strong>git add .</strong>==</p><p>３、将暂存区域的文件提交到git仓库。 ==<strong>git commit</strong>==</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3S3N1OFVsSVR3TWxiWDNrTUd0WjlwMDlpYU9obDBkQUNmTHJNd05iRHp1Y0dRMzBzM0huc2lhY3pmY1I2ZEM5T2VoaWN1d2liS3VIalJsemcvNjQw?x-oss-process=image/format,png" alt="img"></p><h1 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h1><h2 id="增加提交记录"><a href="#增加提交记录" class="headerlink" title="增加提交记录"></a>增加提交记录</h2><p><code>git commit</code></p><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p><code>git branch &lt;name&gt;</code></p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p><code>git checkout &lt;name&gt;</code>切换到name这个分支</p><h2 id="创建并且切换分支"><a href="#创建并且切换分支" class="headerlink" title="创建并且切换分支"></a>创建并且切换分支</h2><p><code>git checkout -b &lt;name&gt;</code></p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p><code>git merge &lt;name&gt;</code>将name这个分支合并到当前分支中</p><hr><p><code>git rebase &lt;name&gt;</code>相比于<code>merge</code>，rebase是线性的。，将当前的*指向这个name</p><p><strong>区别：</strong></p><p>rebase会将这个分支弄到需要的分支下方，看起来就像是一条线</p><p>merge会生成一个新的提交分支，这个分支指向要合并的分支</p><p><img src="/2022/07/19/Git/image-20220719174552554.png" alt="rebase"></p><p><img src="/2022/07/19/Git/image-20220719174521847.png" alt="merge"></p><h2 id="在git提交树上移动"><a href="#在git提交树上移动" class="headerlink" title="在git提交树上移动"></a>在git提交树上移动</h2><p><code>git checkout &lt;提交记录的哈希值&gt;</code> 将head指向这个提交记录</p><h2 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h2><p><code>git checkout name^</code> 指向name分支的父记录</p><p><code>git checkout name~n</code> n指数字，就是将head指向name分支的第n个父记录</p><p><code>git branch -f master HEAD~3</code> 将 master 分支强制指向 HEAD 的第 3 级父提交</p><h2 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h2><p><code>git reset HEAD~n</code>通过把分支记录回退n个提交记录来实现撤销改动，但是在reset之后之前的提交还会存在，只是处在未加入暂存区之前。但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p><code>git revert HEAD~n</code> 撤销更改并<strong>分享</strong>给别人，revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><h2 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h2><p><code>git cherry-pick &lt;提交号&gt;</code> 将一些提交复制到当前所在的位置（<code>HEAD</code>）下面</p><p><code>git rebase -i HEAD~n</code> 会产生一个交互式的窗口直接在里面拖动就可以</p><p><code>git tag vn cn</code>可以永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。它们并不会随着新的提交而移动</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="将本地仓库克隆到远程仓库"><a href="#将本地仓库克隆到远程仓库" class="headerlink" title="将本地仓库克隆到远程仓库"></a>将本地仓库克隆到远程仓库</h2><p><code>git clone</code></p><h2 id="从远程仓库获取数据"><a href="#从远程仓库获取数据" class="headerlink" title="从远程仓库获取数据"></a>从远程仓库获取数据</h2><p><code>git fetch </code>单纯的下载文件</p><h2 id="先抓取更新再合并到本地分支"><a href="#先抓取更新再合并到本地分支" class="headerlink" title="先抓取更新再合并到本地分支"></a>先抓取更新再合并到本地分支</h2><p><code>git pull</code>不仅下载文件而且还会下载结构。 <strong>git pull == git fetch + git merge</strong></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2022/07/17/Redis/"/>
    <url>/2022/07/17/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="一、缓存数据的处理流程是怎样的？"><a href="#一、缓存数据的处理流程是怎样的？" class="headerlink" title="一、缓存数据的处理流程是怎样的？"></a>一、缓存数据的处理流程是怎样的？</h1><p><img src="/2022/07/17/Redis/image-20220919100350056.png" alt="处理流程"></p><p>简单来说就是:</p><ol><li>如果用户请求的数据在缓存中就直接返回。</li><li>缓存中不存在的话就看数据库中是否存在。</li><li>数据库中存在的话就更新缓存中的数据。</li><li>数据库中不存在的话就返回空数据。</li></ol><h1 id="二、为什么要用-Redis-为什么要用缓存？"><a href="#二、为什么要用-Redis-为什么要用缓存？" class="headerlink" title="二、为什么要用 Redis/为什么要用缓存？"></a>二、为什么要用 Redis/为什么要用缓存？</h1><p>简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。</p><p><strong>高性能</strong> ：当用户第一次访问数据的时候会从磁盘中读取，会很慢，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中，那么用户下一次再访问这些数据的时候就可以直接从缓存中获取了</p><p><strong>高并发：</strong>放到缓存中的话，用户的一部分请求就会进入缓存而不是数据库。</p><h1 id="三、Redis常见数据结构"><a href="#三、Redis常见数据结构" class="headerlink" title="三、Redis常见数据结构"></a>三、Redis常见数据结构</h1><hr><p><strong><code>String</code></strong></p><ol><li><strong>常用命令：</strong> <code>set(设置k-v类型的值),get(通过k获得对应的v),strlen(获得key存储的字符串长度),exists(判断key是否存在),decr(设置k的v自减),incr(设置k的v自增),setex(设置过期时间)</code> 等等。</li><li><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li></ol><hr><p>**<code>list</code>**：双向链表</p><ol><li><strong>常用命令:</strong> <code>rpush(向list右边添加元素),lpop(移除list中的左边元素),lpush,rpop,lrange(查看对应下标的list列表 0 -1表示查看所有),llen(查看链表长度)</code> 等。</li><li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li></ol><p><img src="/2022/07/17/Redis/image-20220919100546069.png" alt="redis-list"></p><hr><p><strong><code>hash</code></strong></p><ol><li><strong>常用命令：</strong> <code>hset(设置一个具体的k-v),hmset(设置多个k-v),hexists(查看是否存在k),hget(得到k对应的v),hgetall(得到所有哈希表名的k-v),hkeys(获取所有的k),hvals(获取所有的v)</code> 等。</li><li><strong>应用场景:</strong> 系统中对象数据的存储。</li></ol><p>格式：hset 哈希表名 哈希表key 哈希表value</p><hr><p><strong><code>set</code></strong></p><ol><li><strong>常用命令：</strong> <code>sadd(添加元素),spop(随机删除),smembers(查看所集合中的所有元素),sismember(查询元素是否是集合中的成员),scard(获取成员数量),sinterstore(获取集合1与集合2的交集并放在集合3中),sunion(获取并集)</code> 等。</li><li><strong>应用场景:</strong> <strong>需要存放的数据不能重复</strong>以及需要获取多个数据源交集和并集等场景</li></ol><hr><p><strong><code>zset</code></strong></p><ol><li><strong>常用命令：</strong> <code>zadd(),zcard(),zscore(),zrange(),zrevrange(),zrem()</code> 等。</li><li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li></ol><h1 id="四、Redis-线程模型"><a href="#四、Redis-线程模型" class="headerlink" title="四、Redis 线程模型"></a>四、Redis 线程模型</h1><p>Redis是单线程的，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><h1 id="五、Redis内存管理"><a href="#五、Redis内存管理" class="headerlink" title="五、Redis内存管理"></a>五、Redis内存管理</h1><hr><p><strong><code>为什么要设置过期时间？</code></strong></p><p>因为内存是有限的，不设置过期时间就会产生oom。</p><p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><hr><p><strong><code>过期的数据的删除策略了解么？</code></strong></p><p>常用的过期数据的删除策略就两个：</p><ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p><hr><h1 id="六、Redis持久化机制"><a href="#六、Redis持久化机制" class="headerlink" title="六、Redis持久化机制"></a>六、Redis持久化机制</h1><p><strong>一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong></p><hr><p><strong><code>RDB</code></strong></p><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><hr><p><strong><code>AOF</code></strong></p><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>三种AOF方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度<br>appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘<br>appendfsync no        #让操作系统决定何时进行同步<br></code></pre></td></tr></table></figure><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化</p><h1 id="七、Redis事务"><a href="#七、Redis事务" class="headerlink" title="七、Redis事务"></a>七、Redis事务</h1><ol><li>开始事务（<code>MULTI</code>）。</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol><p><code>DISCARD</code>取消事务，</p><p><code>WATCH</code>监听事务。当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，<strong>Redis 事务其实是不满足原子性的（而且不满足持久性）。</strong></p><p><strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><h1 id="八、Redis生产问题"><a href="#八、Redis生产问题" class="headerlink" title="八、Redis生产问题"></a>八、Redis生产问题</h1><h2 id="8-1、缓存穿透"><a href="#8-1、缓存穿透" class="headerlink" title="8.1、缓存穿透"></a>8.1、缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p><p><img src="https://img-blog.csdnimg.cn/6358650a9bf742838441d636430c90b9.png" alt="缓存穿透情况"></p><p><strong>如何解决？</strong>布隆过滤器</p><p>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端</p><p><img src="/2022/07/17/Redis/image-20220919100639615.png" alt="布隆过滤器"></p><h2 id="8-2、缓存雪崩"><a href="#8-2、缓存雪崩" class="headerlink" title="8.2、缓存雪崩"></a>8.2、缓存雪崩</h2><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong></p><p><strong><code>如何解决？</code></strong></p><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效</li></ol><h1 id="九、3种常用的缓存读写策略"><a href="#九、3种常用的缓存读写策略" class="headerlink" title="九、3种常用的缓存读写策略"></a>九、3种常用的缓存读写策略</h1><h2 id="Cache-Asbde-Pattern（旁路缓存模式）"><a href="#Cache-Asbde-Pattern（旁路缓存模式）" class="headerlink" title="Cache Asbde Pattern（旁路缓存模式）"></a>Cache Asbde Pattern（旁路缓存模式）</h2><p>比较适合读请求比较多的时候。</p><p><strong>写</strong> ：</p><ul><li>先更新 DB。</li><li>然后直接删除 cache 。</li></ul><p><strong>读</strong> :</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache中读取不到的话，就从 DB 中读取数据返回</li><li>再把数据放到 cache 中。</li></ul><p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p><p>解决办法：可以将热点数据可以提前放入cache 中。</p><p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul><h2 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h2><p><strong>写（Write Through）：</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 DB。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li></ul><p><strong>读(Read Through)：</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li></ul><h2 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h2><p>读写穿透的异步模式</p><h1 id="十、Redis分布式锁"><a href="#十、Redis分布式锁" class="headerlink" title="十、Redis分布式锁"></a>十、Redis分布式锁</h1><p>方案一：SETNX 设置锁  <strong>会造成死锁</strong></p><p>方案二：设置锁之后设置锁的过期时间 <strong>但是在设置锁之后 设置过期时间之间如果报错过期时间就会设置不成功</strong></p><p>方案三：设置锁与设置过期时间一起设置 保证原子性 <strong>但是A在过期时间之后没完成任务然后B进入的时候 在B执行期间 A完成任务就会将锁释放</strong></p><p>方案四：设置锁与过期时间以及锁的编号一起设置 当删除锁的时候查询编号 如果一致，则认为是自己设置的锁，可以进行主动删除。  <strong>但是获取锁以及删除锁不是原子性的。</strong></p><p>方案五：将查询锁和删除锁这两步作为原子指令 也就是使用脚本锁删。</p><p>方案六：看门狗机制。我们不知道锁什么时候过期，所以利用看门狗机制，没过10s看门狗就延长30s的过期时间，当服务器G了以后，10s以后看门狗不延长30s，那么锁就会自动删除。</p><h1 id="十一、缓存和数据库一致问题"><a href="#十一、缓存和数据库一致问题" class="headerlink" title="十一、缓存和数据库一致问题"></a>十一、缓存和数据库一致问题</h1><p><strong>采用延迟双删来解决问题</strong>：先进行缓存清除，再执行update，最后（延迟N秒）再执行缓存清除。</p><p>1、想要提高应用的性能，可以引入「缓存」来解决</p><p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p><p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p><p>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p><p>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p><p>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1-1、数据库范式"><a href="#1-1、数据库范式" class="headerlink" title="1.1、数据库范式"></a>1.1、数据库范式</h2><p><strong><code>1NF(第一范式)</code><strong>每一列的属性都不可再分，保证每一列的</strong>原子性</strong></p><p>**<code>2NF(第二范式)</code><strong>2NF 在 1NF 的基础之上，</strong>还要满足数据表里的每一条数据记录都是可唯一标识的，并且所有的非主键字段都要完全依赖于主键。(对于一个数据，如果主键是联合主键，那么就要满足如果要确定非主键字段那么就要同时知道所有主键的信息)**。不完全依赖就将这一部分分离出来形成一个新实体。</p><blockquote><p>1NF是告诉我们字段属性需要原子性，2NF告诉我们一张表就是一个独立的个体，一个表只表达一个意思</p></blockquote><p><strong><code>3NF(第三范式)</code></strong> 每个非主属性必须直接依赖于主属性，不能存在非主属性A依赖于B，B依赖于主属性C，然后A依赖于C这种关系。<strong>也就是说非主属性之间必须完全独立。</strong></p><p><strong><code>BCNF(优化以后的第三范式)</code></strong></p><p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。</p><h2 id="1-2、drop、delete-与-truncate-区别？"><a href="#1-2、drop、delete-与-truncate-区别？" class="headerlink" title="1.2、drop、delete 与 truncate 区别？"></a>1.2、drop、delete 与 truncate 区别？</h2><hr><p><strong><code>用法不同</code></strong></p><p>drop：删除表以及表的数据</p><p>truncate：删除表中的所有数据</p><p>delete：删除表中的某一行元素</p><p> <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p><hr><p><strong><code>属于不同的数据库语言</code></strong></p><p><strong>DDL(数据库定义语言)：</strong>drop、truncate</p><p><strong>DML(数据库操作语言)：</strong>delete</p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><hr><p><strong><code>执行速度不同</code></strong></p><p>一般来说：drop &gt; truncate &gt; delete</p><h2 id="1-3、数据库设计通常分为哪几步"><a href="#1-3、数据库设计通常分为哪几步" class="headerlink" title="1.3、数据库设计通常分为哪几步?"></a>1.3、数据库设计通常分为哪几步?</h2><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li></ol><h1 id="二、MySQL"><a href="#二、MySQL" class="headerlink" title="二、MySQL"></a>二、MySQL</h1><h2 id="2-1、存储引擎"><a href="#2-1、存储引擎" class="headerlink" title="2.1、存储引擎"></a>2.1、存储引擎</h2><blockquote><p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要它不⽀持的特性时，才考虑使⽤其它 存储引擎。</p></blockquote><h3 id="2-1-1、MyISAM-和-InnoDB-的区别是什么？"><a href="#2-1-1、MyISAM-和-InnoDB-的区别是什么？" class="headerlink" title="2.1.1、MyISAM 和 InnoDB 的区别是什么？"></a>2.1.1、MyISAM 和 InnoDB 的区别是什么？</h3><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </li><li>InnoDB支持外键，而MyISAM不支持。</li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li></ol><h2 id="2-2、MySQL查询缓存"><a href="#2-2、MySQL查询缓存" class="headerlink" title="2.2、MySQL查询缓存"></a>2.2、MySQL查询缓存</h2><p><strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。</p><p><strong>查询缓存不命中的情况：（1）</strong>任何两个查询在任何字符上的不同都会导致缓存不命中。</p><p><strong>查询缓存不命中的情况：（2）</strong>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</p><p><strong>查询缓存不命中的情况：（3）</strong> <strong>缓存建立之后</strong>，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效</p><h2 id="2-3、MySQL事务"><a href="#2-3、MySQL事务" class="headerlink" title="2.3、MySQL事务"></a>2.3、MySQL事务</h2><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><blockquote><p>数据库事务</p></blockquote><p><strong>要么全部执行成功,要么全部不执行</strong> </p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215205475.png" alt="数据库事务示意图"></p><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215217274.png" alt="ACID"></p><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215227923.png" alt="AID -&gt; C"></p><h3 id="2-3-1、并发事务带来的问题"><a href="#2-3-1、并发事务带来的问题" class="headerlink" title="2.3.1、并发事务带来的问题"></a>2.3.1、并发事务带来的问题</h3><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一<strong>个事务内两次读到的数据是不一样的情况，</strong>因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<br><img src="https://img-blog.csdnimg.cn/20201216230427546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM5ODY4Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="不可重复读"></li></ul><blockquote><p>不可重复读和幻读两者有些相似。但<code>不可重复读重点在于update和delete，而幻读的重点在于insert。</code></p></blockquote><h3 id="2-3-2、事务隔离级别"><a href="#2-3-2、事务隔离级别" class="headerlink" title="2.3.2、事务隔离级别"></a>2.3.2、事务隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p><strong>其中，可串行化是基于锁来实现的，剩下的三个隔离级别都是基于MVCC实现</strong></p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读，就是一个不加锁的select</li><li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock(临键锁) 进行加锁来保证不出现幻读，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li></ul><p>简单理解需要加锁的是当前读，快照读不需要加锁。</p><p><strong>事务是如何实现mvcc的？</strong> </p><p>1、每个事务都有⼀个事务ID,叫做transaction id(严格递增) </p><p>2、事务在启动时,找到已提交的最⼤事务ID记为up_limit_id。 </p><p>3、事务在更新⼀条语句时 ⽐如 id=1 改为了 id=2.会把 id=1 和该⾏之前的 row trx_id 写到 undo log ⾥, 并且在数据⻚上 把 id 的值改为 2,并且把修改这条语句的transaction id 记在该⾏⾏头 </p><p>4、再定⼀个规矩 ⼀个事务要查看⼀条数据时,必须先⽤该事务的 up_limit_id 与该⾏的transaction id 做⽐对 如果 up_limit_id &gt;= transaction id,那么可以看 如果 up_limit_id &lt; transaction id,则只能去 undo log ⾥去取。 去 undo log 查找数据的时候,也需要做⽐对,必须 up_limit_id &gt; transaction id，才返回数据</p><h2 id="2-4、MySQL锁"><a href="#2-4、MySQL锁" class="headerlink" title="2.4、MySQL锁"></a>2.4、MySQL锁</h2><h3 id="2-4-1、锁的分类"><a href="#2-4-1、锁的分类" class="headerlink" title="2.4.1、锁的分类"></a>2.4.1、锁的分类</h3><p>表级锁与行级锁：表级锁是将整个表锁住，在并发的情况下，性能十分差。</p><p>行级锁是对一行或者多行记录进行加锁。</p><blockquote><p><strong>表级锁和行级锁对比</strong> </p></blockquote><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li></ul><blockquote><p><strong>行级锁的使用注意事项：</strong></p></blockquote><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。</p><blockquote><p><strong>共享锁与排他锁</strong></p></blockquote><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录(SELECT)的时候获取共享锁，允许多个事务同时获取（锁兼容）。如果<code>事务A</code>对<code>数据B</code>（1024房）加上读锁后，则其他事务只能对<code>数据B</code>上加读锁，不能加写锁。获得读锁的事务只能读数据，不能修改数据。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果<code>事务A</code>对<code>数据B</code>加上写锁后，则其他事务不能再对<code>数据B</code>加任何类型的锁。<code>获得写锁的事务既能读数据，又能修改数据</code>。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 共享锁<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 排他锁<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>意向锁</strong></p></blockquote><p>意向锁属于表级锁，<strong>目的</strong>主要是为了在一个事务中揭示下一行将要被请求锁的类型。</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><code>意向锁是 InnoDB 自动加的，不需要用户干预。</code></p><p>对于INSERT、UPDATE和DELETE，InnoDB 会自动给涉及的数据加排他锁；对于一般的SELECT语句，InnoDB 不会加任何锁</p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><blockquote><p><strong>InnoDB 有哪几类行锁？</strong></p></blockquote><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。（实质上是锁住索引）</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p>间隙锁与临键锁可以防止幻读</p><h2 id="2-5、MySQL高性能优化"><a href="#2-5、MySQL高性能优化" class="headerlink" title="2.5、MySQL高性能优化"></a>2.5、MySQL高性能优化</h2><p><a href="https://blog.csdn.net/shassd/article/details/109708433?ops_request_misc=%7B%22request_id%22:%22165796295816782391893729%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165796295816782391893729&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-109708433-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83&spm=1018.2226.3001.4187">常用数据库设计规范总结</a></p><h2 id="2-6、索引"><a href="#2-6、索引" class="headerlink" title="2.6、索引"></a>2.6、索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p>索引的作用就相当于书的目录。</p><h3 id="2-6-1、索引的优缺点"><a href="#2-6-1、索引的优缺点" class="headerlink" title="2.6.1、索引的优缺点"></a>2.6.1、索引的优缺点</h3><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间</li></ul><h3 id="2-6-2、索引的底层数据结构"><a href="#2-6-2、索引的底层数据结构" class="headerlink" title="2.6.2、索引的底层数据结构"></a>2.6.2、索引的底层数据结构</h3><hr><p><strong><code>Hash表</code></strong></p><p><strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点</strong></p><hr><p><strong><code>B 树&amp; B+树</code></strong></p><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong></p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><h3 id="2-6-3、索引类型"><a href="#2-6-3、索引类型" class="headerlink" title="2.6.3、索引类型"></a>2.6.3、索引类型</h3><hr><p><strong><code>主键索引</code></strong></p><p>数据表的主键列使用的就是主键索引。是一种特殊的唯一索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><hr><p><strong><code>二级索引</code></strong></p><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><ol><li><strong>唯一索引(Unique Key)</strong> ：<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> </li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于<strong>字符串类型的数据</strong>。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p>二级索引:</p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215309355.png"></p><hr><h3 id="2-6-4、聚集索引与非聚集索引"><a href="#2-6-4、聚集索引与非聚集索引" class="headerlink" title="2.6.4、聚集索引与非聚集索引"></a>2.6.4、聚集索引与非聚集索引</h3><p><strong><code>聚集索引</code><strong>：</strong>聚集索引即索引结构和数据一起存放的索引，找到索引也就找到了数据。主键索引属于聚集索引。</strong></p><p>聚集索引查询速度非常快，定位到了索引的位置也就直接定位到了数据的值。</p><p><strong>聚集索引的缺点</strong></p><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><hr><p><strong><code>非聚集索引</code>：</strong>非聚集索引即索引结构和数据分开存放的索引。当你要找一个数据的时候，先在内存中搜索索引，然后通过索引找到磁盘对应的数据。 <strong>类似于根据偏旁部首找字，首先找到该字所在的地址，再根据地址找到这个字的信息。</strong></p><p>更新代价比聚集索引要小 。</p><p><strong>非聚集索引的缺点</strong></p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><h3 id="2-6-5、覆盖索引"><a href="#2-6-5、覆盖索引" class="headerlink" title="2.6.5、覆盖索引"></a>2.6.5、覆盖索引</h3><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><h3 id="2-6-6、联合索引"><a href="#2-6-6、联合索引" class="headerlink" title="2.6.6、联合索引"></a>2.6.6、联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><p>使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。(最左前缀匹配原则)</p><h3 id="2-6-7、创建索引的注意事项"><a href="#2-6-7、创建索引的注意事项" class="headerlink" title="2.6.7、创建索引的注意事项"></a>2.6.7、创建索引的注意事项</h3><p><strong>1、选择合适的字段创建索引</strong></p><ul><li>不为 NULL 的字段</li><li>被频繁查询的字段 </li><li>被作为条件查询的字段 </li><li>频繁需要排序的字段 </li><li>被经常频繁用于连接的字段</li></ul><p><strong>2、被频繁更新的字段应该慎重建立索引。</strong></p><p><strong>3、尽可能的考虑建立联合索引而不是单列索引。</strong></p><p><strong>4、注意避免冗余索引</strong> 。</p><p><strong>5、考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><h3 id="2-6-8、-MySQL-如何为表字段添加索引？"><a href="#2-6-8、-MySQL-如何为表字段添加索引？" class="headerlink" title="2.6.8、 MySQL 如何为表字段添加索引？"></a>2.6.8、 MySQL 如何为表字段添加索引？</h3><p>1.添加 PRIMARY KEY（主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY ( `<span class="hljs-keyword">column</span>` )<br></code></pre></td></tr></table></figure><p>2.添加 UNIQUE(唯一索引)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">ALTER TABLE `table_name` ADD UNIQUE ( `column` )<br></code></pre></td></tr></table></figure><p>3.添加 INDEX(普通索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `<span class="hljs-keyword">column</span>` )<br></code></pre></td></tr></table></figure><p>4.添加 FULLTEXT(全文索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> FULLTEXT ( `<span class="hljs-keyword">column</span>`)<br></code></pre></td></tr></table></figure><p>5.添加多列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` )<br></code></pre></td></tr></table></figure><h3 id="2-6-9、什么情况下不会用到索引"><a href="#2-6-9、什么情况下不会用到索引" class="headerlink" title="2.6.9、什么情况下不会用到索引"></a>2.6.9、什么情况下不会用到索引</h3><p>如果条件中有or，即使其中有部分条件带索引也不会使用(这也是为什么尽量少用or的原因)<br>对于多列索引，不是使用的第一部分，则不会使用索引<br>like查询是以%开头<br>存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引<br>where 子句里对索引列上有数学运算，用不上索引<br>where 子句里对有索引列使用函数，用不上索引<br>如果MySQL估计使用全表扫描要比使用索引快,则不使用索引</p><h2 id="2-7、MySQL三大日志-binlog、redo-log和undo-log"><a href="#2-7、MySQL三大日志-binlog、redo-log和undo-log" class="headerlink" title="2.7、MySQL三大日志(binlog、redo log和undo log)"></a>2.7、MySQL三大日志(binlog、redo log和undo log)</h2><h3 id="2-7-1、redo-log-重做日志"><a href="#2-7-1、redo-log-重做日志" class="headerlink" title="2.7.1、redo log(重做日志)"></a>2.7.1、redo log(重做日志)</h3><p>是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215323923.png"></p><h3 id="2-7-2、bin-log"><a href="#2-7-2、bin-log" class="headerlink" title="2.7.2、bin log"></a>2.7.2、bin log</h3><p>负责记录数据库的操作，只要表数据发生更新，那么就会产生日志。</p><p>主要用来 集群化管理，主要用来 <strong>主从复制</strong> 和 <strong>数据恢复</strong> </p><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong>：只有sql语句</li><li><strong>row</strong> ：记录sql语句的时候会包含具体的数据，比较占空间</li><li><strong>mixed</strong>：前两者的结合，判断sql会引起数据不一致就调用row，不会就使用statement</li></ul><h3 id="2-7-3、undo-log"><a href="#2-7-3、undo-log" class="headerlink" title="2.7.3、undo log"></a>2.7.3、undo log</h3><p>如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。</p><p><strong><code>总结：</code></strong></p><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p><h2 id="2-8、MVCC"><a href="#2-8、MVCC" class="headerlink" title="2.8、MVCC"></a>2.8、MVCC</h2><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。</p><hr><p><strong><code>隐藏字段</code></strong></p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。</li></ul><hr><p><strong><code>ReadView</code></strong></p><ul><li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li><li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li><li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li></ul><p><strong>事务可见性示意图</strong>：</p><p><img src="https://javaguide.cn/assets/trans_visible.048192c5.png" alt="trans_visible"></p><hr><p><strong><code>undo-log</code></strong></p><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><hr><p><strong><code>RC 和 RR 隔离级别下 MVCC 的差异</code></strong></p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表</li></ul><p><strong>总结：</strong> <strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/E%60%60M%7B%5BHMESZ2J5R79K2V_7N.png" alt="数据可见性算法"></p><p><strong><code>MVCC➕Next-key-Lock 防止幻读</code></strong></p><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 [Next-key Lockopen in new window]来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h2 id="2-9、Mysql架构"><a href="#2-9、Mysql架构" class="headerlink" title="2.9、Mysql架构"></a>2.9、Mysql架构</h2><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215337684.png" alt="image-20220724215337684"></p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。</li></ul><p><strong><code>总结</code></strong></p><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li><li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li></ul><hr><h2 id="2-10、隐式转换"><a href="#2-10、隐式转换" class="headerlink" title="2.10、隐式转换"></a>2.10、隐式转换</h2><p>规则：</p><ol><li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>&#39;abc&#39;</code>、<code>&#39;a123bc&#39;</code>、<code>&#39;abc123&#39;</code>都会转化为<code>0</code>；</li><li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>&#39;123abc&#39;</code>会转换为<code>123</code>，<code>&#39;012abc&#39;</code>会转换为<code>012</code>也就是<code>12</code>，<code>&#39;5.3a66b78c&#39;</code>会转换为<code>5.3</code>，其他同理。</li></ol><p><strong>总结：</strong></p><ol><li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li><li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li><li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li><li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序</title>
    <link href="/2022/07/15/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/07/15/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:冒泡排序</span><br><span class="hljs-comment">     * @return: int[]</span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 8:48</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:选择排序</span><br><span class="hljs-comment">     * @return: int[]</span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 8:52</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectionSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIndex != i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>                arr[i] = arr[minIndex];<br>                arr[minIndex] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:插入排序</span><br><span class="hljs-comment">     * @return: int[]</span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 9:06</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertionSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;<br>                arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>                preIndex--;<br>            &#125;<br>            arr[preIndex + <span class="hljs-number">1</span>] = current;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:希尔排序</span><br><span class="hljs-comment">     * @return: int[] </span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 9:39</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>                <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>                    arr[preIndex + gap] = arr[preIndex];<br>                    preIndex -= gap;<br>                &#125;<br>                arr[preIndex + gap] = current;<br><br>            &#125;<br>            gap /= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;;<br>        shellSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: quickSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 15:57</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">quickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span> || arr == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (L &lt; R) &#123;<br>            swap(arr,  (<span class="hljs-type">int</span>) (L + Math.random() * (R - L + <span class="hljs-number">1</span>)),R);<br>            <span class="hljs-type">int</span>[] p = partition(arr, L, R);<br>            quickSort(arr, <span class="hljs-number">0</span>, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>            quickSort(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R;<br>        <span class="hljs-keyword">while</span> (L &lt; more) &#123;<br>            <span class="hljs-keyword">if</span> (arr[L] &lt; arr[R]) &#123;<br>                less++;<br>                swap(arr,less,L);<br>                L++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[L] &gt; arr[R]) &#123;<br>                more--;<br>                swap(arr,more,L);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                L++;<br>            &#125;<br>        &#125;<br>        swap(arr,more,R);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;<br>    &#125;<br><br><br><br>    <span class="hljs-comment">// 1 2 3 4 8  4</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[L];<br>        arr[L] = arr[R];<br>        arr[R] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        quickSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>归并排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: mergeSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 9:53</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 归并排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">mergeSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 属于归并排序中的划分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + (R - L) / <span class="hljs-number">2</span>;<br>        process(arr, <span class="hljs-number">0</span>, mid);<br>        process(arr, mid+<span class="hljs-number">1</span>, R);<br>        merge(arr, L, mid, R);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>]; <span class="hljs-comment">//辅助数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> L;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> M + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;<br>            <span class="hljs-comment">// 数组中哪一个小 哪一个在前</span><br>            <span class="hljs-keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;<br>                help[i] = arr[p1];<br>                i++;<br>                p1++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                help[i] = arr[p2];<br>                i++;<br>                p2++;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">//如果p1没越界，就把p1剩下的拷到help中</span><br>        <span class="hljs-keyword">while</span> (p1 &lt;= M) &#123;             <span class="hljs-comment">// 以下两个while只会执行一个 也就是p1 p2 必然会有一个越界</span><br>            help[i] = arr[p1];<br>            i++;<br>            p1++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p2 &lt;= R) &#123;<br>            help[i] = arr[p2];<br>            i++;<br>            p2++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>            arr[L + i] = help[i];<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br>        mergeSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>堆排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: heapSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 21:46</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:左神视频25：44</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">heapSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">heapsize</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            heapInsert(arr, i);<br>        &#125;<br>        swap(arr, <span class="hljs-number">0</span>, --heapsize);<br>        <span class="hljs-keyword">while</span> (heapsize &gt; <span class="hljs-number">0</span>) &#123;<br>            heapify(arr, <span class="hljs-number">0</span>, heapsize);<br>            swap(arr, <span class="hljs-number">0</span>, --heapsize);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 判断大根堆是否成立，如果不成立</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;<br>            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//堆化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapsize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; heapsize) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span> &lt; heapsize &amp;&amp; arr[left] &lt; arr[left + <span class="hljs-number">1</span>] ? left + <span class="hljs-number">1</span> : left;<br>            last = arr[last] &gt; arr[index] ? last : index;<br>            <span class="hljs-keyword">if</span> (last == index) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            swap(arr, last, index);<br>            index = last;<br>            left = (index * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[L];<br>        arr[L] = arr[R];<br>        arr[R] = temp;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br>        heapSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基数排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: radixSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 22:15</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:左神视频1：51：25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">radixSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));<br>    &#125;<br><br>    <span class="hljs-comment">// 计算数组中最大的数字有几位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxbits</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            max = Math.max(max, arr[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>            res++;<br>            max /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// digit是这个数组中最大的数字有几位</span><br>    <span class="hljs-comment">// 对应的词频下标数减1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> digit)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; d &lt; radix; d++) &#123; <span class="hljs-comment">// 有几位就进出几次桶</span><br>            <span class="hljs-comment">// count[0] 表示当前位(d位)小于等于0的数字有几个</span><br>            <span class="hljs-comment">// count[1] 表示当前位(d位)小于等于1的数字有几个</span><br>            <span class="hljs-comment">// count[2] 表示当前位(d位)小于等于2的数字有几个</span><br>            <span class="hljs-comment">// count[i] 表示当前位(d位)小于等于i的数字有几个</span><br>            <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[radix];<br>            <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;<br>                j = getDiggit(arr[i], d);<br>                count[j]++;<br>            &#125;<br><br>            <span class="hljs-comment">// 将count处理成累加和 也就是处理成小于当前位的数有几个</span><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;<br>                count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>            &#125;<br><br>            <span class="hljs-comment">// 数组从右往左遍历</span><br>            <span class="hljs-comment">// 模拟数字出桶过程</span><br>            <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;<br>                j = getDiggit(arr[i], d);<br>                help[count[j] - <span class="hljs-number">1</span>] = arr[i];<br>                count[j]--;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;<br>                arr[i] = help[j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 得到数组中这个数字的第d位的数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDiggit</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> &#123;<br>        <span class="hljs-keyword">return</span> ((x / ((<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、图"><a href="#一、图" class="headerlink" title="一、图"></a>一、图</h1><p>图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：**G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p><h2 id="1-1、图的基本元素"><a href="#1-1、图的基本元素" class="headerlink" title="1.1、图的基本元素"></a>1.1、图的基本元素</h2><h3 id="1-1-1、顶点"><a href="#1-1-1、顶点" class="headerlink" title="1.1.1、顶点"></a><strong>1.1.1、顶点</strong></h3><p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）</p><p>对应到好友关系图，每一个用户就代表一个顶点。</p><hr><h3 id="1-1-2、边"><a href="#1-1-2、边" class="headerlink" title="1.1.2、边"></a><strong>1.1.2、边</strong></h3><p>顶点之间的关系用边表示。</p><p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p><hr><h3 id="1-1-3、度"><a href="#1-1-3、度" class="headerlink" title="1.1.3、度"></a><strong>1.1.3、度</strong></h3><p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。</p><p>对应到好友关系图，度就代表了某个人的好友数量。</p><hr><h3 id="1-1-4、无向图和有向图"><a href="#1-1-4、无向图和有向图" class="headerlink" title="1.1.4、无向图和有向图"></a><strong>1.1.4、无向图和有向图</strong></h3><p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。</p><p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图</p><hr><h3 id="1-1-5、无权图和带权图"><a href="#1-1-5、无权图和带权图" class="headerlink" title="1.1.5、无权图和带权图"></a><strong>1.1.5、无权图和带权图</strong></h3><p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。</p><p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p><h2 id="1-2、图的存储"><a href="#1-2、图的存储" class="headerlink" title="1.2、图的存储"></a>1.2、图的存储</h2><hr><h3 id="1-2-1、邻接矩阵存储"><a href="#1-2-1、邻接矩阵存储" class="headerlink" title="1.2.1、邻接矩阵存储"></a><strong>1.2.1、邻接矩阵存储</strong></h3><p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。</p><p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 <code>A[i][j]=n</code> 。</p><p>在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，<code>A[i][j]</code>=1，当顶点i和顶点j没有关系时，<code>A[i][j]</code>=0。如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8.3ba1bccc.png" alt="无向图的邻接矩阵存储"></p><p>值得注意的是：<strong>无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。</strong></p><p><img src="https://javaguide.cn/assets/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8.46663a1b.png" alt="有向图的邻接矩阵存储"></p><p><strong><code>邻接矩阵存储的方式虽然比较直接简单，但是比较浪费空间。</code></strong></p><hr><h3 id="1-2-2、邻接表存储"><a href="#1-2-2、邻接表存储" class="headerlink" title="1.2.2、邻接表存储"></a><strong>1.2.2、邻接表存储</strong></h3><p>邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 <strong>邻接表</strong>。如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8.2869ec57.png" alt="无向图的邻接表存储"></p><p><img src="https://javaguide.cn/assets/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8.362b00d5.png" alt="有向图的邻接表存储"></p><ul><li>在无向图中，邻接表元素个数等于边的条数的两倍。</li><li>在有向图中，邻接表元素个数等于边的条数。</li></ul><h2 id="1-3、图的搜索"><a href="#1-3、图的搜索" class="headerlink" title="1.3、图的搜索"></a>1.3、图的搜索</h2><h3 id="1-3-1、广度优先搜索"><a href="#1-3-1、广度优先搜索" class="headerlink" title="1.3.1、广度优先搜索"></a>1.3.1、广度优先搜索</h3><p>广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：</p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE%E7%A4%BA.4f9122d2.png" alt="广度优先搜索图示"></p><p><strong>广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列</strong> 。具体过程如下图所示：</p><p><strong>第1步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A21.c43db853.png" alt="广度优先搜索1"></p><p><strong>第2步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A22.d42ff990.png" alt="广度优先搜索2"></p><p><strong>第3步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A23.e46fdfec.png" alt="广度优先搜索3"></p><p><strong>第4步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A24.d7bbf332.png" alt="广度优先搜索4"></p><p><strong>第5步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A25.2f52a074.png" alt="广度优先搜索5"></p><p><strong>第6步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A26.98a33175.png" alt="广度优先搜索6"></p><h3 id="1-3-2、深度优先搜索"><a href="#1-3-2、深度优先搜索" class="headerlink" title="1.3.2、深度优先搜索"></a>1.3.2、深度优先搜索</h3><p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE%E7%A4%BA.a5e0d06f.png" alt="深度优先搜索图示"></p><p><strong>和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈</strong> 。具体过程如下图所示：</p><p><strong>第1步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A21.3c4595de.png" alt="深度优先搜索1"></p><p><strong>第2步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A22.c79a5d25.png" alt="深度优先搜索1"></p><p><strong>第3步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A23.6d7c7ecb.png" alt="深度优先搜索1"></p><p><strong>第4步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A24.89719079.png" alt="深度优先搜索1"></p><p><strong>第5步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A25.d36925bc.png" alt="深度优先搜索1"></p><p><strong>第6步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A26.ef5280c9.png" alt="深度优先搜索1"></p><h1 id="二、堆"><a href="#二、堆" class="headerlink" title="二、堆"></a>二、堆</h1><h2 id="2-1、什么是堆？"><a href="#2-1、什么是堆？" class="headerlink" title="2.1、什么是堆？"></a>2.1、什么是堆？</h2><p>任意一个节点的值都大于等于（或小于等于）所有子节点的值</p><h2 id="2-2、堆的用途"><a href="#2-2、堆的用途" class="headerlink" title="2.2、堆的用途"></a>2.2、堆的用途</h2><p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong></p><h2 id="2-3、堆的分类"><a href="#2-3、堆的分类" class="headerlink" title="2.3、堆的分类"></a>2.3、堆的分类</h2><p>分为最大堆和最小堆</p><ul><li><strong>最大堆</strong> ：堆中的每一个节点的值都大于等于子树中所有节点的值</li><li><strong>最小堆</strong> ：堆中的每一个节点的值都小于等于子树中所有节点的值</li></ul><h2 id="2-4、堆的存储"><a href="#2-4、堆的存储" class="headerlink" title="2.4、堆的存储"></a>2.4、堆的存储</h2><p>若根结点的序号为1，对于树中任意节点i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）</p><p>堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8.03237dbe.png" alt="堆的存储"></p><h2 id="2-5、堆的操作"><a href="#2-5、堆的操作" class="headerlink" title="2.5、堆的操作"></a>2.5、堆的操作</h2><h3 id="2-5-1、插入元素"><a href="#2-5-1、插入元素" class="headerlink" title="2.5.1、插入元素"></a>2.5.1、插入元素</h3><blockquote><p>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</p></blockquote><p><strong>1.将要插入的元素放到最后</strong></p><p><strong>2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换</strong></p><h3 id="2-5-2、删除堆顶元素"><a href="#2-5-2、删除堆顶元素" class="headerlink" title="2.5.2、删除堆顶元素"></a>2.5.2、删除堆顶元素</h3><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”<strong>堆化</strong>“，堆化的方法分为两种：</p><ul><li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li><li>另一种是自顶向下堆化，元素由最顶部向下移动。</li></ul><hr><p><strong>自底向上的堆化</strong></p><p>1、将堆顶的元素也就是下标为1的元素删除</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A01.cd68b7ff.png" alt="删除堆顶元素1"></p><p>2、对比下标为2，3的元素，哪一个比较大就将他的下标变成1</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A02.59fc6629.png" alt="删除堆顶元素2"></p><p>3、一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A03.b5c78c7d.png" alt="删除堆顶元素3"></p><hr><p><strong>自顶向下(推荐使用)</strong></p><p>1、我们将最后一个元素移动到堆顶。</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A04.90633757.png" alt="删除堆顶元素4"></p><p>2、然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A05.ca1fc0c4.png" alt="删除堆顶元素5"></p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A06.9549fe90.png" alt="删除堆顶元素6"></p><h3 id="2-5-3、堆的操作总结"><a href="#2-5-3、堆的操作总结" class="headerlink" title="2.5.3、堆的操作总结"></a>2.5.3、堆的操作总结</h3><ul><li><strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li><li><strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。<strong>最好采用自顶向下堆化的方式。</strong></li></ul><h2 id="2-6、堆排序"><a href="#2-6、堆排序" class="headerlink" title="2.6、堆排序"></a>2.6、堆排序</h2><p>重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>详细过程如下图所示：</p><p>取出第一个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F1.4a22573f.png" alt="堆排序1"></p><p>取出第二个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F2.26994f33.png" alt="堆排序2"></p><p>取出第三个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F3.e411601b.png" alt="堆排序3"></p><p>取出第四个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F4.2b2472be.png" alt="堆排序4"></p><p>取出第五个元素并堆化：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeEAAAEjCAMAAAAytEmDAAABMlBMVEX////a6Pz/5sxsjr8AAAD/MzMTFBbfqyfY5fkLDAy2wtPZnQPgy9zoqLS0v9DjuUwgIyajrr5/iJM0ODzovVlESU8dHyHM2eyvuspxeILzcXjE0eOptMT94sJ5gYz47M6Zo7L316GLlKHisz+gqrn8Q0TY5vrix9iPmKbe2OqDi5ctMDTc4PO7x9niwdHluMZVWmLI1ee/y93qnalmbHb1ZmxtYlfR3/KTnKpsc31ZX2f7S00YGRz63bXv2Jvtjpjzz47vzYTrzX7vyHrpyHJhaHHtxW9LT1bmuE89QUfgrzMkJyrcpx3aoA7P3O/3Wl/f0OLvhY/9PD3jvMzmsL7Hs59cYmtQVVzwfofydn758Nr36sr+5cn047fz4rTslJ/ltkg7NS+xn46fj3/dx7FaUUh/PS8lAAALSElEQVR42uzdTYrcMBCGYVE0EUELbUR2wgjfITsb/2GMsZfZTPcMM/m5/xWS9cBMq7u9kJT3ucKHLUsuVan/xbmd7Lrtxph9W+3UnhXKUfW10cvchcZf5OKb0M2LNnVfKRTgadCb67y85zu36eFJIW/PdndBPhLcbp8V8vVS61E+N+r6RSFPldW9XNdry4KcpcHMEmc2g0JuqvW1kVjN68pjnJnWjHKL0bQKGZl0kNsEPSlkw9VebuVrp5AJu8g9FquQBevkPo6Is+AWudfCizoDUy33q/ncSl6rvdzPazZNiatMkEcEw9FH2tZRHjOuCgkbXuVRr5xRJ6wyjTyq4T2dMDvL42Z2xcl60XIETUlAqupejtDXCkl61nIMTe1WmuwoxxhZiZP0tMtRdopsUzQ4OYpjT5wiHeQoQSskp9rkOBunHunpnRzH9QqpqTs5TseWOD3GS4Q/p9N3uc4bhcSctUT4fYpLWDT3i1PTLnKV//UlNuGFWo/UTLNc8fPr6Z/IhGcKtlJjO7ni1+mGhDsOLlOzhqvP8Nvb27fYhAPFPKnZGonwIzbhZlNIy+4PTdjvCmkxl0MTvrAhTo2RQxMWEk4Nz3DpWIdLx7d06dYQlTD74WzZLiphzrSyNc1RCXMuna12iUqYf0vZOuuohPk/nC/jJRI1HnmiTqt01FqWjnrp4nHnoXTcWyoddw+Lx/3h0tEDoHj08SgdvXiKRz+t0tETr3j0tSwevWlLR3/p4tEjvnjMeSges1qKx7yl4jEzrXjMPSwes0uLx/zh4jFDvHyDmSXObDiLzlJldS/X9dryAOfqpdajfG7UNT/8c/ZsdxfkI8Htlpqs3D0NenOdl/d85zY9UDZbhKqvjV7mLjT+IhffhG5etKl7lt+SnNvJrttujNm31U4t94MBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/ZgwMBAAAAACD/10ZQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhj46JAACBAIbBvX/PeGCjJHunAgAAAAAAAAAA/GNoW7PvaR9oHa63Dtdbh+utw/XW4XrrcL11uN46XG8drrcO19vDzrm0KA5EYZSCQ0hcSB7kRUITgjTBIGhoiJFsRURwaf//fzJacR4Mg3bdhTNk8i16VcdbqUOVdTtND4a7MJypPyS7XFJZZXtelnNbOutVWZ5l7PusrBJh3dZbVvm7eKUXi0UjYZv5kFhUNyvftvFzwwF46g+Zgyt64uwEcMqEq7WGmahu0+u6uYT1LIB6JpxzBbxJ2CNDKgFrHwCc7csN2y46ri1ZrU2H0PCmR8fJzNnMQSc6iwyfLanhCLnhNUNmzwyfN5vvLuIfUtr2p+E2M6rsgZUkFizMZ50AUsMVuF4VwcWc7SBMtkAhMrxHaNiGsLylMWcbcLx5AN0zw59RlKvcddNlDUGiF+sEQTEYrlywDlfJvuu6K3WuryMfVt6Bfx0N69ca3ms/JdTmbAiJUgfwJYbncJQZzqCU3rR8PdumLL0vndIL+HnG+ehowx/o9Fe3PYSqAyt+WDmAXKlctNJtkiSO0PCurht9gkTmbF4UtnoPYG7O3rjDm8xwDlWZbjdKwAYwy0tPy/ii4ajbAaWKgWjda8NzIOy0Wz1mCRSPK0ewUmoFvezWYgkNDzlAKGJX6RFqSd0SGqHhCh2nErA91AY3rQXQ6NOqU77epnYArrrAWusi0+cv8Pmk8jA2A15v2N4DCxG7BZCsdOyQKqHhlHsSc9b5jX1u+DTcOD7UfrCov4ePEOx2u2HnxhZa/pPKf89wFgCpjPV6AM+cvdC3UsOd5ezboodPcxao8+IE4RcN64HpzXAI/vduKYJf7vNvQPqssvv9lI5ebTixgKX4hD8f4WjMxnD0/RBC3xbV1ct6Mp+zpXdvBZax4U/Y37sPVcPe11nd97CTPak89NceBC827AF9rgSs/fHRDaeWZcxu+JHYvFuy7evPhaSuqqHRPRPvpoZTOA0NtavWw34utttY3dQD4fOuJdWfdHmt4Y0FYSzrPCLY6DnXxmzs3ALgnE1ZG33edZKzQ130ebXVsgwNJ8C66ABXVcAyv4DVqgJYAtXTDoDt1oH8tYZ9IDxcsxN0WnD0lhbsZXOWfg8HcFykDixFnZblVxF8GBtW61/64ZAhS71HLuoTnOzxEwfoBO+vNXzgHke0WgMav9ZwzpCTLf+tpbP5quHD3fC953AKvf/bjnvTtdYflgGHx5XbEOB4Ft54eqFhC7lhlfcAQaPkhn0JW0QAh1jC2juA00r0fjjOf779OyfFyjZ74tjz4n/yfemjTmvhZX+hrj0v8o20bpsXzfQXAP81OxkeOzsZHjs7GR47OxkeOzsZHjs7GR47OxkeOzsZHjs7GR47OxkeOzsZHjs7/T+tsWfaw2NnJ8NjZ7+1c0Y7jQJRGM4kZwxuoNldI7XVNMZYWVoEW2xaWxOujGlMhBai7VXf/y32MENLTJQwXAg7O/8Fc4z5MrbfMCDVowzLzirDsrPKsOysMiw7qwzLzirDsrPKsOysMiw7qwzLzhYans/n9fzU1ftpObFhuJXmtQ7RRNnIMJy8EmMTI+aFbviu0LyO53s2L21Wihu+AYBaDFfvp+X1KSbUxVmHHhKJsltK9bwSYiNKuwSjrShmbZRnA5pmpWHps9L/dwxX76dlr7mjhSPM2pUN2wEyel6JsPEiM7yiPFZZdpcBK0KMrDTKG25PCwy32yKGv7HbEl/XEzfBF5sIs07AMmHLQ4C1KIueV+XZLgNSwxGOvrXBycuyuDQCFwFqkxA9R7hEwq8Nn5mmeY7jiWlektH7EcDwqbU3fG+a6X8LL03zlhDtAb9pPmkNNYx+LPbG+cIsj92n60iIdQ9eXWHDk4PhBJcmDn3Ey7E2Lgbu2Ytwd8cSt6/oS8PaMcAf3m6nPT0CluNxZvgOYMBbc7SINgSW5auA4W/spxUnSea5omFEDbF5Hdd11ygmr8qzkesG3LBP6YZfxo1yrBWGAQ4hAh5fHROU/aXhrPXOAOCZNbLo9I5Q6yeGfwPA/O0YoCdg+Ht78UQ7fKlhxXkNhgqy/NTLKyHWQMN8WHBhfnmWXxgsZLcFq4MbPgM41sgpwCXpDYfXJC3vPzGMhyvWHuylsYYTijGqsHzTs2owzFWtvBUeA4F5LZwu3J//G1wdBXdaJsDZlGkmNxed9xf41LAGAO/z+TsOo6Ya9hYUE1ddHVtSi2HSpVl2QixdRCUNdwA616x1zusQMJ8bHsMh46YaJsTBbXpSiQ1xadRk2NlQzFpkl06J0D6sy27RLs1usk6eAC5Ys5PHzq/OB8O/eZu71hSw5nltomFttQpw8CjtV5k3ZjeltRjG2J6rsbulkuxk/7wj5jcPYdGdFmYIGJObRM9vueEn1n/oB6Bh8pgeyOtsdtnM6zDu0DZ7GBBWmTfA7a4mw/Zu5xPi4DnsCDzxSPa/OCHl4NEuMjwAzANhVmftK8gN9/A4GJjM8Bzg5+xyCXDaTMMb3J9jv4+LW5zl+1w9hpmfndvFL8qyuBj63TReejZv4y27NBUYHgHmFoslZLnLDN/CPi3SPtqXzTQcU561I8zyHcCtx3D+1FIvyep0H594WeUVGianWbu/8QsAnMzwcM4Nk+tUa2/J3vTxM2BeWkTA8Df20yIuu5OeRFXY/T4nzi4OZhZVDXPFi7gki1xumCRrHNdJ2U8etLNfI/Ix5z+mh3p0cX1e+2ee5OvYXmw38nNadiz8wQ238rx6oqu/APhfWWVYdlYZlp1VhmVnlWHZWWVYdlYZlp1VhmVnlWHZWWVYdlYZlp1VhmVnVT8t2fMXdEkHpCpN8mQAAAAASUVORK5CYII=" alt="堆排序5"></p><p>取出第六个元素并堆化：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeEAAABRCAMAAADSKe79AAAA3lBMVEXa6Pxsjr8AAAD/MzPgy9yAiJQTFBYLDA20v9AzNzumscEgIybX5fn8Q0RudX/Y5vrL2esdHyLE0OJbYGlESE7op7R5gIziwtJmbHa7x9jhx9e2wtPltsWTnKpVWmLR3/Kst8fuiZPydXyPmKVOU1uYorH1aG7O2+6gqrmIkZ37SUwkJyoYGRy/y9zwf4jzcXj9PD3f0OLskJssLzPb5fnc4fXjvMyirbydp7Y+Qkfd3/Hd2euMlaJze4VhZ3DH1Oavusvmr734WFznqrfqn6rrmaVKTlXe1uj2XmM6PkPPHJPiAAAIcklEQVR42uyc24raUBSGd3/IeZPJiaJIDhCDDSZXuVDB05Xg+79Qk2Wc9qJV9yrYWvd/ozB+rDX7S3ZW4jDii87/HfFFsKPZl2Bfs2vNasOa1YbfhX3NrjWrDWtWG34X9jW71qw2rFlt+F3Y1+xas4qG/SSZiV8kiuMdr7K069qW3K6n2+2Cx37MtuWRWTdf1WXxwV7pb+t1y2Fb+5KAVTfafk2D+4YdwBW/iA14rN84WqLPMmKuVgbMWHWnDdUtOOzKHNhuxuy5BPCVw25wSclg5XwgrfTphqUHiic5q3XwwTR8aECxInU2skAJFyzDC5NrOATfcDays3uGF0Egr53mn5tW/sNwHilVXgFmcTSBtXrXNgCu4RTw3DIEYnXWB5JjCqBiGZ6AaVgCyXZIq862gOXaDuDfMzwPw0IUnucbHeAUtFhL4FxdDJceYJ56yYbneVOx6Dxvd7NyDBj9p4FMvesj+Ib35KcGOnU2AY5CnACDY9gGNjzDEVBzJy2Dum3r2n1ol/6GMVY0sBQyPAGl6d02QCJ8wAxuVnaAQggXcNS7zouisJiG465raQcJ1Vm3qqT4cABbnR24+VeeYRco6116EAz2DMyK7YpkPGg49DMAWxEM77OGDNsAEr8BNoI+UwOoblcOgakQU6DhTS0mz/CYE5Cw2OnuDHScujXQMg2XoFglg22Ajiatxw23tFv5wqDTVDqD4RjISBci2n/7zO9Uvnw2AvB8w3IC4BuLTdGHs9KBBV8wDe8w5qjOWp/so4aXl4ljIvYXi3QdPgNOHA9qKxoZSf6dyn/PcNS3C5/HrmgUX6mzMZqca9g3rX1eNcBcnQXQueslsHnUcHI1nADG9W4pBH6a578C8O9V9q67dPhsw8ceRc3e4RcbYKPMLoCzYSRAYkhWXVrWpXrPJlDQPm8qG54D+/HuY/jh3qD01gJzHMXuTVormnicpxqmkmgKwWDlZOL3L2vAVGYDfCZQ7llKya0rOrqutgA+VA37l0MqGwxnl/O5StNA9OqHJPfvWnZ0hYmfa/jQg0nfJYcNgQP13KkbtobQvLRQZSVov/M5e8d4V5qSLEXDRwBZ5QPwaNgz3Bgwc1EN7wGUtysXANLUAtznGjYAJPM+GWu1NivDBCa8nrnXYQc4r3cW6z68AEyjDIGJsmGRYYxH0zWlpj06FnPap4n+fdsU5+O5hk8YY6mz7hUN/sQwv+5S8p9aWsGjhk/D9E6G5X4A13T+5/718XbWvxxoRj7drpzTUbHJmRNPQzsXZ/LgGxZFQwflVPANGxy2olH2FHBYSYqXU9b3w4Fry09hx2oqFZ/Eu27wb35f+vtE39zoL9SVduUeuHVzd93qvwB4b/Y1u9asNqxZbfhd2NfsWrPasGa14XdhX7NrzWrDmtWG34V9za41qw1rdmT1/9P63t75NicNBHH4ZhdLUQoETGMxiMFKbWopwRBr0NbwR/D7fyGXTSDOWDB3DhOQ+71IdoY+k22fu2uA9vjfc6DjUrN6ldasNnws7GF2rVltWLPa8LGwh9m1ZrVhzWrDx8IeZtea1YY1m8Vwo9HIp2vPNEM1dhiYE6uqwFab6/iSLLebVnJsZAZxUZjMLF+GDe2pPY/LEZUjBcNVAMjHcAexoMTaZ0gZF+TZENfxJFluN62kWA/xjkdmDyn9SXbW4V6dIZVTLmeHY3jkoKLheR85bijNjpQMp+2mlQTrB+PEMJGcZlZ2lgCOEJOkNLMbrrW3GK7Vdmu4iRRFww5i14qItqXZ4YCzoBVgKMGm7XIlZ7iDFDbs0XnapHnsZmVdxIFFAM7Fgjx7DjW+2fB3wzDqdC4Zxr14vDwB+PRwujL8yjDe0WNfDONCiHKFHjRelXdo2PoHw12eBHeIU8V1Z36GfU+KTdu1pA1314YjGpp0OiM8C8tLjht7tue0uvvCp+XL22i4XAR4F2+3U2ufAKd4mxhOtgB4AXDKm/PE/za6O8NDy7L6ioaDKKqK6oJoWTb9mU/krpu2y5WUYc+yHDIcr7m9eFKb2djmeOzQaUH92vHo6JLsjYaTrXeeAfwQ7wFOKuek+foJw/QV0GgUAc53eqfFY1mR9Qb0rY4Vr2siLuSvy+2mlRRrxobNeEqOEWeyv9GaE8TOttHB9FuAYlm8BHgvzkule7EsXz1hmA7XvD3Yzd4ajpAyUWN9F7GZh2FW1bN7dHQkrlugyy1W85/g2WbDwgB422bNovq8cnkDTxouA8Blo3FJp8d9NWy7SAlUR0dH5GCYZ2CSgRSLriemmQxXAL7d89Y5V5+A8rThOqxzu6+GhQhpme4qsLxIBjkZDuPnw4jTrKy/JMYjIaL1Kj3ZYvgCoPQA8Jw3O/lY+fztD8NFMtwGquNc7aNh33EcOtmIZyrXDfimNAfDnLlt+Xy3lI31u6vXO4L45mGxiU1ovkk2YpNvhWikhh9487TXQIbFx+VBXLVarf38Pewi0qAe0NiWZ5nriXwMjwYDWmJDmsNhJpabxWj9Ws1QDOk432b4GVAqgq22rr5Cavh8OXGvDTZM4l+07n8CvNxPwz1an4Mp0Y48y883zHwMs5+ZdUftZ2SrfVqoOsvYy747QWcjm9CPQLngTx1I8iYxfAEcNlw7WZX7aTjAOP1QnuUVwMrHcPqqZSEjW8BVpsJOKnurYfEy2e7v9gYASi061GPD4gN/ggGZf02P/gDKzanYrWFX0bCw+E564SmwPI9CpZ7Tdl0Fw531fRO6QVbW/M2wiPp07kdZ33kon/6x53j9dXtdPz7/UM//Pc/NGdnBfD/fp/1L5vbE8hXZasEuVPVfABwre5hda1Yb1qw2fCzsYXatWW1Ys9rwsbCH2bVmtWHNasPHwh5m15rVhjWr99M6kvwC1z+0SNUVhy0AAAAASUVORK5CYII=" alt="堆排序6"></p><h1 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h1><p>树的特点：</p><ol><li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li><li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li><li>一棵树不包含回路。</li></ol><p><img src="/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220724215505026.png" alt="二叉树"></p><ul><li><strong>节点</strong> ：树中的每个元素都可以统称为节点。</li><li><strong>根节点</strong> ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li><li><strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li><li><strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li><li><strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li><li><strong>叶子节点</strong> ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li><li><strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li><li><strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li><li><strong>节点的层数</strong> ：节点的深度+1。</li><li><strong>树的高度</strong> ：根节点的高度。</li></ul><h2 id="3-1、二叉树的分类"><a href="#3-1、二叉树的分类" class="headerlink" title="3.1、二叉树的分类"></a>3.1、二叉树的分类</h2><p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^(k+1)-1</code> 个节点（满二叉树的情况），至少有 2^(k) 个节点</p><h3 id="3-1-1、满二叉树"><a href="#3-1-1、满二叉树" class="headerlink" title="3.1.1、满二叉树"></a>3.1.1、满二叉树</h3><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.9025b079.png" alt="img"></p><h3 id="3-1-2、完全二叉树"><a href="#3-1-2、完全二叉树" class="headerlink" title="3.1.2、完全二叉树"></a>3.1.2、完全二叉树</h3><p>除了最后一层以外，每一层都是慢的，并且最后一层或者是满的，或者是在右边缺少连续若干节点。</p><p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。</p><p><img src="https://javaguide.cn/assets/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.c4f02f51.png" alt="img"></p><p>当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。</p><h3 id="3-1-3、平衡二叉树"><a href="#3-1-3、平衡二叉树" class="headerlink" title="3.1.3、平衡二叉树"></a>3.1.3、平衡二叉树</h3><p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p><ol><li>可以是一棵空树</li><li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li></ol><p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p><h2 id="3-2、二叉树的存储"><a href="#3-2、二叉树的存储" class="headerlink" title="3.2、二叉树的存储"></a>3.2、二叉树的存储</h2><h3 id="3-2-1、链式存储"><a href="#3-2-1、链式存储" class="headerlink" title="3.2.1、链式存储"></a>3.2.1、链式存储</h3><ul><li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li><li>左节点指针 left</li><li>右节点指针 right。</li></ul><p><img src="https://javaguide.cn/assets/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91.8dfe7691.png" alt="img"></p><h3 id="3-2-2、顺序存储"><a href="#3-2-2、顺序存储" class="headerlink" title="3.2.2、顺序存储"></a>3.2.2、顺序存储</h3><p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 <code>2i</code> 的位置，它的右子节点存储在下标为 <code>2i+1</code> 的位置。</p><p>一棵完全二叉树的数组顺序存储如下图所示：</p><p><img src="https://javaguide.cn/assets/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.ec1113ca.png" alt="img"></p><h1 id="四、红黑树"><a href="#四、红黑树" class="headerlink" title="四、红黑树"></a>四、红黑树</h1><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment">漫画：什么是红黑树？</a></p><h1 id="五、布隆过滤器"><a href="#五、布隆过滤器" class="headerlink" title="五、布隆过滤器"></a>五、布隆过滤器</h1><p>传来一个数据，将这个数据利用hash函数变成二进制，然后放到一个数组中，数组中原来全是0，数据通过hash函数编程二进制之后，将数组中的对应位置编程1，下一次传入数据的时候通过hash函数计算之后去数组中对应地方寻找，如果所寻找的对应位置是1，那么这个数据就存在。</p><p>在redis中，存在redis之前 数据库之前，用来解决缓存穿透</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统基础"><a href="#一、操作系统基础" class="headerlink" title="一、操作系统基础"></a>一、操作系统基础</h1><h2 id="1-1-什么是操作系统？"><a href="#1-1-什么是操作系统？" class="headerlink" title="1.1 什么是操作系统？"></a>1.1 什么是操作系统？</h2><ol><li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><h2 id="1-2、什么是系统调用？"><a href="#1-2、什么是系统调用？" class="headerlink" title="1.2、什么是系统调用？"></a>1.2、什么是系统调用？</h2><p>进程在系统上的运行分为两个级别：</p><ol><li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li><li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>按功能可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能</li></ul><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220724215539929.png"></p><h2 id="1-3、操作系统的内核-Kernel"><a href="#1-3、操作系统的内核-Kernel" class="headerlink" title="1.3、操作系统的内核(Kernel)"></a>1.3、操作系统的内核(Kernel)</h2><ol><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li><li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li></ol><h3 id="1-4、中央处理器（CPU，Central-Processing-Unit）"><a href="#1-4、中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="1.4、中央处理器（CPU，Central Processing Unit）"></a>1.4、中央处理器（CPU，Central Processing Unit）</h3><ol><li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li><li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li><li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li></ol><h2 id="1-5、Kernel-vs-CPU"><a href="#1-5、Kernel-vs-CPU" class="headerlink" title="1.5、Kernel vs CPU"></a>1.5、Kernel vs CPU</h2><ol><li>操作系统的CPU属于硬件，Kernel属于操作系统层面</li><li>CPU主要提供运算、处理各种指令的能力；而内核主要负责系统管理</li></ol><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220724215551114.png" alt="Kernel_Layout"></p><h1 id="二、进程和线程"><a href="#二、进程和线程" class="headerlink" title="二、进程和线程"></a>二、进程和线程</h1><h2 id="2-1、进程和线程的区别"><a href="#2-1、进程和线程的区别" class="headerlink" title="2.1、进程和线程的区别"></a>2.1、进程和线程的区别</h2><p>线程是进程的一个小单位，一个进程中可能有多个线程，进程之间是相互独立的，但是线程之间却不是，可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h2 id="2-2、进程的状态"><a href="#2-2、进程的状态" class="headerlink" title="2.2、进程的状态"></a>2.2、进程的状态</h2><p>创建、就绪、运行、阻塞、结束</p><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712164004769.png" alt="进程的状态"></p><h2 id="2-3、进程间的通信方式"><a href="#2-3、进程间的通信方式" class="headerlink" title="2.3、进程间的通信方式"></a>2.3、进程间的通信方式</h2><ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于<code>具有亲缘关系的父子进程间或者兄弟进程之间的通信</code>。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，<code>可以实现本机任意两个进程通信。</code></li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于<code>通知接收进程某个事件已经发生；</code></li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符(队列ID)标识。管道和消息队列的通信数据都是<strong>先进先出</strong>的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是<strong>消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除</strong>。消息队列可以<code>实现消息的随机查询</code>,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要<code>用于实现线程之间的互斥与同步。</code></li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是**<code>最有用</code>**的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用<code>于在客户端和服务器之间通过网络进行通信</code>。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程</li></ol><h2 id="2-4、线程之间的同步方式"><a href="#2-4、线程之间的同步方式" class="headerlink" title="2.4、线程之间的同步方式"></a>2.4、线程之间的同步方式</h2><p><strong>1、互斥量：</strong>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p><strong>2、信号量：</strong> 允许同一时刻多个线程访问同一个资源，但是线程数量要有一个限制</p><p><strong>3、事件：</strong> 通过通知操作的方式来保持多线程同步</p><h2 id="2-5、进程的调度算法"><a href="#2-5、进程的调度算法" class="headerlink" title="2.5、进程的调度算法"></a>2.5、进程的调度算法</h2><ul><li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列调度算法：</strong>(<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/449587?fr=aladdin)%EF%BC%9A">https://baike.baidu.com/item/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/449587?fr=aladdin)：</a>  多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h2 id="2-6、死锁产生的条件"><a href="#2-6、死锁产生的条件" class="headerlink" title="2.6、死锁产生的条件"></a>2.6、死锁产生的条件</h2><ul><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul><h2 id="2-7、解决死锁的方法"><a href="#2-7、解决死锁的方法" class="headerlink" title="2.7、解决死锁的方法"></a>2.7、解决死锁的方法</h2><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ul><h3 id="2-7-1、死锁的预防"><a href="#2-7-1、死锁的预防" class="headerlink" title="2.7.1、死锁的预防"></a>2.7.1、死锁的预防</h3><p>一般是破坏死锁产生的条件的第二个和第四个条件</p><p><strong>1、静态分配</strong>，负责破坏第二个条件，当一个进程在执行之前申请到他所需要的所有资源，并且所有资源都满足之后才开始执行。 <strong>严重降低了资源利用率</strong></p><p><strong>2、层次分配策略</strong>，将所有的资源按层次分配，当一个进程得到某一次的一个资源以后，只能申请再高一级的资源；当一个进程要释放某层的一个资源，那么他就只能通过先释放高层的资源以后再释放底层级的资源，</p><h3 id="2-7-2、死锁的避免"><a href="#2-7-2、死锁的避免" class="headerlink" title="2.7.2、死锁的避免"></a>2.7.2、死锁的避免</h3><p>银行家算法：<a href="https://blog.csdn.net/qq_33414271/article/details/80245715">一句话+一张图说清楚——银行家算法</a></p><p>有一个Available(空闲资源数量)，当有进程申请资源的时候，Available尝试着分配给进程p1，如果没有出现死锁，那么我就继续往下分配给接下来的p2….，如果出现死锁，那么我就不分配给p1，尝试着分配给p2。若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–&gt;回收（Work+已分配给P0的A0=Work）–&gt;分配给P3–&gt;回收(Work+A3=Work) –&gt; 分配给P2 –&gt; ······满足所有进程）。</p><p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p><h3 id="2-7-3、死锁的检测"><a href="#2-7-3、死锁的检测" class="headerlink" title="2.7.3、死锁的检测"></a>2.7.3、死锁的检测</h3><p>资源分配图化简：</p><blockquote><p>第一步：先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞（“不阻塞”即：系统有足够的空闲资源分配给它）的； 第二步：把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来； 第三步：看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点； 第四步：最后，所有的资源和进程都变成孤立的点。这样的图就叫做“可完全简化”； 如果一个图可完全简化，则不会产生死锁；如果一个图不可完全简化（即：图中还有“边”存在），则会产生死锁。这就是“死锁定理”。 </p></blockquote><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712221401480.png"></p><p>第一步：先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。<br>第二步：再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。<br>第三步：看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。<br>第四步：再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示：</p><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712221408659.png"></p><p>第五步：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图： </p><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712221423591.png"></p><p>因此不会产生死锁。</p><h3 id="2-7-4、死锁的解除"><a href="#2-7-4、死锁的解除" class="headerlink" title="2.7.4、死锁的解除"></a>2.7.4、死锁的解除</h3><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p><ol><li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li><li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li><li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除</li></ol><h1 id="三、操作系统内存管理"><a href="#三、操作系统内存管理" class="headerlink" title="三、操作系统内存管理"></a>三、操作系统内存管理</h1><hr><h2 id="3-1、操作系统的内存管理主要是干什么？"><a href="#3-1、操作系统的内存管理主要是干什么？" class="headerlink" title="3.1、操作系统的内存管理主要是干什么？"></a>3.1、操作系统的内存管理主要是干什么？</h2><p>主要负责的是内存的分配与回收，以及地址转换(就是将逻辑地址转换为对应的物理地址)</p><hr><h2 id="3-2、操作系统的内存管理机制有哪些？"><a href="#3-2、操作系统的内存管理机制有哪些？" class="headerlink" title="3.2、操作系统的内存管理机制有哪些？"></a>3.2、操作系统的内存管理机制有哪些？</h2><p>分为<strong>连续分配管理机制</strong>以及<strong>非连续分配管理机制</strong>两种</p><p><code>连续分配管理机制</code>：</p><ul><li>块式管理：将内存划分为几个固定大小的块，每一个块只包含一个进程，当有进程需要内存的时候，就分配给它一个块；但是如果这个程序只需要一点点内存的话，这个块中就会有一些内存没有被利用，这些没有被利用但是被分配出去的内存就被称为碎片。</li></ul><p><code>非连续分配管理机制</code>：</p><ul><li>页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li>段式管理：段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息。 段式管理通过段表对应逻辑地址和物理地址。</li><li>段页式管理机制：段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。</li></ul><p><strong>逻辑地址：</strong> 是用户可以看见的地址</p><p><strong>物理地址：</strong> 对应的是CPU地址上传来的地址，是在内存条中相对应的地址</p><p>逻辑地址就相当于是windows系统上一个文件 例如：G:\A-学习笔记\Android开发 物理地址则是这个文件在CPU上处于那里，物理地址不可见，逻辑地址可见</p><hr><h2 id="3-3、快表和多级页表"><a href="#3-3、快表和多级页表" class="headerlink" title="3.3、快表和多级页表"></a>3.3、快表和多级页表</h2><p><strong>快表：</strong>一种高速缓存器(Cache)，其中的内容是页表的一部分内容或者页表的全部内容</p><p><strong>使用快表之后的地址转换过程是：</strong></p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><hr><p><strong>页表就是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。</strong></p><p><strong>⻚表的作⽤</strong>是将虚拟地址转换为物理地址</p><hr><p><strong>多级页表：</strong></p><p><strong>可以压缩页表占用的内存</strong>，将一个内存(4GB)全部分为一级页表(4KB，占用4B)之后，需要1M个页表项，每一个页表占用4MB的内存空间；但是当我们使用二级页表之后，一级页表映射4MB，二级页表映射4KB，这个时候就会有1K个一级页表，每一个一级页表对应1K个二级页表，但是一级页表不会全部被使用，所以也不需要这个一级页表对应的二级页表，假设只有20%的页表被使用，那么页表占用空间就只有0.804MB（1K * 4B + 0.2 * 1K * 1K * 4B = 0.804MB）</p><hr><h2 id="3-4、分页机制和分段机制有哪些共同点和区别呢？"><a href="#3-4、分页机制和分段机制有哪些共同点和区别呢？" class="headerlink" title="3.4、分页机制和分段机制有哪些共同点和区别呢？"></a>3.4、<strong>分页机制和分段机制有哪些共同点和区别呢？</strong></h2><ol><li>共同点：<ul><li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul></li><li>区别：<ul><li><strong>页的大小是固定的</strong>，由操作系统决定；而<strong>段的大小不固定</strong>，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要</li></ul></li></ol><h2 id="3-5、逻辑地址和物理地址"><a href="#3-5、逻辑地址和物理地址" class="headerlink" title="3.5、逻辑地址和物理地址"></a>3.5、逻辑地址和物理地址</h2><p>在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址</p><h2 id="3-6、CPU寻址"><a href="#3-6、CPU寻址" class="headerlink" title="3.6、CPU寻址"></a>3.6、CPU寻址</h2><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。</p><hr><p><strong><code>为什么要有虚拟地址空间？</code></strong></p><p><strong>没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存，容易造成对操作系统的破坏，而且根本无法同时运行两个以及两个以上的程序。</strong>微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。</p><p><img src="https://img-blog.csdnimg.cn/72ab76ba697e470b8ceb14d5fc5688d9.png"></p><h1 id="四、虚拟内存"><a href="#四、虚拟内存" class="headerlink" title="四、虚拟内存"></a>四、虚拟内存</h1><h2 id="4-1、什么是虚拟内存？"><a href="#4-1、什么是虚拟内存？" class="headerlink" title="4.1、什么是虚拟内存？"></a>4.1、什么是虚拟内存？</h2><p><strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。<strong>虚拟内存技术：</strong>即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。</p><p><strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间。</strong></p><h2 id="4-2、局部性原理"><a href="#4-2、局部性原理" class="headerlink" title="4.2、局部性原理"></a>4.2、局部性原理</h2><p>表现在以下两个方面：</p><p><strong>1、时间局部性：</strong>由于存在循环，可能一个指令一个数据被执行或者被访问之后过一段时间就再次执行或者访问</p><p><strong>2、空间局部性：</strong>程序在一段时间内所访问的地址，可能集中在一定的范围之内</p><h2 id="4-3、虚拟存储器"><a href="#4-3、虚拟存储器" class="headerlink" title="4.3、虚拟存储器"></a>4.3、虚拟存储器</h2><ul><li>虚拟存储器的定义<ul><li>虚拟存储器是指<strong>仅把作业的一部分装入内存便可运行作业</strong>的存储管理系统，</li><li>它具有<strong>请求调入功能</strong>和<strong>置换功能</strong>，能从逻辑上对内存容量进行扩充，</li><li>其逻辑容量由外存容量和内存容量之和决定，其<strong>运行速度接近于内存</strong>，<strong>成本接近于外存</strong>。</li></ul></li></ul><h2 id="4-4、虚拟内存的技术实现"><a href="#4-4、虚拟内存的技术实现" class="headerlink" title="4.4、虚拟内存的技术实现"></a>4.4、虚拟内存的技术实现</h2><p>虚拟内存的技术实现主要建立在离散分配的内存管理方式的基础上，所以主要有三种方式：</p><ol><li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。<strong>请求分页是目前最常用的一种实现虚拟存储器的方法</strong>。请求分页存储管理系统中，在作业开始运行之前，<strong>仅装入当前要执行的部分段即可运行</strong>。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，<strong>增加了请求调段功能、分段置换功能</strong>。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li></ol><h2 id="4-5、页面置换算法"><a href="#4-5、页面置换算法" class="headerlink" title="4.5、页面置换算法"></a>4.5、页面置换算法</h2><p><a href="https://www.jianshu.com/p/18285ecffbfb">页面置换算法</a></p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下d的若千页面中哪个是未来最长时间内不再被访问的，<strong>因而该算法无法实现</strong>。一般作为衡量其他置换算法的方法。**(填数的时候，当数字不在框中的时候，选择该数字后面中出现最远的数字加以替换)**</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> ： 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。 <strong>算法性能差</strong> (填数的时候，当数字不在框中时，横着找最长的连续数字将这个数字划掉，然后将新的数字填入)</li><li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。(当数字不在框中的时候，选择最前面的数字将其划掉，然后将新的数字填入，当数字在框中的时候，将前面相同的数划掉，这一列不写数字。)</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> ：该置换算法选择在之前时期使用最少的页面作为淘汰页</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="一、OSI和TCP-IP网络分层"><a href="#一、OSI和TCP-IP网络分层" class="headerlink" title="一、OSI和TCP/IP网络分层"></a>一、OSI和TCP/IP网络分层</h1><h2 id="1-1、OSI七层协议"><a href="#1-1、OSI七层协议" class="headerlink" title="1.1、OSI七层协议"></a>1.1、OSI七层协议</h2><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215655470.png" alt="OSI七层协议"></p><p><strong>有些功能在多个层中重复出现。</strong></p><h2 id="1-2、TCP-IP-四层模型"><a href="#1-2、TCP-IP-四层模型" class="headerlink" title="1.2、TCP/IP 四层模型"></a>1.2、TCP/IP 四层模型</h2><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220919100919057.png" alt="TCP/IP 四层模型"></p><hr><p><strong><code>应用层</code></strong></p><p><strong>位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong></p><hr><p><strong><code>传输层</code></strong></p><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong>     </p><p><strong>运输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><p><img src="https://javaguide.cn/assets/transport-layer.583ce71a.png"></p><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220919100933620.png" alt="transport-layer"></p><hr><p><strong><code>网络层（网际层/IP层）</code></strong></p><p><strong>网络层负责为分组交换网上的不同主机提供通信服务，网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p><hr><p><strong><code>网络接口层</code></strong></p><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><ol><li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li><li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li></ol><h2 id="1-3、为什么要分层？"><a href="#1-3、为什么要分层？" class="headerlink" title="1.3、为什么要分层？"></a>1.3、为什么要分层？</h2><p>1、各层之间相互独立</p><p>2、提高了整体灵活性</p><p>3、大问题化小</p><h1 id="二、Http-vs-HTTPS"><a href="#二、Http-vs-HTTPS" class="headerlink" title="二、Http vs HTTPS"></a>二、Http vs HTTPS</h1><h2 id="2-1、HTTP-默认端口80"><a href="#2-1、HTTP-默认端口80" class="headerlink" title="2.1、HTTP(默认端口80)"></a>2.1、HTTP(默认端口80)</h2><p>全称：超文本传输协议，顾名思义：就是用来规范超文本(html代码)的传输。具体来说，主要是来规范浏览器和服务器端的行为的，并且HTTP是一个无状态的协议，也就是服务器不需要维护客户端发来的请求的消息。</p><hr><p><strong><code>通信过程：</code></strong></p><ol><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li><li>服务器接收来自浏览器的 TCP 连接。</li><li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li><li>关闭 TCP 连接。</li></ol><hr><p><strong><code>优点</code></strong></p><p>扩展性强、速度快、跨平台支持性好</p><h2 id="2-2、HTTPS-默认端口443"><a href="#2-2、HTTPS-默认端口443" class="headerlink" title="2.2、HTTPS(默认端口443)"></a>2.2、HTTPS(默认端口443)</h2><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p><hr><p><strong><code>优点：</code></strong></p><p>保密性好、信任度高。</p><h2 id="2-3、HTTPS-的核心—SSL-TLS协议"><a href="#2-3、HTTPS-的核心—SSL-TLS协议" class="headerlink" title="2.3、HTTPS 的核心—SSL/TLS协议"></a>2.3、HTTPS 的核心—SSL/TLS协议</h2><p><strong><code>SSL与TLS的区别</code></strong></p><p>SSL刚发行就是3.0，然后在SSL3.0的基础上进行了进一步升级 就变成<code>TLS1.0</code>    </p><hr><h3 id="2-3-1、工作原理"><a href="#2-3-1、工作原理" class="headerlink" title="2.3.1、工作原理"></a>2.3.1、工作原理</h3><hr><p><strong><code>非对称加密：</code></strong></p><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。</p><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215733002.png"></p><p><strong>单向函数：</strong>已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p><p><strong>单向陷门函数：</strong>一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p><hr><p><strong><code>对称加密</code></strong></p><p>由于非对称加密的计算代价大，效率低，所以实际上使用的是对称加密。</p><p><strong>对称加密：</strong>通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p><p><img src="https://javaguide.cn/assets/symmetric-encryption.20454cea.png" alt="img"></p><hr><p><strong><code>证书颁发机构</code></strong></p><p>为了公钥传输的信赖性问题，第三方机构应运而生——<strong>证书颁发机构</strong>（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>。</p><p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p><hr><p><strong><code>数字签字</code></strong></p><p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能</p><blockquote><p>CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p><p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p><p>客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p></blockquote><p>带有证书的公钥传输机制如下：</p><ol><li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li><li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li><li>S 获得 CA 颁发的证书，将该证书传递给 C。</li><li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li><li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li></ol><p><img src="https://javaguide.cn/assets/public-key-transmission.a8809fd8.png" alt="img"></p><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220712110017350.png"></p><h1 id="三、HTTP-1-0-vs-HTTP-1-1-应用层"><a href="#三、HTTP-1-0-vs-HTTP-1-1-应用层" class="headerlink" title="三、HTTP 1.0 vs HTTP 1.1(应用层)"></a>三、HTTP 1.0 vs HTTP 1.1(应用层)</h1><h2 id="3-1、缓存处理"><a href="#3-1、缓存处理" class="headerlink" title="3.1、缓存处理"></a>3.1、缓存处理</h2><h3 id="3-1-1、HTTP-1-0"><a href="#3-1-1、HTTP-1-0" class="headerlink" title="3.1.1、HTTP/1.0"></a>3.1.1、HTTP/1.0</h3><p>如果服务器接收到了请求头，并判断<code>If-Modified-Since</code>时间后，资源确实没有修改过，则返回给客户端一个<code>304 not modified</code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。</p><p><img src="https://javaguide.cn/assets/HTTP1.0cache1.2f2b7eac.png" alt="HTTP1.0cache1"></p><p><img src="https://javaguide.cn/assets/HTTP1.0cache2.7430070e.png" alt="HTTP1.0cache2"></p><h3 id="3-1-2、HTTP-1-1"><a href="#3-1-2、HTTP-1-1" class="headerlink" title="3.1.2、HTTP/1.1"></a>3.1.2、HTTP/1.1</h3><p>HTTP/1.1的缓存机制在HTTP/1.0的基础上，大大增加了灵活性和扩展性。基本工作原理和HTTP/1.0保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是<code>Cache-Control</code></p><h2 id="3-2、连接方式"><a href="#3-2、连接方式" class="headerlink" title="3.2、连接方式"></a>3.2、连接方式</h2><p><strong>HTTP/1.0 默认使用短连接</strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。</p><p><strong>为了解决 HTTP/1.0 存在的资源浪费的问题， HTTP/1.1 优化为默认长连接模式 。</strong> 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该TCP连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p><p>有必要说明的是，HTTP/1.0仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在HTTP/1.1中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p><p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p><p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p><h2 id="3-3、Host头处理"><a href="#3-3、Host头处理" class="headerlink" title="3.3、Host头处理"></a>3.3、Host头处理</h2><p>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，但是HTTP/1.0并没有考虑这个问题，假设我们有一个资源URL是   <a href="http://example1.org/home.html%EF%BC%8C">http://example1.org/home.html，</a>  HTTP/1.0的请求报文中，将会请求的是 <code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p><p>因此，HTTP/1.1在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">GET /home.html HTTP/1.1<br>Host: example1.org<br></code></pre></td></tr></table></figure><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p><h2 id="3-4、带宽优化"><a href="#3-4、带宽优化" class="headerlink" title="3.4、带宽优化"></a>3.4、带宽优化</h2><h3 id="3-4-1、状态码100"><a href="#3-4-1、状态码100" class="headerlink" title="3.4.1、状态码100"></a>3.4.1、状态码100</h3><p>HTTP/1.1中新加入了状态码<code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应，过程如下图：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYUAAADSCAMAAACSASyBAAAA4VBMVEX///8AAADg4OAfHx+enp6goKDnplIAgsb/46Wl4////8ZeXl7G//9SpucAVaViYmLGggD/x4SEx//n/////+elVQCEAAAcHBwAAISjo6NSAFJSAAAAAFJSAISEAFLAwMA6OjqEAISlVVLv7+8WFhZSpsjn46VSVaXnx4R+fn7n4//n/+fG/8aEwefG46XGx4TGglKl4+cAgqWZh5HGgoSlVYSlggCEggBSVQDn5Of/4+fXzcyP0cZSgsalyqVSgoQAVVLnx6WEpqXnpoTGplJRUlHGx//n/8aEVaWlpoSEglJdQquRAAALx0lEQVR42uydiZbSMBSGE0ebKZIx7QCDgo77vu/77jke3/+BzL1Z2g7IMuAQpv93BFq6eMyXm7SJ3AoAAAAAAAAAAAAAAAAAAAAAAAAAAPA/MVo02b3cjcuZDgt7+wLUMesskd4PqY9YGKlq+VIuRDHskoX2msikRXcG0sHFU0jdLDRpGXbd5zhf4txNyrhhnNeNw4L9h/f61kIZGg8u9YiqVVf6pJVlzi06g2CU/w4jAyzWNU+w0LBgl6i0uNby6jhf0UJnMM4bFpSIFCG8VCE9sMBRUNrX3v7uyMXEsLtSi8RG6xV/wkJYbHsPzW03WzC0QOHApTf+OJC0tEosiCJW74zCa9ICtVcko+3EWJisw0dKx2j79VKVlXt5Y8u/oHNNs0Dr2d5dyfhIayPBQmyYq44hIxGxs67QYgn4+MqnkTVcn+zEtDskgoWPHA1GxTJjilg7d0e3+sdotQtJRjPS67v/RizQy6iwpb0EC4/c5VEZvlZHdrPFSO3Rsl2OqkWE1dssa+5znvV1r1+7pWglsXfm63VbO6lIKnw99cVjlr2ULBotftRcwUFo3bi+qTNoq4XQO/OfUFPrd3Gm3k8XbGZhuLGvLrT4vYIFf7mUw0K0YEvsTSwzE5vxVe4XJi1QwE3uAgtGCW/BtjtlqKDDrl8oV7pfaFpgq9Maredtt0Dl4i2Y8VtXU01sc4pVRjAm+wXqd6bd1rU+Fmw5ewuG7qFkaV+6urLXYo0tEofWJFWImNbetKnOQI5z+8ZxMHkxOhkL7SwoAAAAAAAAAAAAAAAAAABsBRe2GXFaODi/veyI08LBRbGtnIWFBICFFICFFICFFICFFICFFICFFICFFICFFICFFICFFICFFICFFICFY7D7aUo+rUwJo2o/hjEKFmam/3EFZaQjZnQY51ktW4Ep7VvnSt4oZ8f716rKcDDshq29+8ad/J2RChYWs1D/JW+vr+NGTnUjOte6nGWlspDJWK6967mPhSqRTVTpvithYTULXI0LesmvtENI/vRWiQojPboRKZUco2FhZQuZtl+WvANTUB6UmB1CNfqFTPu0cpzJrPdtJEtYWNVCIcvQ5lQWWE7VQ2QyUtqjlWuwCnnrfvxpPCzMT5E43ULMcbJ7Z3+mhZBelD+4E8+e96lTCMDCarHAFErMsTCqbPIJpLJdMi81O2tYOL4FU4olYkGYcc5mqvpvlSAWVrLA16lLxIKRJX0XfoUfsxO1xsKHdVuId8ezLRTfYyxwrWcLVQLeQlJmTVo+SQsfxIY43Dn3PyxkeiI1TcOCVI0WyVuoNnP5c5bTk7Rw7+qh2AxX5cG5Ex1HYmclFT/fNasqYWBsi3Tlg2SfmIUbUm7Iw6GU1gPGVJl7clMerkr2AAsuGNbr4d25BSH/7GGbLdw8tx5+yfV6ONxZkAPp2Lm5xRbkznq4Kb2GM+JkcbFwcBYtkmueN9I13HAOFumdi7Io/ZiopiFSfXS4YW9/1iwaX942r03rx5cJWDjcgAPmnncw30LvVfdpTsXGZXnnwbeRioPWVOzzZ9He0fxPJh2kYO9Bv6y8TMLmHl/KT8rC1Q1dIt24SQ4Ws/Bi/6V/mgmPmdJQj33VR97mz6Lx0QXlseRIetQvszk53V92f5yUhUNysAnOkoMFLfRv9XWwQG9+wMjHAg1Pz5xFcw7+5CSntI0THdqzFpTXNp3O7wevuid173woNs5CvXMhG5RNC7Nn0Th9731rSfOo3fuf47wXY4G/o1HVjCfahg/9aqF3H5360bxlLbhYqAZNmy3S7Fm0ekZlGqqz+h5UsUBFzrubYbcY5361HWOqx7LwcDB+dj2nPoBs+DE9ioU5s2iVM1onarFgj6XM47TTl5EWfhUWppP5OYGyM3h+PzY/i8yixQhiOXxg+Ax7lmFY26+2ZH5hSQvUTlAlZxlqspuYM4vGFjLFFvjN7mQjymhTukjRbJIF8ios/ItgoeQR6tAe0Q3B3Fk0tmA0C+AT2Y7dbjXOrBk+GefuYThK+FVYmGEhk+O3fFXk7n6Hj0dqgVk0skBVXIU+pNen8icvheJM8IbuJEhkGVZh4V8W/FVkSbduBHewaoFZNG7CtGvNKChsST/NXXQ8/TzSFDLKDLukLKzCwjQMl2AYTqo9sKCQ43zmLFrjYTeFVDYejPYHpjKat3kwppoCsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACBxfPbCunyYLcXk6PhTPbjAAAAAAAAAAAAAAAAAAAAGgrZ7cZcVo42NlixGkB/wcjBWAhBWAhBWAhBWAhBdKwYDMCwMIG4IxvFdmwCwsL4tO9UFKXkXQ86kuH6gyqNFUuY0mmZtR2U8bEGhUaFpaxEJ+sEPLW8saYMinTjQfm1Z+kR7JUETPiUhoT9Atrt7B7iXPrNR+Yx0/Si0GRKd8cFdGC0XwCWFifhZBvNezAT9L7t4XH1kOm7No4h4U1WOBttmQLJfwOkaMWbo/oiaxs4eGgpFPQk2VgYSEL0jHdQmjqhSnnW6D0eWzhzr7RtNm6Rb+wjlioHl67sAVqlWwQ2IPtBlhYnwWq3ktY4Cyg9pRWByys0UKmxeL9gtF8pFFG40p1nRae5rMsDKR0scDXSO6iVrMdWFifhSqjs1Fxo/jXlSov+WVY+Nveua22DQRhWOvSXZx4zUjErVOoHXBaaBtIQ5Le9KYXPdD3f6HuP3tA0ZrESiyzcufHlrVmpYv5NHuaFXNYsclJKeNmEnCOKCMUxiahUIKEQgkSCiVIKJSg4ils/jcKm6o4rS8mA1HAqP8xnfxuFb73mACQeQmFyWlxmyXXF+p0mBYJkZvpU7O6JD0/CAUwUG+rsuQYKDUZiIL+8a44Co6BUmW5AjOAKwxAIWbX7CS4C+ZH2B9HztCDH41EGEwCB90K7ddhkkyo4X/n30zFF5qeFJiBuqwKEhhA68nuujzvs4qEfiFLcBcWlsigBr4wdMPGjxSwmIRrPQRUsgjKcdoejTCb8hl6cMMeFMAAup3sR5s95Wzur90pkGFL5gnuYNTIKQJ7SAGW7jQ+uBXwoSpbn6z/t0euc7VnfSrfF8LznCe4S0n1UuhZqY4voK2yVfSb1kKsNv6WZPgqtFEj94WB+wVSLLs1wR0K6BganJjMFzwom1OgRCH40/j7hcHHSN4Xtie4g+XdB9ZFlRYFYgpM45EWyX2OZYwU5wtDUsgT3HG/APM7o+Jv+APjQE/s6vp+ITkB0JHJemfUReEY5gvDz53zBHd49kOKYeUszrtXjUfhCvOfiC6nEE4+UtVhpFrzLtcjmTvLOtL4dCQURi6hUIKEQgkSCiXo8BSwIVIovJgClijmf1bTsKmoLettXHd3F2mcRrXTaGueZwuF8x7Gt26+oLFIxPuyJ4vlLDcsU0ApmZ4rx6lCSzxn5jl2DEh8WVihsBMFNl0wLJluJJRdY3mNY4w1WK1iMeBJQjltzWuEwm4U8I4B//LhAZ90rp09oy/AMcgGn9CBAi6N3Mjik7avViQUntTX6dn91RvVlgmWT8/4ye37q9VfxdpCIW6Wx4IRB3zwrgPYkqlqW+lGKOyk6AbUtAY917wTHrrDu4JdX6iBxFP4iJgpSJgUoAAF6Z2fQYGU1XigbTAitsCzRWvbGiMlCnhrylMwQFhzJAKYgJKMu4EDIxT6CD1uA4NWtLwJ0U1nZr++ejdrjZFyCtqEuClqnd3PqEHBUXA3EQp9HMGNZBqGESNuNvW6+KM9J8spWD8salDwzZo2oV8QCv1ABAr8bGMvTKCAIoJnqykZ/0pPt1/AlfxO7YdFEyiAgPvib6HQkwI84Rf6WJgzUoDQ5K9uPhPaf3eO1sv7AhABDDdgoBMoYLrHvTMZodCTAvm9Q3FODAoJENuUj2Q7I1WcQemEZIz0PAp1DEtioLn11UDKF5FQV6GtgnNEWU+BlLuNUBirhEIJEgolSCiUIKFQgoRCCTomCq9GrOpY9HrMqkQikUgkEolEIpFIJOroHxA0Ou5lMYdmAAAAAElFTkSuQmCC" alt="HTTP1.1continue1"></p><p><img src="https://javaguide.cn/assets/HTTP1.1continue2.7d63532b.png" alt="HTTP1.1continue2"></p><p>然而在HTTP/1.0中，并没有<code>100 (Continue)</code>状态码，要想触发这一机制，可以发送一个<code>Expect</code>头部，其中包含一个<code>100-continue</code>的值</p><h1 id="四、TCP三次握手与四次握手"><a href="#四、TCP三次握手与四次握手" class="headerlink" title="四、TCP三次握手与四次握手"></a>四、TCP三次握手与四次握手</h1><p><strong>简单示意图：</strong></p><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215756378.png" alt="三次握手"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h2 id="4-1、为什么要三次握手"><a href="#4-1、为什么要三次握手" class="headerlink" title="4.1、为什么要三次握手"></a>4.1、为什么要三次握手</h2><p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双方收发功能都正常，缺一不可。</p><h2 id="4-2、第-2-次握手传回了-ACK，为什么还要传回"><a href="#4-2、第-2-次握手传回了-ACK，为什么还要传回" class="headerlink" title="4.2、第 2 次握手传回了 ACK，为什么还要传回"></a>4.2、第 2 次握手传回了 ACK，为什么还要传回</h2><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p><h2 id="4-3、为什么要四次握手？"><a href="#4-3、为什么要四次握手？" class="headerlink" title="4.3、为什么要四次握手？"></a>4.3、为什么要四次握手？</h2><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215807607.png" alt="四次握手"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ul><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2022/07/10/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/07/10/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Interface"><a href="#一、Interface" class="headerlink" title="一、Interface"></a>一、Interface</h1><p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p><p>interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p><ol><li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li><li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li></ol><hr><p><strong>接口与类的区别</strong></p><ol><li>interface 和 class 的区别，好像是废话，主要有：<ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li></ul></li><li>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</li></ol><p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p><h1 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h1><h2 id="2-1、语法格式："><a href="#2-1、语法格式：" class="headerlink" title="2.1、语法格式："></a>2.1、语法格式：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(parameters) -&gt; expression 或<br>(parameters) -&gt;&#123; statements; &#125;<br></code></pre></td></tr></table></figure><ul><li>左侧：指定了Lambda表达式需要的所有参数</li><li>右侧：制定了Lambda体，即Lambda表达式要执行的功能。</li></ul><h2 id="2-2、代替匿名内部类："><a href="#2-2、代替匿名内部类：" class="headerlink" title="2.2、代替匿名内部类："></a>2.2、代替匿名内部类：</h2><p><strong>1.<code>Runnable</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;The runable now is using!&quot;</span>);<br>            &#125;<br>&#125;).start();<br><span class="hljs-comment">//用lambda</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();<br></code></pre></td></tr></table></figure><p><strong>2.<code>Comparator</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; strings = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>Collections.sort(strings, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>    <span class="hljs-keyword">return</span> o1 - o2;&#125;<br>&#125;);<br><br><span class="hljs-comment">//Lambda</span><br>Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);<br><span class="hljs-comment">//分解开</span><br>Comparator&lt;Integer&gt; comperator = (Integer o1, Integer o2) -&gt; o1 - o2;<br>Collections.sort(strings, comperator);<br></code></pre></td></tr></table></figure><p><strong>3.<code>Listener</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>();<br>button.addItemListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">itemStateChanged</span><span class="hljs-params">(ItemEvent e)</span> &#123;<br>   e.getItem();<br>&#125;<br>&#125;);<br><span class="hljs-comment">//lambda</span><br>button.addItemListener(e -&gt; e.getItem());<br></code></pre></td></tr></table></figure><h2 id="2-3、方法的引用"><a href="#2-3、方法的引用" class="headerlink" title="2.3、方法的引用"></a>2.3、方法的引用</h2><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><p>目标引用放在 <code>::</code> 之前，目标引用提供的方法名称放在 <code>::</code> 之后，即 <code>目标引用::方法</code>。</p><h1 id="三、Stream"><a href="#三、Stream" class="headerlink" title="三、Stream"></a>三、Stream</h1><h2 id="3-1、Stream操作分类"><a href="#3-1、Stream操作分类" class="headerlink" title="3.1、Stream操作分类"></a>3.1、Stream操作分类</h2><p>**<code>主要是对集合的操作，</code>**它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</p><p>Stream的操作可以分为两大类：中间操作、终结操作</p><p>中间操作可分为：</p><p>无状态（Stateless）操作：指元素的处理不受之前元素的影响<br>有状态（Stateful）操作：指该操作只有拿到所有元素之后才能继续下去<br>终结操作可分为：</p><p>短路（Short-circuiting）操作：指遇到某些符合条件的元素就可以得到最终结果<br>非短路（Unshort-circuiting）操作：指必须处理完所有元素才能得到最终结果</p><p><img src="https://img-blog.csdnimg.cn/20201218181011714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5MzM5NDUyNjg5,size_16,color_FFFFFF,t_70" alt="Stream操作分类"></p><p><strong><code>Stream操作的三个步骤：</code></strong></p><p>1）创建Stream：一个数据源（如：集合数组），获取一个流，Stream的实例化</p><p>2）中间操作：一个中间操作链，对数据源的数据进行处理（如：过滤、映射等）</p><p>3）终止操作（终端操作）：一旦执行终止操作，就执行中间操作链，并产生结果。之后，就不会再被使用。<br><img src="https://img-blog.csdnimg.cn/20211011115043745.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pil5rC054WO6Iy2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h2 id="3-2、Stream常用方法的实战"><a href="#3-2、Stream常用方法的实战" class="headerlink" title="3.2、Stream常用方法的实战"></a>3.2、Stream常用方法的实战</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stream8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;gkh&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">// 返回abc</span><br>        Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="hljs-string">&quot;abc&quot;</span>.equals(s));<br>        <span class="hljs-comment">// 计算符合条件的流的数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringStream.count();<br>        System.out.println(count); <span class="hljs-comment">// 2</span><br><br>        <span class="hljs-comment">// 遍历strings</span><br>        strings.stream().forEach(System.out::println);<br><br>        <span class="hljs-comment">// limit 获取第一个元素的stream</span><br>        Stream&lt;String&gt; limit = strings.stream().limit(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// toArray 想看流里面有什么的时候就可以转换成String[]</span><br>        String[] array = limit.toArray(String[]::<span class="hljs-keyword">new</span>);<br><br>        <span class="hljs-comment">// map 对每一个元素进行操作返回新流</span><br>        Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="hljs-string">&quot;22&quot;</span>);<br>        map.forEach(System.out::println);<br><br>        <span class="hljs-comment">// sorted 排序并打印</span><br>        strings.stream().sorted().forEach(System.out::println);<br><br>        <span class="hljs-comment">// Collectors collect 把abc放入到容器中</span><br>        List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="hljs-string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());<br>        <span class="hljs-comment">// 把list转换为String，之间用，隔开</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">mergedString</span> <span class="hljs-operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>        System.out.println(mergedString); <span class="hljs-comment">// abc,def,gkh,abc</span><br><br>        <span class="hljs-comment">// 对数组进行统计</span><br>        List&lt;Integer&gt; number = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>);<br>        number.forEach(System.out::println);<br><br>        <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">statistics</span> <span class="hljs-operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();<br>        System.out.println(<span class="hljs-string">&quot;列表中的最大值：&quot;</span> + statistics.getMax());<br>        System.out.println(<span class="hljs-string">&quot;列表中的最小值：&quot;</span> + statistics.getMin());<br>        System.out.println(<span class="hljs-string">&quot;列表的平均数：&quot;</span> + statistics.getAverage());<br>        System.out.println(<span class="hljs-string">&quot;列表中的所有数之和：&quot;</span> + statistics.getSum());<br><br>        <span class="hljs-comment">// concat合并</span><br>        <span class="hljs-comment">// Arrays.asList(&quot;xyz&quot;, &quot;jqx&quot;) 是一个不可变的 不能使用add等一系列对list的增删改查</span><br>        List&lt;String&gt; strings2 = Arrays.asList(<span class="hljs-string">&quot;xyz&quot;</span>, <span class="hljs-string">&quot;jqx&quot;</span>);<br>        Stream.concat(strings2.stream(),strings.stream()).count();<br><br>        <span class="hljs-comment">// 注意 一个stream是能操作一次，不能断开</span><br>        <span class="hljs-type">Stream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> strings.stream();<br>        <span class="hljs-comment">// 第一次使用</span><br>        stream.limit(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 第二次使用</span><br>        stream.forEach(System.out::println);<br>        <span class="hljs-comment">// 报错：java.lang.IllegalStateException: stream has already been operated upon or closed</span><br>        <br>        <span class="hljs-comment">// 如果要一个stream完成两个操作的话 可以使用.拼接起来</span><br>        stream.limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3、小结"><a href="#3-3、小结" class="headerlink" title="3.3、小结"></a>3.3、小结</h2><p>从源码和实例中我们可以总结出一些 stream 的特点</p><ol><li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li><li>方法参数都是函数式接口类型</li><li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li><li>Stream 不保存数据，不改变数据源</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/07/08/JVM-1/"/>
    <url>/2022/07/08/JVM-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/08/JVM-1/image-20220716215746191.png"></p><h1 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h1><h2 id="1-1、运行时数据区"><a href="#1-1、运行时数据区" class="headerlink" title="1.1、运行时数据区"></a>1.1、运行时数据区</h2><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="1-1-1、程序计数器"><a href="#1-1-1、程序计数器" class="headerlink" title="1.1.1、程序计数器"></a>1.1.1、程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p><img src="/2022/07/08/JVM-1/image-20220604110733931.png"></p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><img src="/2022/07/08/JVM-1/image-20220604143627082.png" alt="pc寄存器的使用场景"></p><h3 id="1-1-2、Java虚拟机栈"><a href="#1-1-2、Java虚拟机栈" class="headerlink" title="1.1.2、Java虚拟机栈"></a>1.1.2、Java虚拟机栈</h3><p>虚拟机栈<strong>是线程私有的</strong>，<code>生命周期与线程一样</code>，随着线程的存在而存在，随着线程的消亡而消亡。</p><p>除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><p><img src="/2022/07/08/JVM-1/image-20220724220028947.png" alt="栈"></p><p><img src="/2022/07/08/JVM-1/image-20220606093338725.png" alt="栈帧的基本结构"></p><p><strong>局部变量表：</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>操作数栈：</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接(指向运行时常量池的方法引用)：</strong> 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p><p><img src="/2022/07/08/JVM-1/image-20220724220055120.png"></p><p><strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><h3 id="1-1-3、本地方法栈"><a href="#1-1-3、本地方法栈" class="headerlink" title="1.1.3、本地方法栈"></a>1.1.3、本地方法栈</h3><p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p><h3 id="1-1-4、堆"><a href="#1-1-4、堆" class="headerlink" title="1.1.4、堆"></a>1.1.4、堆</h3><p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆</strong>；Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p><strong>堆空间的细分</strong></p><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</p><ul><li>Java7及之前堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>永久区</strong><ul><li>新生区又被分为eden(伊甸)区和Survivor(幸存者)区 幸存者区又分为幸存者1区(from区)和幸存者2区(to区)</li></ul></li><li>Java8及之后堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>元空间</strong></li><li>新生区&lt;=&gt;新生代&lt;=&gt;年轻代 养老区&lt;=&gt;老年区&lt;=&gt;老年代 永久区&lt;=&gt;永久代</li><li>堆大小=新生区+养老区，元空间或者永久区有他自己的大小</li><li><strong>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。</strong></li></ul><p><img src="/2022/07/08/JVM-1/image-20220830133642134.png" alt="image-20220830133642134"></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><hr><p><strong>为什么要建立两个Survivor区？</strong><br>建立两个Survivor区，分别是S0和S1（From和To），MinorGC流程如下：</p><p>把new的对象放在Eden区中，一旦Eden满了，触发一次Minor GC，Eden区中存活的对象会送到S0中，Eden被清空；再次new对象放入Eden区中，Eden又满了，触发Minor GC，Eden和S0中存活的对象放入到S1中，然后S0和Eden清空，然后S0和S1交换角色，S1变成了S0，作为下一次GC的主要目标，S0变成了S1，存放下一次GC存活的对象。<br>如此循环往复，对象头的分代年龄达到16次，则会被送到老年代中。</p><p>官方推荐新生代占java堆的3/8，幸存代(S区)占新生代的1/10</p><h3 id="1-1-5、方法区"><a href="#1-1-5、方法区" class="headerlink" title="1.1.5、方法区"></a>1.1.5、方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，<u>是各个线程共享的内存区域。</u>他的实际的物理内存空间可以是<u>不连续的</u>。关闭JVM就会释放这个区域的内存</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src="/2022/07/08/JVM-1/image-20220830133707663.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>元空间不在虚拟机设置的内存中，而是使用本地内存。永久代因为使用的是虚拟机设置的内存，所以会出现OOM，但是将永久代替换为原空间以后就没有这个问题。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:PermSize=N <span class="hljs-comment">//方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的初始（和最小大小）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></p><h3 id="1-1-6、运行时常量池"><a href="#1-1-6、运行时常量池" class="headerlink" title="1.1.6、运行时常量池"></a>1.1.6、运行时常量池</h3><p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 <code>将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)</code>。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。<br><strong>方法区的Class文件信息，Class常量池和运行时常量池的三者关系</strong></p><p><img src="/2022/07/08/JVM-1/image-20220708232527703.png"></p><h3 id="1-1-7、字符串常量池"><a href="#1-1-7、字符串常量池" class="headerlink" title="1.1.7、字符串常量池"></a>1.1.7、字符串常量池</h3><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是字符串常量池。<strong>字符串常量池由String类私有的维护</strong>。</p><p>DK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><img src="/2022/07/08/JVM-1/image-20220830133841991.png" alt="image-20220830133841991"></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h3 id="1-1-8、直接内存"><a href="#1-1-8、直接内存" class="headerlink" title="1.1.8、直接内存"></a>1.1.8、直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。</p><p>通常，访问直接内存的速度会优于Java堆，即读写性能高。</p><h2 id="1-2、HotSpot-虚拟机对象探秘"><a href="#1-2、HotSpot-虚拟机对象探秘" class="headerlink" title="1.2、HotSpot 虚拟机对象探秘"></a>1.2、HotSpot 虚拟机对象探秘</h2><h3 id="1-2-1、对象的创建过程"><a href="#1-2-1、对象的创建过程" class="headerlink" title="1.2.1、对象的创建过程"></a>1.2.1、对象的创建过程</h3><p><img src="https://img-blog.csdnimg.cn/07d02dbb0e3546b6a720b0d277a03889.png" alt="对象的创建过程"></p><h4 id="Step1：类加载检查"><a href="#Step1：类加载检查" class="headerlink" title="Step1：类加载检查"></a>Step1：类加载检查</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace（元空间）的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2：分配内存"><a href="#Step2：分配内存" class="headerlink" title="Step2：分配内存"></a>Step2：分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p><p><strong>如果内存规整</strong>：虚拟机将采用的是<code>指针碰撞法（Bump The Point）</code>来为对象分配内存。</p><ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul><p><strong>如果内存不规整：</strong>虚拟机需要维护一个<code>空闲列表（Free List）</code>来为对象分配内存。</p><ul><li>虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul><p><strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong><code>内存分配并发问题（补充内容，需要掌握）</code></strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。通过设置 <code>-XX:+UseTLAB</code>参数来设定</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法进行初始化"><a href="#Step5-执行-init-方法进行初始化" class="headerlink" title="Step5:执行 init 方法进行初始化"></a>Step5:执行 init 方法进行初始化</h4><p>从 Java 程序的视角来看，对象创建才刚开始，<code>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="1-2-2、对象的内存布局"><a href="#1-2-2、对象的内存布局" class="headerlink" title="1.2.2、对象的内存布局"></a>1.2.2、对象的内存布局</h3><p><img src="https://img-blog.csdnimg.cn/a97a450c6432470f94dd97bd4c3d4dac.png" alt="对象的内存布局"></p><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></p><h3 id="1-2-3对象的访问定位"><a href="#1-2-3对象的访问定位" class="headerlink" title="1.2.3对象的访问定位"></a>1.2.3对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</p><p><img src="/2022/07/08/JVM-1/image-20220830133916058.png" alt="对象的访问定位-使用句柄"></p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 <strong>reference 中存储的直接就是对象的地址。</strong></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。</p><p><img src="/2022/07/08/JVM-1/image-20220830133936189.png" alt="对象的访问定位-直接指针"></p><h1 id="二、JVM垃圾回收"><a href="#二、JVM垃圾回收" class="headerlink" title="二、JVM垃圾回收"></a>二、JVM垃圾回收</h1><h2 id="2-1、-JVM-内存分配与回收"><a href="#2-1、-JVM-内存分配与回收" class="headerlink" title="2.1、 JVM 内存分配与回收"></a>2.1、 JVM 内存分配与回收</h2><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆</strong>。 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="/2022/07/08/JVM-1/image-20220724220119040.png"></p><p>Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><h3 id="2-1-1、对象优先在Eden区分配"><a href="#2-1-1、对象优先在Eden区分配" class="headerlink" title="2.1.1、对象优先在Eden区分配"></a>2.1.1、对象优先在Eden区分配</h3><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><h3 id="2-1-2、大对象直接进入老年代"><a href="#2-1-2、大对象直接进入老年代" class="headerlink" title="2.1.2、大对象直接进入老年代"></a>2.1.2、大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="2-1-3、长期存活的对象将进入老年代"><a href="#2-1-3、长期存活的对象将进入老年代" class="headerlink" title="2.1.3、长期存活的对象将进入老年代"></a>2.1.3、长期存活的对象将进入老年代</h3><p>对象通常在Eden区里诞生，如果经过第一次Minor GC还存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄加+1，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。</p><h3 id="2-1-4、动态对象年龄判定"><a href="#2-1-4、动态对象年龄判定" class="headerlink" title="2.1.4、动态对象年龄判定"></a>2.1.4、动态对象年龄判定</h3><p>HopStop虚拟机并不是永远要求对象的年龄必须达到<code>-XX：MaxTenuringThreshold</code>才能晋升老年代，如果在<strong>survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半</strong>，年龄大于等于该年龄的对象就可以直接进入老年代。无需等到MaxTenuringThreshold中要求的年龄。</p><h3 id="2-1-5、空间分配担保"><a href="#2-1-5、空间分配担保" class="headerlink" title="2.1.5、空间分配担保"></a>2.1.5、空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><hr><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区</p><h2 id="2-2、判断对象是否已经死亡"><a href="#2-2、判断对象是否已经死亡" class="headerlink" title="2.2、判断对象是否已经死亡"></a>2.2、判断对象是否已经死亡</h2><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><h3 id="2-2-1、引用计数法"><a href="#2-2-1、引用计数法" class="headerlink" title="2.2.1、引用计数法"></a>2.2.1、引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><hr><p><strong>循环引用：</strong></p><p><img src="https://img-blog.csdnimg.cn/ef82e7291ec74d78aeea2fe36232c765.png" alt="循环引用"></p><h3 id="2-2-2、可达性分析算法"><a href="#2-2-2、可达性分析算法" class="headerlink" title="2.2.2、可达性分析算法"></a>2.2.2、可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p><p><img src="/2022/07/08/JVM-1/image-20220830134012328.png" alt="可达性分析算法"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="2-2-3、引用"><a href="#2-2-3、引用" class="headerlink" title="2.2.3、引用"></a>2.2.3、引用</h3><p>引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>如果一个对象有强引用，那么就相当于是生活中<strong>必不可少的生活用品</strong>，哪怕内存空间不足，jvm哪怕抛出异常也不愿意随意回收具有强引用的对象</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象有软引用，那么就相当于是生活中<strong>可有可无的生活用品</strong>，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收。</strong></p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用<strong>必须</strong>和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-2-4、如何判断一个常量是废弃常量？"><a href="#2-2-4、如何判断一个常量是废弃常量？" class="headerlink" title="2.2.4、如何判断一个常量是废弃常量？"></a>2.2.4、如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="2-2-5、如何判断一个类是无用的类？"><a href="#2-2-5、如何判断一个类是无用的类？" class="headerlink" title="2.2.5、如何判断一个类是无用的类？"></a>2.2.5、如何判断一个类是无用的类？</h3><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的<strong>仅仅是“可以”</strong>，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="2-3、垃圾收集算法"><a href="#2-3、垃圾收集算法" class="headerlink" title="2.3、垃圾收集算法"></a>2.3、垃圾收集算法</h2><h3 id="2-3-1、标记-清除算法"><a href="#2-3-1、标记-清除算法" class="headerlink" title="2.3.1、标记-清除算法"></a>2.3.1、标记-清除算法</h3><p>分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。<strong>它是最基础的收集算法。</strong></p><p>但是会有<strong>两个问题</strong>：</p><p>1、效率问题</p><p>2、空间问题（标记清除后，会产生大量不连续的碎片）</p><p><img src="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg" alt="标记-清除算法"></p><h3 id="2-3-2、标记-复制算法"><a href="#2-3-2、标记-复制算法" class="headerlink" title="2.3.2、标记-复制算法"></a>2.3.2、标记-复制算法</h3><p>可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://javaguide.cn/assets/90984624.e8c186ae.png" alt="标记-复制算法"></p><h3 id="2-3-3、标记-整理算法"><a href="#2-3-3、标记-整理算法" class="headerlink" title="2.3.3、标记-整理算法"></a>2.3.3、标记-整理算法</h3><p>标记过程与标记-清除算法一样，但是后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://javaguide.cn/assets/94057049.22c58294.png" alt="标记-整理算法 "></p><h3 id="2-3-4、分代收集算法"><a href="#2-3-4、分代收集算法" class="headerlink" title="2.3.4、分代收集算法"></a>2.3.4、分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h2 id="2-4、垃圾回收器"><a href="#2-4、垃圾回收器" class="headerlink" title="2.4、垃圾回收器"></a>2.4、垃圾回收器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p><img src="/2022/07/08/JVM-1/image-20220724220136406.png"></p><h3 id="2-4-1、Serial-收集器（串行回收）"><a href="#2-4-1、Serial-收集器（串行回收）" class="headerlink" title="2.4.1、Serial 收集器（串行回收）"></a>2.4.1、Serial 收集器（串行回收）</h3><p>串行收集器是一个<strong>单线程</strong>收集器，不仅仅意味着他只会使用一个垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://javaguide.cn/assets/46873026.3a9311ec.png" alt=" Serial 收集器 "></p><p>但是 它<strong>简单而高效</strong></p><h3 id="2-4-2、ParNew-收集器（并行回收）"><a href="#2-4-2、ParNew-收集器（并行回收）" class="headerlink" title="2.4.2、ParNew 收集器（并行回收）"></a>2.4.2、ParNew 收集器（并行回收）</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="ParNew 收集器 "></p><p><strong><code>首要选择</code></strong></p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="2-4-3、Parallel-Scavenge-收集器（吞吐量优先的并行回收）"><a href="#2-4-3、Parallel-Scavenge-收集器（吞吐量优先的并行回收）" class="headerlink" title="2.4.3、Parallel Scavenge 收集器（吞吐量优先的并行回收）"></a>2.4.3、Parallel Scavenge 收集器（吞吐量优先的并行回收）</h3><p>标记-复制算法的多线程收集器，相比于ParNew收集器，他的关注点在 <strong>吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong></p><p>吞吐量表示在单位时间内通过某个网络或接口的数据量 ，包括全部上传和下载的流量。</p><p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="Parallel Scavenge 收集器 "></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p>JDK1.8默认使用的是 Parallel Scavenge + Parallel Old</p><h3 id="2-4-4、Serial-Old-收集器"><a href="#2-4-4、Serial-Old-收集器" class="headerlink" title="2.4.4、Serial Old 收集器"></a>2.4.4、Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="2-4-5、Parallel-Old-收集器"><a href="#2-4-5、Parallel-Old-收集器" class="headerlink" title="2.4.5、Parallel Old 收集器"></a>2.4.5、Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="2-4-6、CMS-收集器（低停顿时间）"><a href="#2-4-6、CMS-收集器（低停顿时间）" class="headerlink" title="2.4.6、CMS 收集器（低停顿时间）"></a>2.4.6、CMS 收集器（低停顿时间）</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。是一种基于标记-清楚算法实现的</strong></p><p>运转过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫</li></ul><p><img src="https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png" alt="CMS 垃圾收集器 "></p><p>主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="2-4-7、G1-收集器（区域化分代式）"><a href="#2-4-7、G1-收集器（区域化分代式）" class="headerlink" title="2.4.7、G1 收集器（区域化分代式）"></a>2.4.7、G1 收集器（区域化分代式）</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率<code>满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征</code>.</strong></p><p>侧重点在于<strong>回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）</strong></p><div class="note note-success">            <p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。Region中还有一类特殊的Humongous区域，专门用来存储大对象（只要超过了一个Region容量一半的对象）。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region 之中，G1的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待</p>          </div><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200730161610159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMjI4MTI4NDk=,size_16,color_FFFFFF,t_70" alt="G1运行过程"></p><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记：</strong>需要停顿线程，但是耗时很短，</li><li><strong>并发标记：</strong>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="2-4-8、ZGC-收集器"><a href="#2-4-8、ZGC-收集器" class="headerlink" title="2.4.8、ZGC 收集器"></a>2.4.8、ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><h1 id="三、类加载过程"><a href="#三、类加载过程" class="headerlink" title="三、类加载过程"></a>三、类加载过程</h1><h2 id="3-1、类的生命周期"><a href="#3-1、类的生命周期" class="headerlink" title="3.1、类的生命周期"></a>3.1、类的生命周期</h2><p><img src="/2022/07/08/JVM-1/image-20220717120404351.png" alt="类的生命周期"></p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690785011/2F1143CD0902210BA8783DBC8CB76D0A" alt="类加载过程"></p><h2 id="3-2、类加载过程"><a href="#3-2、类加载过程" class="headerlink" title="3.2、类加载过程"></a>3.2、类加载过程</h2><p>加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="/2022/07/08/JVM-1/image-20220724220201809.png" alt="加载Class文件的过程"></p><h3 id="3-2-1、加载"><a href="#3-2-1、加载" class="headerlink" title="3.2.1、加载"></a>3.2.1、加载</h3><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象，作为方法区这些数据的访问入口</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：第一点比较常见的就是从 <code>ZIP</code> 包中读取（日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础）、其他文件生成（典型应用就是 <code>JSP</code>）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了</p><h3 id="3-2-2、验证"><a href="#3-2-2、验证" class="headerlink" title="3.2.2、验证"></a>3.2.2、验证</h3><p>验证（Verify）：</p><ul><li>目的在子确保Class文件的字节流文件包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害到虚拟机自身安全。</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul><p><img src="/2022/07/08/JVM-1/image-20220724220221738.png" alt="验证阶段示意图"></p><h3 id="3-2-3、准备"><a href="#3-2-3、准备" class="headerlink" title="3.2.3、准备"></a>3.2.3、准备</h3><ul><li>准备（Prepare）：<ul><li>为类变量分配内存并设置该变量的默认初始值，即零值。例如：int类型为0。</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li></ul></li></ul><h3 id="3-2-4、解析"><a href="#3-2-4、解析" class="headerlink" title="3.2.4、解析"></a>3.2.4、解析</h3><ul><li>解析（Resolve）：<ul><li>将常量池内的符号引用转换为直接引用的过程，一般在初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="3-2-5、初始化"><a href="#3-2-5、初始化" class="headerlink" title="3.2.5、初始化"></a>3.2.5、初始化</h3><ul><li><strong>初始化阶段就是执行类构造方法<code>&lt;client&gt;()</code>的过程</strong></li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量(静态变量)的赋值动作和静态代码块中的语句合并而来的。（如果没有静态变量赋值动作或静态代码就没有<code>&lt;client&gt;()</code>方法） <strong>必须要有静态变量赋值动作或者静态代码块</strong></li><li>构造器方法中指令按照语句<strong>在源文件中出现的顺序</strong>执行。</li><li><strong><code>&lt;client&gt;()</code>不同于类的构造器。</strong>（关联：构造器是虚拟机视角下的<code>&lt;client&gt;()</code>）</li><li>若该类有父类，JVM会保证子类的<code>&lt;client&gt;()</code>执行前，父类的<code>&lt;client&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;client&gt;()</code>方法在多线程下被同步加锁。一个类只会被加载一次</li></ul><p><img src="http://www.eliseo.top/2022/05/08/JVM/image-20220511215809705.png"></p><h2 id="3-3、卸载"><a href="#3-3、卸载" class="headerlink" title="3.3、卸载"></a>3.3、卸载</h2><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在 JVM 生命周期内，由 <strong>jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</strong></p><h1 id="四、类加载器详解"><a href="#四、类加载器详解" class="headerlink" title="四、类加载器详解"></a>四、类加载器详解</h1><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><h2 id="4-1、双亲委派机制"><a href="#4-1、双亲委派机制" class="headerlink" title="4.1、双亲委派机制"></a>4.1、双亲委派机制</h2><p>即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。<strong>通俗点说：就是先查看类是否已经被加载过，如果被加载过那么久直接返回，否则九一直询问父类是否加载，如果所有父类都没有加载过，那么就自己加载。</strong></p><p><img src="/2022/07/08/JVM-1/image-20220724220251452.png" alt="ClassLoader"></p><p><strong>双亲委派模型的好处</strong></p><p>双亲委派模型保证了 Java 程序的稳定运行，<strong>可以避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），<strong>也保证了 Java 的核心 API 不被篡改</strong>。</p><hr><p>Java文件的运行过程</p><ol><li>Java文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><p>只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找</p><h1 id="JVM的常用参数"><a href="#JVM的常用参数" class="headerlink" title="JVM的常用参数"></a>JVM的常用参数</h1><p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or later)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java集合</title>
    <link href="/2022/07/07/java%E9%9B%86%E5%90%88/"/>
    <url>/2022/07/07/java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>线程安全的集合：vector，hashtable，剩下的集合都不安全</p><h1 id="说说-List-Set-Queue-Map-四者的区别？"><a href="#说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="说说 List, Set, Queue, Map 四者的区别？"></a>说说 List, Set, Queue, Map 四者的区别？</h1><p><code>list:</code>有序的可重复的，一般对付排序的问题</p><p><code>set:</code>(注重独一无二的性质): 无序的、不可重复的。</p><p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树</li></ul><h1 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h1><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><p>这些接口拥有众多的实现类，其中最常用的实现类有HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。</p><h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>在传入（add）第一个参数的时候，源码中会调用<code>ensureCapacityInternal()</code>方法，当传入的参数&lt;10的时候，<code>ensureCapacityInternal()</code>方法会默认ArrayList的大小为10；</p><p>当传入的参数大于10个之后，会进入<code>grow()</code>方法，进行扩容</p><h1 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h1><p><strong>使用场景：</strong></p><p><code>comparable接口</code>一般用在实体类，实体类实现这个接口，然后可以通过重写<code>compareTo方法</code>，对实体类的<code>Integer</code>类型的参数进行比较。</p><p><code>Comparator接口</code>在实体类被实现，用于自定义比较一些非 <code>Integer</code>类型的参数进行比较，用于自定义比较。也可以用在方法中 使用一个自定义比较器实现自定义比较。</p><h1 id="Queue-与-Deque"><a href="#Queue-与-Deque" class="headerlink" title="Queue 与 Deque"></a>Queue 与 Deque</h1><p>Queue是单端队列，从一端插入，从另一端删除，遵循**先进先出(FIFO)**原则。</p><p><img src="/2022/07/07/java%E9%9B%86%E5%90%88/image-20220707212625845.png"></p><p>Deque是双端队列，队列两端均可以插入与删除。</p><p><img src="/2022/07/07/java%E9%9B%86%E5%90%88/image-20220707212700993.png"></p><p>实际上还有 <code>push()</code>方法与<code>pop()</code>方法，用于模拟栈</p><h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><p><code>hashMap</code>可以存储null的k-v，但是作为k只能有一个null，value则是可以存在多个null，</p><p><code>TreeMap</code>自己本身默认是按照key的升序进行排列的，但是也可以自定义比较器</p><p><strong>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h1 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h1><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h1 id="hashCode-与-equals-的相关规定："><a href="#hashCode-与-equals-的相关规定：" class="headerlink" title="hashCode()与 equals() 的相关规定："></a><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</h1><ol><li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li><li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li><li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li><li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li><li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><h1 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="==与 equals 的区别"></a>==与 equals 的区别</h1><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方)；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、使用线程池的好处："><a href="#一、使用线程池的好处：" class="headerlink" title="一、使用线程池的好处："></a>一、使用线程池的好处：</h1><p>1、降低资源消耗</p><p>2、提高响应速度</p><p>3、提高线程的客观理性</p><h1 id="二、Executor框架"><a href="#二、Executor框架" class="headerlink" title="二、Executor框架"></a>二、Executor框架</h1><h2 id="2-1、Executor-框架结构"><a href="#2-1、Executor-框架结构" class="headerlink" title="2.1、Executor 框架结构"></a>2.1、Executor 框架结构</h2><h3 id="1、任务-Runnable-callable"><a href="#1、任务-Runnable-callable" class="headerlink" title="1、任务(Runnable/callable)"></a>1、任务(Runnable/callable)</h3><h3 id="2、任务的执行-Executor"><a href="#2、任务的执行-Executor" class="headerlink" title="2、任务的执行(Executor)"></a>2、任务的执行(Executor)</h3><p><strong>需要更多关注的是 <code>ThreadPoolExecutor</code>这个类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractExecutorService实现了ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ScheduledExecutorService继承ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScheduledExecutorService</span><br></code></pre></td></tr></table></figure><h3 id="3、异步计算的结果-Future"><a href="#3、异步计算的结果-Future" class="headerlink" title="3、异步计算的结果(Future)"></a>3、异步计算的结果(Future)</h3><p>将<code>runnable</code>与<code>callable</code>接口的实现类提交给<code>ThreadPoolExecutor</code> 执行，使用<code>submit()</code>方法会得到一个返回值</p><h2 id="2-2、执行流程"><a href="#2-2、执行流程" class="headerlink" title="2.2、执行流程"></a>2.2、执行流程</h2><p><img src="https://javaguide.cn/assets/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.36e59afa.png" alt="Executor 框架的使用示意图"></p><ol><li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li><li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable  task）</code>）。</li><li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li></ol><h1 id="三、ThreadPoolExecutor-类的简单介绍-重点"><a href="#三、ThreadPoolExecutor-类的简单介绍-重点" class="headerlink" title="三、ThreadPoolExecutor 类的简单介绍(重点)"></a>三、ThreadPoolExecutor 类的简单介绍<code>(重点)</code></h1><h2 id="1、类分析"><a href="#1、类分析" class="headerlink" title="1、类分析"></a>1、类分析</h2><p>ThreadPoolExecutor类 一共提供了四个构造方法</p><p>最长的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>其他的常见参数：</strong></p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程会一直等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ol><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220707162623783.png" alt="线程池中各个参数的关系"></p><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略：</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 此策略将丢弃最早的未处理的任务请求。</li></ul><p>当不指定<code>RejectedExecutionHandler</code>饱和策略的时候默认使用<code>ThreadPoolExecutor.AbortPolicy</code></p><h2 id="3-2、推荐使用ThreadPoolExecutor-创建线程池"><a href="#3-2、推荐使用ThreadPoolExecutor-创建线程池" class="headerlink" title="3.2、推荐使用ThreadPoolExecutor 创建线程池"></a>3.2、推荐使用<code>ThreadPoolExecutor</code> 创建线程池</h2><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</p><p><strong>使用<code>Executors</code> 创建线程池的弊端：</strong></p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li></ul><h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a><strong>创建方式：</strong></h3><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数实现（推荐）</strong><img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.d54a5992.png" alt="通过构造方法实现"></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</strong> 我们可以创建三种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li><code>FixedThreadPool</code></li><li><code>SingleThreadExecutor</code></li><li>CachedThreadPool</li></ul><p>对应 Executors 工具类中的方法如图所示：</p><p><img src="https://javaguide.cn/assets/Executors%E5%B7%A5%E5%85%B7%E7%B1%BB.4b0cbd16.png" alt="通过Executor 框架的工具类Executors来实现"></p><h1 id="四、ThreadPoolExecutor-使用-分析"><a href="#四、ThreadPoolExecutor-使用-分析" class="headerlink" title="四、ThreadPoolExecutor 使用+分析"></a>四、ThreadPoolExecutor 使用+分析</h1><h2 id="4-1、线程池原理分析"><a href="#4-1、线程池原理分析" class="headerlink" title="4.1、线程池原理分析"></a>4.1、线程池原理分析</h2><p><strong><code>excute</code>方法(提交一个任务到线程池中去)详解：</strong></p><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220724215903960.png" alt="图解线程池实现原理"></p><p><strong><code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</strong></p><h2 id="4-2、常见对比"><a href="#4-2、常见对比" class="headerlink" title="4.2、常见对比"></a>4.2、常见对比</h2><h3 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h3><p><strong><code>Runnable</code>接口</strong>不会返回结果或抛出异常，但是 <strong><code>Callable</code>接口</strong>可以。</p><h3 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a><code>execute()</code> vs <code>submit()</code></h3><p><code>execute()</code>用于不会提交返回值的任务</p><p><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</p><p>示例1：使用 <code>get() </code>方法获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get();<br>System.out.println(s);<br>executorService.shutdown();<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">abc<br></code></pre></td></tr></table></figure><p>示例2：使用 <code>get（long timeout，TimeUnit unit） </code>方法获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>System.out.println(s);<br>executorService.shutdown();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException<br>at java.util.concurrent.FutureTask.get(FutureTask.java:205)<br></code></pre></td></tr></table></figure><h3 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h1 id="五、几种常见的线程池"><a href="#五、几种常见的线程池" class="headerlink" title="五、几种常见的线程池"></a>五、几种常见的线程池</h1><h2 id="5-1、FixedThreadPool"><a href="#5-1、FixedThreadPool" class="headerlink" title="5.1、FixedThreadPool"></a>5.1、FixedThreadPool</h2><h3 id="5-1-1、简介"><a href="#5-1-1、简介" class="headerlink" title="5.1.1、简介"></a>5.1.1、简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 创建一个可重用固定数量线程的线程池</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                   <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                   threadFactory);<br> &#125;<br></code></pre></td></tr></table></figure><p>1.固定大小的线程池nThreads；<br>2.corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；<br>3.keepAliveTime为0，一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效(由于采用了无界队列)；<br>4.阻塞队列采用了LinkedBlockingQueue，一个无界队列；由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</p><p><strong>被称为 <code>可重用固定线程数</code>的线程池，新创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</strong></p><h3 id="5-1-2、执行任务过程介绍"><a href="#5-1-2、执行任务过程介绍" class="headerlink" title="5.1.2、执行任务过程介绍"></a>5.1.2、执行任务过程介绍</h3><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图</p><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708084630822.png" alt="excute()运行示意图"></p><p><strong>说明：</strong></p><p>1、当前运行数小于corePoolSize的时候，有新的任务时，就会创建新的线程中</p><p>2、当前运行数大于或等于corePoolSize的时候，有新的任务时，就会将任务加到 <code>LinkedBlockingQueue</code></p><p>3、当线程池中的线程结束了手里的任务时，就会去<code>LinkedBlockingQueue</code>中获取任务执行</p><h2 id="5-2、SingleThreadExecutor-会导致OOM"><a href="#5-2、SingleThreadExecutor-会导致OOM" class="headerlink" title="5.2、SingleThreadExecutor(会导致OOM)"></a>5.2、SingleThreadExecutor(会导致OOM)</h2><h3 id="5-2-1、简介"><a href="#5-2-1、简介" class="headerlink" title="5.2.1、简介"></a>5.2.1、简介</h3><p><strong>只有<code>一个线程</code>的线程池。</strong></p><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *返回只有一个线程的线程池</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>         (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                 <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                 threadFactory));<br> &#125;<br></code></pre></td></tr></table></figure><p>将<code>corePoolSize</code>与<code>maximumPoolSize</code>都设置成1，保证只有一个线程能运行，剩下的参数与 <code>FixedThreadPool</code>相同</p><h3 id="5-2-2、执行任务过程介绍"><a href="#5-2-2、执行任务过程介绍" class="headerlink" title="5.2.2、执行任务过程介绍"></a>5.2.2、执行任务过程介绍</h3><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708090951289.png"></p><ol><li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li><li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li><li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行</li></ol><h2 id="5-3、CachedThreadPool-详解"><a href="#5-3、CachedThreadPool-详解" class="headerlink" title="5.3、CachedThreadPool 详解"></a>5.3、CachedThreadPool 详解</h2><h3 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h3><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>将<code>corePoolSize</code>设置成0，<code>maximumPoolSize</code>设置成<code>Integer.MAX.VALUE</code>。如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程，极端情况下，会导致耗尽CPU和内存资源。</p><h3 id="5-3-2、执行任务过程介绍"><a href="#5-3-2、执行任务过程介绍" class="headerlink" title="5.3.2、执行任务过程介绍"></a>5.3.2、执行任务过程介绍</h3><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708091916023.png" alt="execute()执行流程"></p><p>当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</p><h2 id="5-4、线程使用场景"><a href="#5-4、线程使用场景" class="headerlink" title="5.4、线程使用场景"></a>5.4、线程使用场景</h2><p><code>CachedThreadPool</code>：执行很多短期异步的小程序或者负载较轻的服务器 </p><p><code>FixedThreadPool</code>：适合执行长期任务</p><p><code>SingleThreadExecutor</code>：适合一个任务一个任务执行的场景</p><h1 id="六、ScheduledThreadPoolExecutor-了解即可"><a href="#六、ScheduledThreadPoolExecutor-了解即可" class="headerlink" title="六、ScheduledThreadPoolExecutor(了解即可)"></a>六、ScheduledThreadPoolExecutor(了解即可)</h1><h2 id="6-1、简介"><a href="#6-1、简介" class="headerlink" title="6.1、简介"></a>6.1、简介</h2><p><strong>主要用来在给定的延迟后运行任务，或者定期执行任务</strong></p><p>使用的任务队列<code>DelayQueue</code>封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行，如果执行所需时间一样，那么谁先进来的谁先执行</p><h2 id="6-2、运行机制"><a href="#6-2、运行机制" class="headerlink" title="6.2、运行机制"></a>6.2、运行机制</h2><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708094216584.png" alt="image-20220708094216584"></p><ol><li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>scheduleAtFixedRate()</code></strong> 方法或者 <strong><code>scheduleWithFixedDelay()</code></strong> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>DelayQueue</code></strong> 添加一个实现了 <strong><code>RunnableScheduledFuture</code></strong> 接口的 <strong><code>ScheduledFutureTask</code></strong> 。</li><li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li></ol><p><strong>为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code>做了如下修改</strong></p><p>1、将消息队列改为了 <code>DelayQueue</code></p><p>2、获取任务的方不同</p><p>3、执行周期任务后，增加了额外的处理</p><h2 id="6-3、ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#6-3、ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="6.3、ScheduledThreadPoolExecutor 执行周期任务的步骤"></a>6.3、ScheduledThreadPoolExecutor 执行周期任务的步骤</h2><p><img src="https://javaguide.cn/assets/ScheduledThreadPoolExecutor%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E6%AD%A5%E9%AA%A4.5bd57dd0.png" alt="ScheduledThreadPoolExecutor执行周期任务的步骤"></p><ol><li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li><li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li></ol><h1 id="七、线程池大小确定"><a href="#七、线程池大小确定" class="headerlink" title="七、线程池大小确定"></a>七、线程池大小确定</h1><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong></p><p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>N是指CPU的核心数，一般<strong>CPU 密集型任务设置线程池大小为：(N+1)；I/O 密集型任务线程池大小设置为(2N)</strong></p><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h1 id="八、如何使用线程池"><a href="#八、如何使用线程池" class="headerlink" title="八、如何使用线程池"></a>八、如何使用线程池</h1><p>一般是通过 <code>ThreadPoolExecutor</code> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。</p><p><code>ThreadPoolExecutor</code>的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">KEEP_ALIVE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//使用阿里巴巴推荐的创建线程池的方式</span><br>        <span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_TIME,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;CurrentThread name:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;date：&quot;</span> + Instant.now());<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//终止线程池</span><br>        executor.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Finished all threads&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="九、线程池的注意事项"><a href="#九、线程池的注意事项" class="headerlink" title="九、线程池的注意事项"></a>九、线程池的注意事项</h1><h2 id="9-1、使用-ThreadPoolExecutor-的构造函数声明线程池"><a href="#9-1、使用-ThreadPoolExecutor-的构造函数声明线程池" class="headerlink" title="9.1、使用 ThreadPoolExecutor 的构造函数声明线程池"></a>9.1、使用 <code>ThreadPoolExecutor </code>的构造函数声明线程池</h2><p><strong>线程池必须手动通过 <code>ThreadPoolExecutor </code>的构造函数来声明，避免使用<code>Executors </code>类的 <code>newFixedThreadPool</code> 和 <code>newCachedThreadPool</code> ，因为可能会有 OOM 的风险。</strong>就是<strong>使用有界队列，控制线程创建数量。</strong></p><h2 id="9-2、监测线程池运行状态"><a href="#9-2、监测线程池运行状态" class="headerlink" title="9.2、监测线程池运行状态"></a>9.2、监测线程池运行状态</h2><p>使用SpringBoot 中的 Actuator 组件</p><p>每一秒打印一次线程状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 打印线程池的状态</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> threadPool 线程池对象</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printThreadPoolStatus</span><span class="hljs-params">(ThreadPoolExecutor threadPool)</span> &#123;<br>       <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, createThreadFactory(<span class="hljs-string">&quot;print-images/thread-pool-status&quot;</span>, <span class="hljs-literal">false</span>));<br>       scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;<br>           log.info(<span class="hljs-string">&quot;=========================&quot;</span>);<br>           log.info(<span class="hljs-string">&quot;ThreadPool Size: [&#123;&#125;]&quot;</span>, threadPool.getPoolSize());<br>           log.info(<span class="hljs-string">&quot;Active Threads: &#123;&#125;&quot;</span>, threadPool.getActiveCount());<br>           log.info(<span class="hljs-string">&quot;Number of Tasks : &#123;&#125;&quot;</span>, threadPool.getCompletedTaskCount());<br>           log.info(<span class="hljs-string">&quot;Number of Tasks in Queue: &#123;&#125;&quot;</span>, threadPool.getQueue().size());<br>           log.info(<span class="hljs-string">&quot;=========================&quot;</span>);<br>       &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="9-3、不同类别的业务使用不同的线程池"><a href="#9-3、不同类别的业务使用不同的线程池" class="headerlink" title="9.3、不同类别的业务使用不同的线程池"></a>9.3、不同类别的业务使用不同的线程池</h2><p>一个项目中有多个不同的业务，建议每一个业务都使用各自的线程池</p><p>如果多个业务使用一个线程池，那么可能会造成<code>死锁</code></p><p>假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 **”死锁”**。</p><p><img src="https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81.8ea83cdb.png" alt="线程池使用不当导致死锁"></p><h2 id="9-4、初始化线程池的时候别忘了给线程池命名"><a href="#9-4、初始化线程池的时候别忘了给线程池命名" class="headerlink" title="9.4、初始化线程池的时候别忘了给线程池命名"></a>9.4、初始化线程池的时候别忘了给线程池命名</h2><p><strong>好处：</strong>有助于定位问题。</p><h3 id="9-4-1、给线程池命名一般使用两种方法："><a href="#9-4-1、给线程池命名一般使用两种方法：" class="headerlink" title="9.4.1、给线程池命名一般使用两种方法："></a>9.4.1、给线程池命名一般使用两种方法：</h3><p>**1.利用 guava 的 <code>ThreadFactoryBuilder</code> **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)<br></code></pre></td></tr></table></figure><p><strong>2.自己实现 <code>ThreadFactor</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转图像</title>
    <link href="/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/image-20220706222939152.png" alt="旋转图像"></p><p><strong>方法一：加入一个二维数组存放数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[j][n - i - <span class="hljs-number">1</span>] = matrix[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[i][j] = res[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：直接原地交换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// 先上下交换 然后在沿着对角线交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 上下交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = matrix[i];<br>            matrix[i] = matrix[n - i - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>        <span class="hljs-comment">// 对角线交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全排列</title>
    <link href="/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/image-20220706223151247.png" alt="全排列"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        backtrace(<span class="hljs-number">0</span>, list, nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> index, List&lt;Integer&gt; list, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从第一位往后固定</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123; <span class="hljs-comment">// 要是这个位置没有元素</span><br>                list.add(nums[i]);<br>                used[i] = <span class="hljs-literal">true</span>;<br>                backtrace(index + <span class="hljs-number">1</span>, list, nums, used);<br>                <span class="hljs-comment">// 移除list数组最后一个值</span><br>                list.remove(list.size() - <span class="hljs-number">1</span>);<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接雨水</title>
    <link href="/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20220704163322027.png" alt="接雨水"></p><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 双指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 那边小那边就往里走</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            leftMax = Math.max(height[left], leftMax);<br>            rightMax = Math.max(height[right], rightMax);<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                <span class="hljs-comment">// 计算最高值和当前值之间的储水量</span><br>                ans += leftMax - height[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += rightMax - height[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/image-20220613101313587.png" alt="搜索旋转排序数组"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 数组找东西 优先想到二分法，虽然数组不有序，但是局部有序 所以我们现在有序的地方寻找，然后再在无序的地方寻找</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[r]) &#123; <span class="hljs-comment">// 有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长有效括号</title>
    <link href="/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/image-20220613091241176.png" alt="最长有效括号"></p><p><strong>解法：栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.push(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 如果加入的元素是(</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 将(的下标放入栈内</span><br>                stack.push(i);<br>            &#125;<br>            <span class="hljs-comment">// 如果加入的元素是 (，那么存在</span><br>            <span class="hljs-comment">// 1、)前面有(</span><br>            <span class="hljs-comment">// 2、前面没有左括号和它进行匹配，那么这个右括号就形成了新的边界。新的子串匹配时，起点必须在该边界右边</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123; <span class="hljs-comment">// 加入的元素不是(,是)</span><br>                stack.pop();<br>                <span class="hljs-comment">// 如果栈是空的</span><br>                <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 将这个右括号的下标作为最后一个没有被匹配的右括号</span><br>                    stack.push(i);<br>                &#125;<br>                <span class="hljs-comment">// 匹配到了。那么这个有括号的下标减去栈顶元素(也就是最后一个没有被匹配的括号)就是当前长度</span><br>                max =  Math.max(max, i - stack.peek());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下一个排列</title>
    <link href="/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/image-20220607113633064.png" alt="下一个排列"></p><p><strong>题意分析：</strong></p><p>找到一个比nums刚好还大的一个数字，也就是用nums的所给数字组成一个比刚开始的nums大的数字中的最小的数字就是所要输出的数</p><p><strong>题解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">// [1,2,3,8,5,7,6,4]</span><br>    <span class="hljs-comment">// 先从后往前找 找到最靠右的第一个变小的值 然后找到这个值右边比这个值小的值</span><br>    <span class="hljs-comment">// 然后交换这两个值</span><br>    <span class="hljs-comment">// 然后将最小的最大值的右边的数字按从小到大排序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i--;<br>        &#125; <span class="hljs-comment">// 5</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j--;<br>            &#125; <span class="hljs-comment">// 6</span><br>            swap(nums, i, j);<br>        &#125;<br>        sort(nums, i+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220607084424542.png" alt="合并K个升序链表"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 防止溢出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br><br>    <span class="hljs-comment">// 空指针</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dum;<br><br>        <span class="hljs-keyword">while</span>(a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(a.val &lt; b.val) &#123;<br>                cur.next = a;<br>                a = a.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur.next = b;<br>                b = b.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = a != <span class="hljs-literal">null</span> ? a : b;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>括号生成</title>
    <link href="/2022/06/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2022/06/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/image-20220604094755038.png" alt="括号生产"></p><p><strong>解法一：（深度优先遍历。回溯）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, n, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// left 与 right指的是左右括号的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, String s, <span class="hljs-type">int</span> n, List&lt;String&gt; ans)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == n &amp;&amp; right == n) &#123;<br>            ans.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>            dfs(left + <span class="hljs-number">1</span>, right, s + <span class="hljs-string">&quot;(&quot;</span>, n, ans);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; n) &#123;<br>            dfs(left, right + <span class="hljs-number">1</span>, s + <span class="hljs-string">&quot;)&quot;</span>, n, ans);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="/2022/06/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220604091731709.png" alt="合并两个有序链表"></p><p><strong>解法一：（递归）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list1, list2.next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（迭代）</strong></p><p>定义一个哨兵节点，然后将两个表中的节点一一对比，小的节点跟在哨兵节点之后。最后返回哨兵节点.next</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的括号</title>
    <link href="/2022/06/03/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/06/03/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/03/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/image-20220603152739672.png" alt="有效的括号"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            ch = s.charAt(i);<br>            <span class="hljs-comment">//碰到左括号，就把相应的右括号入栈</span><br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果是右括号判断是否和栈顶元素匹配</span><br>                deque.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后判断栈中元素是否匹配</span><br>        <span class="hljs-keyword">return</span> deque.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="解题过程"></p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="/2022/06/03/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2022/06/03/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/03/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220603102220574.png" alt="删除链表的倒数第N个节点"></p><p><strong>解法一：（双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br><br>        <span class="hljs-comment">//前面添加0节点以解决删除第一个的问题</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        fast = head;<br>        slow = res;<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//快指针先走n个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-comment">//当fast来到了末尾之后一个的时候，slow到达了倒数第n个的前一个，此时这个节点就是要删除的</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="/2022/05/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/05/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/image-20220529110449581.png" alt="电话号码的字母组合"></p><p><strong>解法：(回溯)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">//设置全局列表存储最后的结果</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">//初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串&quot;&quot;</span><br>        String[] numString = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>        <span class="hljs-comment">//迭代处理</span><br>        backTracking(digits, numString, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br><br>    &#125;<br><br>    <span class="hljs-comment">//每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-comment">//比如digits如果为&quot;23&quot;,num 为0，则str表示2对应的 abc</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(String digits, String[] numString, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">//遍历全部一次记录一次得到的字符串</span><br>        <span class="hljs-comment">//用num记录每次遍历到字符串的位置，这样性能更好</span><br>        <span class="hljs-keyword">if</span> (num == digits.length()) &#123;<br>            list.add(temp.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//str 表示当前num对应的字符串 </span><br>        <span class="hljs-comment">//digits.charAt(num) 获取当前num位置的字符</span><br>        <span class="hljs-comment">//由于numString表是从0下标开始一直到9 所以 -&#x27;0&#x27;之后就可以得到对应的数组的下标位置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> numString[digits.charAt(num) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-comment">//遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            temp.append(str.charAt(i));<br>            <span class="hljs-comment">//回溯</span><br>            backTracking(digits, numString, num + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//剔除末尾的继续尝试</span><br>            temp.deleteCharAt(temp.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql</title>
    <link href="/2022/05/28/Mysql/"/>
    <url>/2022/05/28/Mysql/</url>
    
    <content type="html"><![CDATA[<p><strong>一些不怎么用过的mysql语句：</strong></p><p><strong>rank() over：</strong>排名相同的两名是并列，但是占两个名次，1 1 3 4 4 6这种</p><p><strong>dense_rank() over：</strong>排名相同的两名是并列，共占一个名词，1 1 2 3 3 4这种</p><p><strong>row_number() over：</strong>这个函数不需要考虑是否并列，哪怕根据条件查询出来的数值相同也会进行连续排名 1 2 3 4 5</p><p><strong>distance</strong> 去重</p><p><strong>ifnull</strong> 判断是否为空 自动去除空的数据 ifnull(( ***),null) 将表中的空数据输出为null</p><h1 id="一、逻辑架构"><a href="#一、逻辑架构" class="headerlink" title="一、逻辑架构"></a>一、逻辑架构</h1><h2 id="1、逻辑架构剖析"><a href="#1、逻辑架构剖析" class="headerlink" title="1、逻辑架构剖析"></a>1、逻辑架构剖析</h2><h3 id="1-1服务器处理客户端请求"><a href="#1-1服务器处理客户端请求" class="headerlink" title="1.1服务器处理客户端请求"></a>1.1服务器处理客户端请求</h3><p>mysql是c/s架构，即 <strong>Client/Server 架构</strong>，服务器端程序使用的 <strong>mysqld</strong></p><p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是： <strong>客户端进程向服务器进程发送一段文本(SQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)。</strong></p><p><img src="/2022/05/28/Mysql/image-20220530211722852.png" alt="查询请求"></p><p><img src="/2022/05/28/Mysql/image-20220530221410526.png" alt="mysql服务器的逻辑架构说明"></p><h3 id="1-2、Connectors"><a href="#1-2、Connectors" class="headerlink" title="1.2、Connectors"></a>1.2、Connectors</h3><p>Connectors，指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server<strong>建立TCP连接</strong>,之后按照其定义好的协议进行交互。或者比较方便的办法是调用SDK，比如Native c API、JDBC、PHP等各种语言MySQL Connector，或者通过ODBC。但<strong>通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互。</strong></p><h3 id="1-3、第1层：连接层"><a href="#1-3、第1层：连接层" class="headerlink" title="1.3、第1层：连接层"></a>1.3、第1层：连接层</h3><p>系统(客户端)访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p><p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p><ul><li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li><li><strong>用户名认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li></ul><p><strong>TCP</strong> 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>多个系统都可以和MySQL服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL服务器里有专门的<code>TCP连接池</code>限制连接数，采用<code>长连接模式</code>复用TCP连接。</p><p><img src="/2022/05/28/Mysql/image-20220530230605123.png" alt="image-20220530230605123"></p><p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>这些内容都归纳到<code>MySQL</code>的<strong>连接管理</strong>组件中。</p><p>所以<strong>连接管理</strong>的职责是负责认证、管理连接、获取权限信息。</p><h3 id="1-4、第2层：服务层"><a href="#1-4、第2层：服务层" class="headerlink" title="1.4、第2层：服务层"></a>1.4、第2层：服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成 <code>缓存的查询</code>，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现。</p><p>在该层，服务器会 <code>解析查询</code>并创建相应的内部 <code>解析树</code>，并对其完成相应的 <code>优化</code>：如确定查询表的顺序，是由利用索引等，最后生成相应的执行操作。</p><p>如果是SELECT语句，服务器还会 <code>查询内部的缓存</code>。如果缓存空间足够大，这样在解决大量读操作的环境中能后很好的提升系统的性能。</p><ul><li><p><strong>SQL Interface：SQL接口</strong></p><ul><li>接受用户的SQL命令，并且返回用户需要查询的结果。比如SELECT…FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。</li></ul></li><li><p><strong>Parser：解析器</strong></p><ul><li>在解析器中对SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是够具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>OpTimizer：查询优化器</strong></p><ul><li><p>SQL语句在语法解析之后，查询之前会使用查询优化器确定SQL语句的执行路径，生成一个<code>执行计划</code>。</p></li><li><p>这个执行计划表明应该 <code>使用哪些索引</code>进行查询(全表检索还是使用索引检索)，表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用<code>选取-投影-连接</code>策略进行查询。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id,name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是讲标全部查询出来以后再进行gender过滤。</p><p>这个SELECT查询现根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后在进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p></li></ul></li><li><p><strong>Caches &amp; Buffers：查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能后在其中找到对应的查询结果，那么就不再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓存等。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul></li></ul><h3 id="1-5、第3层：引擎层"><a href="#1-5、第3层：引擎层" class="headerlink" title="1.5、第3层：引擎层"></a>1.5、第3层：引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。</p><hr><p>和其它数据库相比，MysQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，<code>插件式的存储引擎</code>架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MySQL还允许<code>开发人员设置自己的存储引擎</code>。</p><p>这种高效的模块化架构为那些希望专门针对特定应用程序需求（例如数据仓库、事务处理或高可用性情况)的人提供了巨大的好处，同时享受使用一组独立于任何接口和服务的优势存储引擎。</p><p>插件式存储引擎层（Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p><p>MySQL8.0.25默认支持的存储引擎如下：</p><p><img src="/2022/05/28/Mysql/image-20220531002203728.png" alt="存储引擎"></p><h3 id="1-6、存储层"><a href="#1-6、存储层" class="headerlink" title="1.6、存储层"></a>1.6、存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在<strong>文件系统</strong>上，以<strong>文件</strong>的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统</p><p>使用 <strong>show variables like “%datadir%”</strong>可以查看存储文件所在的地方</p><p><img src="/2022/05/28/Mysql/image-20220531002543626.png"></p><h3 id="1-7、小结"><a href="#1-7、小结" class="headerlink" title="1.7、小结"></a>1.7、小结</h3><p>MySQL架构图简化如下：</p><p><img src="/2022/05/28/Mysql/image-20220531002348351.png"></p><p>简化为三层结构：</p><ol><li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li><li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li><li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li></ol><h2 id="2、SQL执行流程"><a href="#2、SQL执行流程" class="headerlink" title="2、SQL执行流程"></a>2、SQL执行流程</h2>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和</title>
    <link href="/2022/05/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/05/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/image-20220527150203332.png" alt="三数之和"></p><p><strong>解法：（排序+双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 先从小到大排序</span><br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 从第一位开始判断</span><br>        <span class="hljs-comment">// k &lt; nums.length - 2是为了保证后面还能存在两个数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; nums.length - <span class="hljs-number">2</span>; k++) &#123;<br>            <span class="hljs-comment">// 若nums[k]大于0，则后面的数字也是大于零（排序后是递增的）</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 判断该数字的下一个数字与最后一个数字</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>, j = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>                <span class="hljs-comment">// 如果该数字与数字下一个数字与最后一个数字之和为sum 那么输出</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[k] + nums[i] + nums[j];<br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 左指针向右并且去重</span><br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 右指针向左并且去重</span><br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="/2022/05/26/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/05/26/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/26/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/image-20220526092922227.png" alt="盛最多水的容器"></p><p><strong>解法：（双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || height == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nowRes</span> <span class="hljs-operator">=</span> (right - left) * Math.min(height[left], height[right]);<br>            res = Math.max(res, nowRes);<br>            <span class="hljs-keyword">if</span> (height[left] &gt; height[right]) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子串</title>
    <link href="/2022/05/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/05/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20220525103931088.png" alt="最长回文子串"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                                        中心扩散</span><br><span class="hljs-comment">    思路：寻找一个字符 然后判断左右是否相等 相等则左右各自+1 如果左边等于 那么左边指针往左移动</span><br><span class="hljs-comment">    右边等于 那么右指针往右边 然后判断左右指针所指的字符是否相等</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxlen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            left = i - <span class="hljs-number">1</span>;<br>            right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nowlen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//当前值与左值相等 左减</span><br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; chars[i] == chars[left]) &#123;<br>                left--;<br>                nowlen++;<br>            &#125;<br>            <span class="hljs-comment">//当前值与右值相等 左加</span><br>            <span class="hljs-keyword">while</span> (right &lt; len &amp;&amp; chars[i] == chars[right]) &#123;<br>                right++;<br>                nowlen++;<br>            &#125;<br>            <span class="hljs-comment">//当左右相等时，左减右加</span><br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; chars[left] == chars[right]) &#123;<br>                left--;<br>                right++;<br>                nowlen += <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nowlen &gt; maxlen) &#123;<br>                maxlen = nowlen;<br>                start = left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maxstr</span> <span class="hljs-operator">=</span> s.substring(start + <span class="hljs-number">1</span>,start + <span class="hljs-number">1</span> + maxlen);<br>        <span class="hljs-keyword">return</span> maxstr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找两个正序数组的中位数</title>
    <link href="/2022/05/24/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/05/24/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/24/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220524103718735.png" alt="寻找两个正序数组的中位数"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     思路：</span><br><span class="hljs-comment">        1、假设我们要找第 k 小数，我们可以每次循环排除掉 k/2 个数，假如我们要找第7小的数字，我们比较两个数组的第 k/2 个数字，</span><br><span class="hljs-comment">        如果 k 是奇数，向下取整。也就是比较第3个数字，上边数组中的4和下边数组中的3，</span><br><span class="hljs-comment">        如果哪个小，就表明该数组的前 k/2 个数字都不是第 k 小数字，所以可以排除。</span><br><span class="hljs-comment">        然后我们寻找第k - 3 = 4小的数字就行</span><br><span class="hljs-comment">        2、我们可能遇见有一个数组小于 k/2的情况 然后将这个小于的数组直接全部排除 然后在另一个数组中寻找第 k-m个元素即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-comment">// m + n为奇数 那么a和b一样 如果 m + n为偶数 那么就是ab的平均数</span><br>        <span class="hljs-comment">// 由于要求的是如果为奇数 让左边的数字比右边多一个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 寻找ab在nums1与nums2中的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">resa</span> <span class="hljs-operator">=</span> rec(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resb</span> <span class="hljs-operator">=</span> rec(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, b);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) (resa + resb) / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//两个数组及其起始位置，k为要找的数字的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rec</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//如果i位置大于等于长度，说明nums1走完了，就去nums2里直接找</span><br>        <span class="hljs-keyword">if</span> (i &gt;= nums1.length) &#123;<br>            <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j &gt;= nums2.length) &#123;<br>            <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//如果要找第一个元素，那么就找这两个数组中最小的数,也就是他们起始位置中最小的</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>        &#125;<br><br>        <span class="hljs-comment">//确保还有第k/2个值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br><br>        <span class="hljs-comment">//如果两个数组中的第k/2相等  如果k是偶数，那么这个位置的数字就是要找的，无论舍弃哪个都会留下有正确答案的,如果是奇数，答案在某个数组的k/2的下一个，总之正确答案不会被舍弃掉</span><br>        <span class="hljs-keyword">if</span> (m1 == m2 &amp;&amp; k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> m1;<br>        &#125;<br>        <span class="hljs-comment">//两个数组中谁的第k/2个数小，就舍弃他的前k/2个数，k也小一半</span><br>        <span class="hljs-keyword">if</span> (m1 &lt; m2) &#123;<br>            i += k / <span class="hljs-number">2</span>;<br>            k -= k / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> rec(nums1, i, nums2, j, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j += k / <span class="hljs-number">2</span>;<br>            k -= k / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> rec(nums1, i, nums2, j, k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="/2022/05/24/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/05/24/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/24/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/image-20220524104149607.png" alt="无重复字符的最长子串"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 哈希集合，记录每个字符是否出现过</span><br>        Set&lt;Character&gt; occ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Character&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 左指针向右移动一格，移除一个字符</span><br>                occ.remove(s.charAt(i - <span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-keyword">while</span> (r + <span class="hljs-number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(r + <span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-comment">// 不断地移动右指针</span><br>                occ.add(s.charAt(r + <span class="hljs-number">1</span>));<br>                ++r;<br>            &#125;<br>            <span class="hljs-comment">// 第 i 到 r 个字符是一个极长的无重复字符子串</span><br>            ans = Math.max(ans, r - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数相加</title>
    <link href="/2022/05/24/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2022/05/24/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/24/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/image-20220524104020123.png" alt="两数相加"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> res;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">// carry 是否要进位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果l1 l2有一个为0但carry不为零，就只需要加剩余的一个</span><br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>||carry != <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) &#123;<br>                carry += l1.val;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) &#123;<br>                carry += l2.val;<br>                l2 = l2.next;<br>            &#125;<br>            <span class="hljs-comment">//例如刚开始是9+9   carry就等于18  l3这一位就等于8，</span><br>            l3.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry%<span class="hljs-number">10</span>);<br>            l3 = l3.next;<br>            <span class="hljs-comment">//carry除以10之后带到下一位  例如18，就会把1带到下一位</span><br>            carry /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2022/05/24/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/05/24/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/24/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/image-20220524103848060.png" alt="两数之和"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字序列中某一位的数字</title>
    <link href="/2022/05/18/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/05/18/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/18/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220518113457587.png" alt="数字序列中某一位的数字"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 前十位每个占一格  总共有10个位子除去0还有9个</span><br>        <span class="hljs-comment">// 10-99 占2格      总共有90 * 2 = 180个位子</span><br>        <span class="hljs-comment">// 100 -999 占3格   总共有 900 * 3 = 2700个位子</span><br>        <span class="hljs-comment">// 所以知道n可以知道是几位数，第几个</span><br><br>        <span class="hljs-comment">//占了几位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//在第几个数字中</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//目前占了多少个数字。因为n&lt; 2e31,所以count是可能越int的</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br>        <span class="hljs-comment">//例如1，10，100，1000</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; count) &#123;<br><br>            n -= count;<br><br>            digit++;<br><br>            start *= <span class="hljs-number">10</span>;<br><br>            count = digit * start * <span class="hljs-number">9</span>;<br><br>        &#125;<br>        <span class="hljs-comment">//在第res个数字中</span><br>        res = start + (n - <span class="hljs-number">1</span>)/digit;<br><br>        <span class="hljs-comment">//这个数的第几位</span><br>        <span class="hljs-keyword">return</span> Long.toString(res).charAt((n - <span class="hljs-number">1</span>) % digit) - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1~n整数中1出现的次数</title>
    <link href="/2022/05/18/1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/05/18/1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/18/1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/image-20220518102620979.png" alt="1~n整数中1出现的次数"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 对于这道题而言 1出现的个数取决于 1在每一位上出现的次数</span><br>    <span class="hljs-comment">// 当前位为0的时候 1出现的次数由高位决定 也就是 res = 高位 * 10</span><br>    <span class="hljs-comment">// 当前位为1的时候 1出现的次数由高位与低位决定 也就是 res = 高位 * 10 + 低位 + 1</span><br>    <span class="hljs-comment">// 当前位为2~9的时候 1出现的次数由高位决定 也就是 res = (高位 + 1) * 10</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 高位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 当前位,从个位开始</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 低位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 位因子</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当高位与当前位有一个不是0的时候</span><br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 高位 * 位因子</span><br>                res += high * digit;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>                res += high * digit + low + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                res +=(high + <span class="hljs-number">1</span>) * digit;<br>            &#125;<br>            <span class="hljs-comment">// 更新low  cur  hight  dight</span><br>            low +=cur * digit;<br>            <span class="hljs-comment">// cur是high的最后一位</span><br>            cur = high % <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">// 高位上升</span><br>            high /= <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">// 位因子乘10</span><br>            digit *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剪绳子Ⅱ</title>
    <link href="/2022/05/18/%E5%89%AA%E7%BB%B3%E5%AD%90%E2%85%A1/"/>
    <url>/2022/05/18/%E5%89%AA%E7%BB%B3%E5%AD%90%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/18/%E5%89%AA%E7%BB%B3%E5%AD%90%E2%85%A1/image-20220518092413253.png" alt="剪绳子Ⅱ"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 由剪绳子Ⅰ可以得出 剪绳子剪成3的倍数 为最理想状态</span><br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>            res = res * <span class="hljs-number">3</span> % p;<br>            n -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-comment">// 乘3以后 将剩下的数字也乘进去</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res * n % p);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="/2022/05/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2022/05/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/image-20220517155231958.png" alt="数组中的逆序对"></p><p><strong>解法一：</strong></p><p>暴力递归（双指针一个一个进行比较，发现符合的情况则res++），题目所给的数组长度在0~500之间，暴力递归会出现超时</p><p><strong>解法二：归并排序的时候进行对逆序对的统计</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums, tmp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">return</span> mergeSort(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 递归划分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> mergeSort(l, m) + mergeSort(m + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-comment">// 合并阶段</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = m + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 在每次比较大小的时候顺便进行对逆序对的统计</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l; k &lt;= r; k++)<br>            tmp[k] = nums[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l; k &lt;= r; k++) &#123;<br>            <span class="hljs-keyword">if</span> (i == m + <span class="hljs-number">1</span>)<br>                nums[k] = tmp[j++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == r + <span class="hljs-number">1</span> || tmp[i] &lt;= tmp[j])<br>                nums[k] = tmp[i++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                nums[k] = tmp[j++];<br>                res += m - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 统计逆序对</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打印从1到最大的n位数</title>
    <link href="/2022/05/16/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/05/16/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/16/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/image-20220516113408866.png" alt="打印从1到最大的n位数"></p><p><strong>解法一：（不考虑大数）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] printNumbers(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            max *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; max; i++) &#123;<br>            res[i - <span class="hljs-number">1</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（考虑大数）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-type">int</span>[] res;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,nine = <span class="hljs-number">0</span>,start,n;<br>        <span class="hljs-type">char</span>[] a;<br>        <span class="hljs-type">char</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>&#125;;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] printNumbers(<span class="hljs-type">int</span> n) &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[(<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">10</span>,n) - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 数字字符串集</span><br>            a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n]; <span class="hljs-comment">// 定义长度为n的字符列表</span><br>            <span class="hljs-comment">//初始化start例如最大99，那么前十个的个位就不需要</span><br>            start = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 全排列</span><br>            dfs(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-comment">// 终止条件：固定完所有的位</span><br>            <span class="hljs-keyword">if</span> (x == n) &#123;<br>                <span class="hljs-comment">// 截取</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(a).substring(start);<br>                <span class="hljs-keyword">if</span> (!s.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>                    <span class="hljs-comment">// num添加到res尾部用逗号隔开</span><br>                    <span class="hljs-comment">// res.append(s + &quot;,&quot;);</span><br>                    res[count++] = Integer.parseInt(s);<br>                &#125;<br>                <span class="hljs-comment">// 所有位都是9即要进位了 nine是9的数量</span><br>                <span class="hljs-keyword">if</span> (n - start == nine) &#123;<br>                    start--;<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 每一位</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i : b) &#123;<br>                <span class="hljs-comment">// a[0]=0</span><br>                <span class="hljs-comment">// a[1]=0</span><br>                <span class="hljs-comment">// 固定的x位是i</span><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    nine++;<br>                &#125;<br>                a[x] = i;<br>                <span class="hljs-comment">// 下一位固定</span><br>                dfs(x + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// nine恢复</span><br>            nine--;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>n个骰子的点数</title>
    <link href="/2022/05/15/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <url>/2022/05/15/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/15/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/image-20220515110935835.png" alt="n个骰子的点数"></p><p><strong>解法一：（暴力递归）</strong></p><p>时间复杂度为O(6^n) <strong>超时</strong></p><p><strong>解法二：（动态规划）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] dicesProbability(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">6</span>];<br>    <span class="hljs-comment">// Arrays.fill() 将指定的值分配给指定数组的每个元素。</span><br>        Arrays.fill(dp, <span class="hljs-number">1.0</span> / <span class="hljs-number">6.0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">double</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span> * i + <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// n-1个骰子的每一项都会对有n个骰子的点数和产生影响</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; dp.length; j++) &#123;<br>                <span class="hljs-comment">// 第n个骰子的1~6</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++) &#123;<br>                    <span class="hljs-comment">// 加上前do数组j值对应概率/6</span><br>                    tmp[j + k] += dp[j] * (<span class="hljs-number">1.0</span> / <span class="hljs-number">6.0</span>);<br>                &#125;<br>            &#125;<br>            dp = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑数</title>
    <link href="/2022/05/15/%E4%B8%91%E6%95%B0/"/>
    <url>/2022/05/15/%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/15/%E4%B8%91%E6%95%B0/image-20220515102813385.png" alt="丑数"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 每一个丑数都是由他前面的某一个丑数*2 *3 *5得到的</span><br>        <span class="hljs-comment">// 所以我们只要求的前面的丑数*2 *3 *5之后的最小值就是这个丑数之后的下一个丑数的值</span><br>        <span class="hljs-comment">// n不超过1690</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1690</span>];<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> dp[a] * <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> dp[b] * <span class="hljs-number">3</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> dp[c] * <span class="hljs-number">5</span>;<br>            <span class="hljs-comment">// 得到最小的前面的丑数*2 *3 *5的值</span><br>            dp[i] = Math.min(Math.min(n2, n3), n5);<br>            <span class="hljs-keyword">if</span> (dp[i] == n2) &#123;<br>                <span class="hljs-comment">// 如果dp[i]是a*2得到，那么下一个需要*2得到的丑数就是a的下一个</span><br>                a++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == n3) &#123;<br>                b++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == n5) &#123;<br>                c++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="/2022/05/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/05/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20220514164139599.png" alt="正则表达式匹配"></p><p><strong>解法一：（暴力递归）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-comment">// a是题目所给的字符串</span><br>        <span class="hljs-type">char</span>[] a = s.toCharArray();<br>        <span class="hljs-comment">// b是正则表达式</span><br>        <span class="hljs-type">char</span>[] b = p.toCharArray();<br><br>        <span class="hljs-comment">// 如果字符串为空</span><br>        <span class="hljs-keyword">if</span> (a.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 那么正则表达式只能是偶数，而且最后一位只能 是&#x27;*&#x27;</span><br>            <span class="hljs-keyword">if</span> (!(b.length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果是偶数，偶数位一位只能是&#x27;*&#x27;</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; b.length) &#123;<br>                <span class="hljs-keyword">if</span> (b[i] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                i += <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果字符串不是空 但是正则表达式为0</span><br>        <span class="hljs-keyword">if</span> (b.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义两个变量负责用来遍历a，b内部的元素</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> b[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// c3 是指正则表达式中正在比较的字符的下一位</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;~&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (b.length &gt; <span class="hljs-number">1</span>) &#123;<br>            c3 = b[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c3 != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (c1 == c2 || c2 == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 匹配</span><br>                <span class="hljs-keyword">return</span> isMatch(s.substring(<span class="hljs-number">1</span>), p.substring(<span class="hljs-number">1</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 下一位是&#x27;*&#x27;</span><br>            <span class="hljs-keyword">if</span> (c1 == c2 || c2 == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> isMatch(s.substring(<span class="hljs-number">1</span>), p) || isMatch(s, p.substring(<span class="hljs-number">2</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> isMatch(s, p.substring(<span class="hljs-number">2</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（动态规划）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    <span class="hljs-type">char</span>[] a = s.toCharArray();<br>    <span class="hljs-type">char</span>[] b = p.toCharArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">alen</span> <span class="hljs-operator">=</span> a.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">blen</span> <span class="hljs-operator">=</span> b.length;<br><br>    <span class="hljs-type">boolean</span>[][] ism = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[alen + <span class="hljs-number">1</span>][blen + <span class="hljs-number">1</span>];<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= alen; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= blen; j++) &#123;<br>            <span class="hljs-comment">//正则串为空。是否匹配取决于主串是否为空</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                ism[i][j] = i == <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//正则串本位不为*</span><br>                <span class="hljs-keyword">if</span> (b[j - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>] || b[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>                        ism[i][j] = ism[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span>) &#123;<br>                        <span class="hljs-comment">//如果不看，就砍掉</span><br>                        ism[i][j] = ism[i][j - <span class="hljs-number">2</span>];<br>                    &#125;<br>                    <span class="hljs-comment">//正则串本位为*    如果需要使用*</span><br>                    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">2</span> &amp;&amp; (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">2</span>] || b[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>                        <span class="hljs-comment">//如果在前一步已经计算ism[i][j]是true，就不需要计算</span><br>                        ism[i][j] |= ism[i - <span class="hljs-number">1</span>][j] ;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ism[alen][blen];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p><img src="/2022/05/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/68F4F9C9D81832F29A9D78CEA7E5AD59.png" alt="解题思路"></p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串的排列</title>
    <link href="/2022/05/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2022/05/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/image-20220511103629683.png" alt="字符串的排列"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> chars.length;<br>        <span class="hljs-comment">//第二个参数为固定到了第几个数</span><br>        rec(chars,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 交换数字的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s[a];<br>        s[a] = s[b];<br>        s[b] = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rec</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars,<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">//固定到了最后一个数</span><br>        <span class="hljs-keyword">if</span>(x == chars.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//最后一个数也只有一个排列,也说明固定完了</span><br>            res.add(String.valueOf(chars));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//去重</span><br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt; chars.length;i++) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(chars[i])) &#123;<br>                <span class="hljs-comment">//如果set中已经固定过这个数了,就进行下一个固定</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            set.add(chars[i]);<br>            <span class="hljs-comment">//交换当前数与固定到的最后一个数</span><br>            swap(chars,x,i);<br>            rec(chars,x + <span class="hljs-number">1</span>);<br>            swap(chars,i,x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列的最大值</title>
    <link href="/2022/05/10/%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/05/10/%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/10/%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/image-20220510111946329.png" alt="队列的最大值"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br><br>    <span class="hljs-comment">//普通队列</span><br>    Deque&lt;Integer&gt; queue;<br>    <span class="hljs-comment">//单调队列</span><br>    Deque&lt;Integer&gt; deque;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxQueue</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max_value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (deque.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque.peekFirst();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// offer()方法用于在双端队列的末尾添加给定元素</span><br>        queue.offer(value);<br>        <span class="hljs-comment">// 保证单调队列的递减的</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value) &#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.addLast(value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop_front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (queue.peek().equals(deque.peekFirst())) &#123;<br>            <span class="hljs-comment">// pollFirst() : 返回此双端队列表示的队列的第一个元素，但会从此双端队列中删除第一个元素。</span><br>            deque.pollFirst();<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MaxQueue obj = new MaxQueue();</span><br><span class="hljs-comment"> * int param_1 = obj.max_value();</span><br><span class="hljs-comment"> * obj.push_back(value);</span><br><span class="hljs-comment"> * int param_3 = obj.pop_front();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="/2022/05/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2022/05/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/09/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/image-20220509104013577.png" alt="滑动窗口的最大值"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> - k, j = <span class="hljs-number">0</span>; j &lt; len; j++, i++) &#123;<br>            <span class="hljs-comment">// deque.peekFirst() =&gt; 用于检索链表的第一个元素，初始元素或开始元素，但不会从列表中删除第一个元素。</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                deque.removeFirst();<br>            &#125;<br>            <span class="hljs-comment">// 删除最大值左边的值，保证队列递减,那么就判断队列左边的值与新加入的元素的值的大小</span><br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j]) &#123;<br>                <span class="hljs-comment">// deque.removeLast() =&gt; 用于返回最后一个元素，但要从此双端队列移除该元素</span><br>                deque.removeLast();<br>            &#125;<br>            deque.addLast(nums[j]);<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                res[i] = deque.peekFirst();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈的压入、弹出序列</title>
    <link href="/2022/05/08/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <url>/2022/05/08/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/08/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/image-20220508111814728.png" alt="栈的压入、弹出序列"></p><p><strong>解法：（栈）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 定义弹出序列的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : pushed) &#123; <br>            stack.push(num); <span class="hljs-comment">// 将压栈序列遍历到栈内</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123; <span class="hljs-comment">// 如果我的弹出序列要弹出的数等于栈顶元素</span><br>                stack.pop(); <span class="hljs-comment">// 将栈顶元素弹出</span><br>                i++; <span class="hljs-comment">// 查看压栈序列的下一个数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="/2022/05/08/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/05/08/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/08/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/image-20220508104326728.png" alt="顺时针打印矩阵"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 行数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 列数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 结果集</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[x * y];<br>        <span class="hljs-comment">// 结果集的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 上下左右边界 当遍历大于边界的时候跳出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> x - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> y - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (sub &lt;= res.length) &#123;<br>            <span class="hljs-comment">// 模拟从左往右</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                res[sub] = matrix[top][i];<br>                sub++;<br>            &#125;<br>            top++;<span class="hljs-comment">// 本行走完</span><br>            <span class="hljs-keyword">if</span> (top &gt; bottom) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 模拟从上到下</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>                res[sub] = matrix[i][right];<br>                sub++;<br>            &#125;<br>            right--;<span class="hljs-comment">// 本列走完</span><br>            <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 模拟从右到左</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br>                res[sub] = matrix[bottom][i];<br>                sub++;<br>            &#125;<br>            bottom--;<span class="hljs-comment">// 本行走完</span><br>            <span class="hljs-keyword">if</span> (top &gt; bottom) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 模拟从下到上</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>                res[sub] = matrix[i][left];<br>                sub++;<br>            &#125;<br>            left++;<span class="hljs-comment">// 本列走完</span><br>            <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/05/08/JVM/"/>
    <url>/2022/05/08/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JVM概述"><a href="#一、JVM概述" class="headerlink" title="一、JVM概述"></a>一、JVM概述</h1><h2 id="1-1、Java虚拟机"><a href="#1-1、Java虚拟机" class="headerlink" title="1.1、Java虚拟机"></a>1.1、Java虚拟机</h2><p><strong>Java虚拟机</strong></p><ul><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成</li><li>JVM平台的各种语言可以共享Java虚拟机带来的快平台性、优秀的垃圾回收器，以及可靠的即时编译器</li><li><strong>Java技术的核心就是Java虚拟机</strong>(JVM， Java Virtual Machine)，因为所有的Java程序都运行在Java虚拟机内部</li></ul><p><strong>作用</strong></p><ul><li>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么操作数，怎么处理作数，处理结果放在哪里。</li></ul><p><strong>特点</strong></p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收机制（担忧，因为不需要去考虑回收的原理，长期的自动化会导致如果出现内存溢出是Java程序员无法解决）</li></ul><p><strong>JVM的位置</strong></p><p><img src="/2022/05/08/JVM/image-20220508004058537.png" alt="JVM的位置"></p><p><img src="/2022/05/08/JVM/image-20220508005148157.png" alt="JDK的构成"></p><h2 id="1-2、JVM的整体结构"><a href="#1-2、JVM的整体结构" class="headerlink" title="1.2、JVM的整体结构"></a>1.2、JVM的整体结构</h2><p><img src="/2022/05/08/JVM/image-20220508005504671.png" alt="JVM的整体结构"></p><ul><li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</p></li><li><p>它采用解释器与即时编译器并存的架构。3</p></li><li><p>在今天，Java程序的运行性能早已脱胎换骨，已经带到了可以和C/C++程序一较高下的底部。</p></li><li><p><strong>类装载器子系统</strong>将字节码文件加载到内存中生成一个大的Class对象， 涉及到加载、 连接、 初始化。</p></li><li><p>对于<strong>方法区</strong>和<strong>堆</strong> 多个线程共享，对于<strong>Java栈、本地方法栈、程序技术器</strong> 每一个线程独有一份</p></li><li><p><strong>执行引擎</strong>充当了高级语言翻译成机器语言的翻译器</p></li></ul><h2 id="1-3、Java代码的执行流"><a href="#1-3、Java代码的执行流" class="headerlink" title="1.3、Java代码的执行流"></a>1.3、Java代码的执行流</h2><p><img src="/2022/05/08/JVM/image-20220508010848773.png" alt="Java代码的执行流程"></p><ol><li>Java的代码进过Java编译器变成了Java虚拟机可以识别字节码文件。</li><li>字节码文件再进过Java虚拟机变成了操作系统可以识别的机器指令。</li><li>操作系统再根据相关的机器指令做出对应的操作。</li></ol><h2 id="1-4、JVM的架构模型"><a href="#1-4、JVM的架构模型" class="headerlink" title="1.4、JVM的架构模型"></a>1.4、JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于<strong>栈的指令集架构</strong>，另外一种指令集架构则是基于 <strong>寄存器的指令集架构</strong></p><p>具体来说，这两种架构之间的区别：</p><ul><li><strong>基于栈式架构的特点</strong><ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li><strong>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</strong></li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul></li><li><strong>基于寄存器架构的特点</strong><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li><strong>指令集架构则完全依赖硬件，可移植性差</strong></li><li><strong>性能优秀和执行更高效；</strong></li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都是一地址指令、二地址指令和三地址指令为主，二基于展示架构的指令集确实以零地址指令为主。</li></ul></li></ul><p><strong>举例1：</strong></p><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以Java虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">iconst_2 <span class="hljs-comment">// 常量2入栈</span><br>iconst_1<br>iconst_3 <span class="hljs-comment">// 常量3入栈</span><br>iconst_2<br>iload_1<br>iload_2<br>iadd<span class="hljs-comment">// 常量2、3出栈，执行相加</span><br>istore_0    <span class="hljs-comment">// 结果5入栈</span><br></code></pre></td></tr></table></figure><p>基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mov eax,<span class="hljs-number">2</span><span class="hljs-comment">// 使eax寄存器的值设为1    </span><br>mov eax,<span class="hljs-number">3</span><span class="hljs-comment">// 使eax寄存器的值加3    </span><br></code></pre></td></tr></table></figure><p><strong>举例2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: StackStruTest</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/5/8 1:58</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackStruTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述代码而言，使用栈操作的话，步骤如下（找到字节码文件，用javap -c 文件名）：</p><p><img src="/2022/05/08/JVM/image-20220508020512989.png" alt="栈操作"></p><p><strong>总结：</strong></p><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>栈：跨平台性、指令集小、指令多；执行性能比寄存器差</p><h2 id="1-5、JVM的生命周期"><a href="#1-5、JVM的生命周期" class="headerlink" title="1.5、JVM的生命周期"></a>1.5、JVM的生命周期</h2><p><strong>虚拟机的启动</strong></p><p>Java虚拟机的启动是通过<strong>引导类加载器</strong>（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体现指定的。</p><p><strong>虚拟机的执行</strong></p><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</li></ul><p><strong>虚拟机的退出</strong></p><p>有如下的几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ul><h2 id="1-6、JVM分类"><a href="#1-6、JVM分类" class="headerlink" title="1.6、JVM分类"></a>1.6、JVM分类</h2><ul><li>SUN Classic VM<ul><li>只提供解释器，如果使用JIT编译器，解释器就不能工作，也就是只能二选一</li></ul></li><li>Exact VM   (Exact Memory Management：准确式内存管理)<ul><li>虚拟机可以知道内存中某个位置的数据具体是什么类型 具有热点探测与解释器编译器混合工作功能</li></ul></li><li><strong>HotSpot VM</strong> （<strong>绝对的市场地位，称霸武林</strong>）<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换。(热点代码探测)</li><li>通过编译器与解释器协同工作，在最优化的程序相应时间与最佳性能执行中取得平衡</li><li>Sun / Oracle JDK 和 OpenJDK 的默认虚拟机</li><li><strong>默认都是HotSpot虚拟机，相关机制也主要是值HotSpot的GC机制。</strong></li></ul></li><li><strong>BEA的JRockit VM</strong><ul><li><strong>专注于服务端应用</strong><ul><li>不太关注程序启动速度，所以内部不包含解析器实现，都靠着即时编译器</li></ul></li><li><strong>是世界上最快的JVM</strong></li><li>优势：全面的Java运行时解决方案组合</li></ul></li><li><strong>IBM 的 J9</strong><ul><li>广泛用于IBM的各种Java产品。</li></ul></li><li>HotSpot，JRockit 与J9 是<strong>有影响力的三大商用虚拟机</strong></li><li><strong>Graal VM</strong><ul><li>2018年4月，oracle Labs公开了Graal VM，号称 <strong>“Run Programs Faster Anywhere”</strong>，野心勃勃。与1995年java的”write once，run anywhere”遥相呼应。</li><li>Graal VM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用</strong>。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li><strong>如果说HotSpot有一天真的被取代，Graal VM希望最大。</strong>但是Java的软件生态没有丝毫变化。</li></ul></li></ul><p>……</p><p>所有虚拟机遵循的原则:一次编译，到处允许</p><p><strong>总结</strong></p><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p><h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><h2 id="2-1、内存结构概述"><a href="#2-1、内存结构概述" class="headerlink" title="2.1、内存结构概述"></a>2.1、内存结构概述</h2><ul><li>Class文件</li><li>类加载子系统</li><li>运行时数据区</li><li>方法区</li><li>堆</li><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>执行引擎</li><li>本地方法接口</li><li>本地方法库</li></ul><p><img src="/2022/05/08/JVM/image-20220509231651617.png" alt="简图"></p><p><img src="/2022/05/08/JVM/image-20220509235533862.png" alt="详细图"></p><h2 id="2-2、类加载器与类的加载过程"><a href="#2-2、类加载器与类的加载过程" class="headerlink" title="2.2、类加载器与类的加载过程"></a>2.2、类加载器与类的加载过程</h2><p><img src="/2022/05/08/JVM/image-20220510000550216.png" alt="类加载器子系统作用"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识</li><li>ClassLoader只负责class文件的加载，治郁它是否可以运行，则有ExecutionEngine决定</li></ul><ul><li>加载的类信息存放于一块称为方法区的内存空间。除了类信息外，方法区中还会有存放运行时常量信息，可能还包含字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li><li>我自己的理解：类加载器是从硬盘中找到.class文件（是通过特定文件标识找），然后以二进制流的形式加载到内存中，当一个类被加载后，他是否能够运行是有执行引擎去负责的，和类加载器没有关系。且我们加载进去的类的信息都存放在方法区中，同时方法区中还有运行时常量信息等信息。如果实例化对象了，他们这个对象存放到堆中，但是对象的引用在栈里面。</li></ul><p><strong>类加载器ClasLoader角色</strong></p><p><img src="/2022/05/08/JVM/image-20220510004021200.png" alt="类加载器ClasLoader角色"></p><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，存放在方法区，</li><li>在.class文件-&gt; JVM-&gt;最终成为元数据模板，此过程需要一个运输根据（类加载器Class Loader），扮演一个快递员的角色。</li></ul><p><strong>类的加载过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *示例代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用流程图表示上述示例代码：</p><p><img src="/2022/05/08/JVM/image-20220510005206272.png" alt="类的加载过程的流程图"></p><h3 id="2-2-1、加载阶段"><a href="#2-2-1、加载阶段" class="headerlink" title="2.2.1、加载阶段"></a>2.2.1、加载阶段</h3><p><img src="/2022/05/08/JVM/image-20220510005107211.png" alt="类的加载阶段"></p><p><strong>加载：</strong></p><ul><li>通过一个类的全限定明获取定义次此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li><strong>在内存中存放一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。（也就是说，Class对象是在加载阶段就生成的）</li></ul><p><strong>补充：加载class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h3 id="2-2-2、链接阶段"><a href="#2-2-2、链接阶段" class="headerlink" title="2.2.2、链接阶段"></a>2.2.2、链接阶段</h3><ul><li>验证（Verify）：<ul><li>目的在子确保Class文件的字节流文件包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害到虚拟机自身安全。</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul></li><li>准备（Prepare）：<ul><li>为类变量分配内存并设置该变量的默认初始值，即零值。例如：int类型为0。</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li></ul></li><li>解析（Resolve）：<ul><li>将常量池内的符号引用转换为直接引用的过程，一般在初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><h3 id="2-2-3、初始化阶段"><a href="#2-2-3、初始化阶段" class="headerlink" title="2.2.3、初始化阶段"></a>2.2.3、初始化阶段</h3><ul><li><strong>初始化阶段就是执行类构造方法<code>&lt;clinit&gt;()</code>的过程</strong></li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量(静态变量)的赋值动作和静态代码块中的语句合并而来的。（如果没有静态变量赋值动作或静态代码就没有<code>&lt;clinit&gt;()</code>方法） <strong>必须要有静态变量赋值动作或者静态代码块</strong></li><li>构造器方法中指令按照语句<strong>在源文件中出现的顺序</strong>执行。</li><li><strong><code>&lt;clinit&gt;()</code>不同于类的构造器。</strong>（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li><li>若该类有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。一个类只会被加载一次</li></ul><p><img src="/2022/05/08/JVM/image-20220511215809705.png"></p><h2 id="2-3、类加载器分类"><a href="#2-3、类加载器分类" class="headerlink" title="2.3、类加载器分类"></a>2.3、类加载器分类</h2><p>JVM支持两种类型的类加载器。分别为<strong>引导类加载器（Bootstrap ClassLoader）和自定义加载器（User-Defined ClassLoader）。</strong></p><p>自定义类加载器一般是指程序员中有开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</strong></p><p>无论类加载器如何划分，在程序中我们最常见的类加载器只有三种：<strong>引导类加载器，扩展类加载器(Extension Class Loader)，系统类加载器(应用程序类加载器)(System Class Loader)</strong></p><div class="note note-success">            <p>因为扩展类加载器和系统类加载器可以理解为都间接继承于(不是)引导类加载器（其实是逻辑上的上下层关系），根据Java虚拟机规范，他们两个属于自定义类加载器，所以还是两种</p>          </div><p><img src="/2022/05/08/JVM/image-20220511230531390.png" alt="类加载器的分类"></p><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载<strong>使用C/C++语言实现的</strong>，嵌套在JVM内部。</li><li>它用来<strong>加载Java的核心库</strong>（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自Java.lang.ClassLoader，<strong>没有父加载器。（因为他是c写的所以不存在这些）</strong></li><li><strong>加载扩展类和应用程序类加载器</strong>，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li><strong>Java语言编写</strong>，由sun.misc.Launcher$ExtClassLoader实现。</li><li><strong>派生于ClassLoader类</strong></li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li><strong>该类加载是程序中默认的类加载器</strong>，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</li></ul><div class="note note-success">            <p>1、类加载器我们不能直接获取到，用C/C++实现</p><p>2、扩展类加载器，扩展类加载器，应用程序加载器与用户自定义加载器用java实现，之间存在getParent()关系，不存在继承关系</p>          </div><p><strong>用户自定义类加载器</strong></p><p>为什么需要自定义类加载器</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul><p>用户自定义类加载器的实现步骤</p><ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass() 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass() 方法，而是建议把自定义的类加载逻辑写在findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h2 id="2-4、ClassLoader类"><a href="#2-4、ClassLoader类" class="headerlink" title="2.4、ClassLoader类"></a>2.4、ClassLoader类</h2><p>ClassLoader类是一个抽象类，其后<strong>所有的类加载器都继承自ClassLoader</strong>（不包括启动类加载器）不包含启动类加载器，因为启动类加载器是由C++编写的)</p><p><img src="/2022/05/08/JVM/image-20220512010030997.png" alt="CLassLoader类的方法"></p><p>获取ClassLoader的途径</p><p>● 方式一：获取当前ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">clazz.getClassLoader()<br></code></pre></td></tr></table></figure><p>● 方式二：获取当前线程上下文的ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.currentThread().getContextClassLoader()<br></code></pre></td></tr></table></figure><p>● 方式三：获取系统的ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader()<br></code></pre></td></tr></table></figure><p>● 方式四：获取调用者的ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DriverManager.getCallerClassLoader()<br></code></pre></td></tr></table></figure><h2 id="2-5、双亲委派机制"><a href="#2-5、双亲委派机制" class="headerlink" title="2.5、双亲委派机制"></a>2.5、双亲委派机制</h2><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派模式</strong>，即把请求交由父类处理，它是一种任务委派模式。</p><p>原理:</p><ol><li>如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器执行</li><li>如果父类加载器还存在其他父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，反之子加载器才会尝试自己去加载</li></ol><p><img src="/2022/05/08/JVM/image-20220512012002912.png" alt="原理"></p><p>例如用户自定义了一个java.lang.String类，在加载的时候，虚拟机就会把这个请求委托给父类执行，可以防止恶意用户篡改核心api；也可以避免类重复加载</p><p><strong>优势：</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ul><h2 id="2-6、沙箱安全机制"><a href="#2-6、沙箱安全机制" class="headerlink" title="2.6、沙箱安全机制"></a>2.6、沙箱安全机制</h2><p>沙箱是一个限制程序运行的环境，他会将java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统的资源访问，包括<strong>cpu,内存，文件系统，网络</strong>，不同级别的沙箱对这些资源的访问的限制也可以不一样。</p><p>在java中将执行程序分为本地代码和远程代码两种，本地代码默认可信任，可访问本地一切自有，远程代码默认不可信，用户可以指定远程代码的权限</p><p>就是说，我们把最重要的东西放在一个盒子里，别的恶意代码无法进入，这样子就保证他的安全性。</p><p><strong>组成沙箱的基本条件:</strong></p><p>1.字节码校验器:确保Java类文件遵循Java语言规范,但核心类通不过字节码校验</p><p> 2.类装载器:可以防止恶意代码去干涉善意代码，守护了被信任的类库边界，将代码归入保护 域，确定了代码可以进行那些操作</p><p>虚拟机为不同的类加载器载入得类提供不同的命名空间，相互之间不可见。</p><h2 id="2-7、判断两个类是否是一个类"><a href="#2-7、判断两个类是否是一个类" class="headerlink" title="2.7、判断两个类是否是一个类"></a>2.7、判断两个类是否是一个类</h2><ul><li>类的完整类名一致，包括包名。</li><li>加载这个类的类加载器（ClassLoader）相同</li></ul><p><strong>以上两者必须同时满足</strong></p><h2 id="2-8、对类加载器的引用"><a href="#2-8、对类加载器的引用" class="headerlink" title="2.8、对类加载器的引用"></a>2.8、对类加载器的引用</h2><p>JVM必须知道一个类是由启动类加载器加载的还是由用户类加载器加载的，如果是用户类加载器加载的，那么JVM<code>会将这个类加载器的一个引用作为类信息的一部分保存在方法区</code>，当解析一个类型到另一个类型的引用时，jvm需要保证这两个类型的类加载器是相同的。</p><h2 id="2-9、类的主动使用和被动使用"><a href="#2-9、类的主动使用和被动使用" class="headerlink" title="2.9、类的主动使用和被动使用"></a>2.9、类的主动使用和被动使用</h2><p><img src="/2022/05/08/JVM/image-20220604100512604.png" alt="类的主动使用和被动使用"></p><h1 id="三、运行时数据区概述及线程"><a href="#三、运行时数据区概述及线程" class="headerlink" title="三、运行时数据区概述及线程"></a>三、运行时数据区概述及线程</h1><h2 id="3-1、内存"><a href="#3-1、内存" class="headerlink" title="3.1、内存"></a>3.1、内存</h2><p>内存是硬盘和cpu的中间仓库和桥梁，承载着操作系统和应用程序的实时运行，JVM内存布局规定了java在运行过程中内存申请，分配，管理的策略，保证了JVM的高效稳定运行，不同的JVM对于内存的划分方式和管理机制存在着部分差异。</p><p><img src="/2022/05/08/JVM/image-20220604105001730.png"></p><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p><p><img src="/2022/05/08/JVM/image-20220604104432595.png"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机的启动而创建，随着虚拟机的销毁而销毁，有些则是与线程一一对应的，这些与线程对应的数据区域会随着线程的开始和结束而创建和销毁。</p><ul><li>每个线程单独拥有的是程序计数器，栈，本地栈。</li><li>线程共享：堆，堆外内存（永久代或者元空间，代码缓存(非堆空间)）</li></ul><p><img src="/2022/05/08/JVM/image-20220604103451954.png"></p><p>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。 </p><h2 id="3-2、线程"><a href="#3-2、线程" class="headerlink" title="3.2、线程"></a>3.2、线程</h2><p>线程是一个程序里的运行单元，jvm允许一个应用程序有多个线程来并行执行</p><p>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>Java宪曾执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用cpu上，一旦本地线程初始化成功，他就会调用Java线程中的run()方法。</p><h1 id="四、程序计数器（PC寄存器）"><a href="#四、程序计数器（PC寄存器）" class="headerlink" title="四、程序计数器（PC寄存器）"></a>四、程序计数器（PC寄存器）</h1><p><img src="/2022/05/08/JVM/image-20220604110409850.png"></p><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据加载到寄存器中才能够运行。</p><p>这里，并不是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）更为贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟（软件层次）。</strong></p><p><strong>作用：</strong></p><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="/2022/05/08/JVM/image-20220604110733931.png"></p><ul><li>是运行速度最快的区域，但是空间很小(因为只需要存储下一条指令的地址)</li><li>每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间，一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，如果是在执行native方法也就是本地方法，则是未指定值(因为计数器是java层面的)。</li><li>它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个不会出现OutOfMemoryError的区域</li></ul><p><img src="/2022/05/08/JVM/image-20220604143627082.png" alt="pc寄存器的使用场景"></p><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></p><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="/2022/05/08/JVM/image-20220604144116135.png"></p><p><strong>PC寄存器为什么被设定为私有的？</strong></p><p>为了防止互相干扰</p><p><strong>CPU时间片</strong></p><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p><strong>并行与并发</strong></p><p>并行是多个线程同时执行。</p><p>并发是快速切换几个线程，依次执行，像是并行，但其实是并发</p><h1 id="五、虚拟机栈"><a href="#五、虚拟机栈" class="headerlink" title="五、虚拟机栈"></a>五、虚拟机栈</h1><div class="note note-success">            <p>栈是运行时的单位，而堆是存储的单位。</p><ul><li>栈解决的是运行问题，即程序如何执行， 或者说是如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放在哪里。</li></ul><p><img src="/2022/05/08/JVM/image-20220604150735708.png"></p>          </div><h2 id="5-1、虚拟机栈的基本内容"><a href="#5-1、虚拟机栈的基本内容" class="headerlink" title="5.1、虚拟机栈的基本内容"></a>5.1、虚拟机栈的基本内容</h2><p><strong>Java虚拟机栈是什么</strong></p><p>Java虚拟机栈，早期也叫作Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的Java方法调用。</p><p>是线程私有的</p><p><img src="/2022/05/08/JVM/image-20220604150230447.png" alt="栈和栈帧"></p><p><strong>生命周期</strong></p><p>生命周期和线程一致。</p><p><strong>作用</strong></p><p>主管Java程序的运行，他保存方法的局部变量（8种基本数据类型、对象的引用地址），部分结果 ，并参与方法的调用和返回。</p><ul><li>局部变量 vs 成员变量（属性）</li><li>基本数据类型变量 vs 引用类型变量（类、数组、接口）</li></ul><p><strong>栈的特点（优点 ）</strong></p><ul><li><p>栈是一种快速有效的存储方式，访问速度仅次于程序计数器。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈，压栈）</li><li>执行结束后的出栈工作。</li></ul></li><li><p>对于栈来说不存在垃圾回收的问题（但是可能会出现栈溢出的情况）</p></li></ul><p><strong>栈中可能出现的异常</strong></p><ul><li>Java虚拟机栈规范允许<strong>Java栈的大小是动态的或者是固定不变的。</strong><ul><li>如果采用固定的大小，那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机栈将会抛出一个<strong>StackOverflow Error</strong>的异常。</li><li>如果采用的动态扩展，并尝试扩展的时候无法申请到做足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>的异常。</li></ul></li></ul><p><strong>设置栈内存大小</strong></p><ul><li><strong>-Xss数字</strong>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</li></ul><h2 id="5-2、栈的存储单位"><a href="#5-2、栈的存储单位" class="headerlink" title="5.2、栈的存储单位"></a>5.2、栈的存储单位</h2><hr><p><strong>栈</strong></p><p>栈中的数据都是以 <strong>栈帧（Strack Frame）的格式存在。</strong></p><p>在线程中执行的每一个方法都各自对应一个栈帧（Strack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><p><strong>栈运行原理</strong></p><ul><li>栈遵循“先进后出” / “后进先出”的原则。</li></ul><ul><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧，即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，与<code>当前栈帧</code>对应的方法就是<code>当前方法</code>，定义这个方法的类就是<code>当前类</code>。</li><li>执行引擎运行的所有字节码指令只针对<code>当前栈帧</code>进行操作</li><li>如果在该方法中调用了其他方法，对应新的栈帧会被创建出来，放在栈的顶端，成为新的栈帧</li><li>不同线程中所包含的栈帧是不允许相互引用的，在一个栈帧之中不可能引用另外一个线程的栈帧</li></ul><ul><li><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p></li><li><p>对于没有返回值的方法 可以直接写一个 return ; 可以省略</p></li></ul><hr><p><strong>栈帧</strong></p><p>每个栈帧中存储着：</p><ul><li><strong>局部变量表(Local Variables)</strong></li><li><strong>操作数栈(operand Stack)(或表达式栈)</strong></li><li>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</li><li>方法返回地址(Return Address) (或方法正常退出或者异常退出的定义)</li><li>一些附加信息</li></ul><div class="note note-success">            <p>后面三个也被统称为帧数据区</p>          </div> <p><img src="/2022/05/08/JVM/image-20220606093338725.png" alt="栈帧的基本结构"></p><h2 id="5-3、局部变量表"><a href="#5-3、局部变量表" class="headerlink" title="5.3、局部变量表"></a>5.3、局部变量表</h2><p>局部变量表也被称之为局部变量数组或本地变量表</p><ul><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用以及returnAddress类型</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译器确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量的大小的。</li><li><strong>方法嵌套调用的次数由栈的大小决定的，</strong>一般来说， <strong>栈越大，方法嵌套调用次数越多。</strong>局部变量和参数越多，栈帧就越大，进而函数调用就会占用更多的栈空间，导致嵌套调用次数就会减少</li><li><strong>局部变量表中的变量只在当前方法调用中有效。</strong>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li></ul><hr><p><strong>Slot</strong></p><ul><li>局部变量表，最基本的存储单位是<strong>Slot（变量槽）</strong></li><li>局部变量表重存放编译期可知的各种基本数据类型(8种)，引用类型(referrnce)，returnAddress类型的变量</li><li>在局部变量表中，<strong>32位以内的类型只占用一个slot(包括returnAddress类型)，64为的类型(long和double)占用两个slot。</strong></li><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用时，他的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>需要访问局部变量表中一个64bit的局部变量值时，只需要使用<strong>前一个索引</strong>即可。</li><li>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，那么该对象引用this将会存在index为0的slot处，其余参数按照参数表顺序继续排列</li></ul><p><img src="/2022/05/08/JVM/image-20220606153242959.png"></p><div class="note note-success">            <p>为什么静态方法不能使用this？</p><p>因为this变量不存在于当前方法的局部变量表中。</p>          </div><hr><p><strong>Slot的重复利用</strong></p><p><strong>帧栈中的局部变量表中的槽位时可以重用的，</strong>如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会重复过期局部变量的槽位，从而达到 <strong>节省资源的目的。</strong></p><p><img src="/2022/05/08/JVM/image-20220606164211547.png" alt="slot的重复利用"></p><hr><p><strong>静态变量与局部变量的对比</strong></p><p>变量表有两次初始化的机会，第一次在 **”准备阶段”**，执行系统初始化，对类变量设置零值，另一次在 <strong>“初始化”阶段</strong>，赋予程序员在代码中定义的初始值。 </p><p>局部变量不存在系统初始化的过程。    </p><hr><p><strong>补充说明</strong></p><ul><li>在栈桢中，与性能调优最为密切的部分就是局部变量表，方法执行时，虚拟机使用局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或简介引用的对象都不会被回收。</strong></li></ul><h2 id="5-4、操作数栈"><a href="#5-4、操作数栈" class="headerlink" title="5.4、操作数栈"></a>5.4、操作数栈</h2><p>也称为表达式栈，<strong>特点是后进先出，</strong>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，<strong>即入栈(push)/出栈(pop)。</strong></p><ul><li>操作数栈<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈是JVM执行引擎的一个工作区，随着方法的执行而创建，它的长度保存在方法的Code属性中，为max_stack值</li><li>操作数栈并非采用访问索引的方式来进行数据访问，而是通过入栈出栈操作来完成数据访问。</li><li><strong>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中</strong></li></ul><h2 id="5-5、栈顶缓存技术"><a href="#5-5、栈顶缓存技术" class="headerlink" title="5.5、栈顶缓存技术"></a>5.5、栈顶缓存技术</h2><p>因为基于栈架构的虚拟机所使用的零地址更加紧凑，但完成一项指令需要更多的出栈入栈指令，意味着需要更多的指令分派次数和内存读写次数，也就是会影响执行速度，因此，Hotspot JVM设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理cpu寄存器中，以次降低对内存的读写次数，提升效率</strong></p><h2 id="5-6、动态链接-指向运行时常量池的方法引用"><a href="#5-6、动态链接-指向运行时常量池的方法引用" class="headerlink" title="5.6、动态链接(指向运行时常量池的方法引用)"></a>5.6、动态链接(指向运行时常量池的方法引用)</h2><ul><li>每个栈帧内部都包含一个指向<strong>运行时常量池中该栈帧所属方法的引用</strong>，目的是为了支持当前方法的代码能实现<strong>动态链接</strong></li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用，保存在class文件的常量池里，比如，描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><p><strong>常量池的作用：</strong>提供一些符号和常量，便于指令的识别，需要这些常量的时候直接指针指向即可。</p><h2 id="5-7、方法的调用"><a href="#5-7、方法的调用" class="headerlink" title="5.7、方法的调用"></a>5.7、方法的调用</h2><p>JVM中将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p><ul><li><strong>静态链接：</strong>当字节码文件被装载进JVM内部时，<strong>如果被调用的方法在编译器可知，</strong>且运行期 保持不变时，这种情况下的调用称为静态链接</li><li><strong>动态链接：如果被调用的方法在编译期无法被确定下来，</strong>也就是说，只有在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，所以叫做动态链接 </li></ul><p><strong>对应的方法绑定机制为</strong>：早期绑定(目标方法在编译期可知，且运行期保持不变)和晚期绑定(编译期无法被确定下来，只能在程序运行期间确定)，<strong>绑定只发生一次</strong></p><p><strong>对应的方法为</strong>：虚方法和非虚方法</p><ul><li><p>静态方法，私有方法，final方法，实例构造器，父类方法都是<strong>非虚方法</strong></p></li><li><p>其余方法为<strong>虚方法</strong></p></li></ul><p>子类对象的多态性的使用前提：① 类的继承关系 ② 方法的重写</p><p>多态性与非虚方法是对立的。</p><p><strong>虚拟机中提供了几条方法调用指令:</strong></p><ul><li><p>普通调用指令</p><ol><li>invokestatic： 调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial： 调用init方法，私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual： 调用所有虚方法</li><li>invokeinterface： 调用接口方法</li></ol></li><li><p>动态调用指令</p><p>​    5.invokedynamic： 动态解析出需要调用的方法，然后执行</p></li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本，其中<strong>invokestatic和invokespecial指令调用的方法称为非虚方法，其余(final修饰的除外)称为虚方法</strong></p><p><strong>动态语言和静态语言：</strong></p><p>后者是判断遍历自身的类型信息，前者是判断变量值的类型信息，遍历没有类型信息，变量值才有类型信息。</p><hr><p><strong>java语言中方法重写的本质</strong></p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作c</li><li>如果不通过类型c中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过，则返回java.lang.ⅠllegalAccessError异常(非法访问异常(无权访问))</li><li>否则，按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程</li><li>如果始终没有找到，则抛出java.lang.AbstractMethodError异常</li></ol><hr><p><strong>虚方法表</strong></p><p>如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话会影响效率，所以JVM提供了<strong>虚方法表</strong>。</p><p>每个类都有一个自己的虚方法表。 （没重写就去父类中寻找方法）</p><p><img src="/2022/05/08/JVM/image-20220609091203788.png"></p><p>如果Son继承Father，Father继承Object，Father重写hardChoice方法，Son重写了父类Father的hardChoise方法，没有重写的方法都指向Object，因为Father与Son都没有重写过这些方法，所以在虚方法表中直接将未重写的方法直接指向父类的父类。</p><h2 id="5-8、方法返回地址"><a href="#5-8、方法返回地址" class="headerlink" title="5.8、方法返回地址"></a>5.8、方法返回地址</h2><p><strong>方法返回地址中存放着该方法的pc寄存器的值</strong></p><p>方法的借宿有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>方法退出后都会返回到该方法被调用的位置，方法正常退出时，<strong>调用者的pc计数器的值作为返回地址。即调用该方法的指令的下一条指令的地址</strong>，而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</p><p>一个方法开始执行后，只有两种方式可以退出这个方法：</p><ul><li><p>正常完成出口</p><p>返回指令包括ireturn（boolean，byte，char，short，int），lreturn，freturn，dreturn，areturn(引用数据类型)，return(声明为void)</p></li><li><p>异常完成出口</p><p>将一场处理存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p></li></ul><p><img src="/2022/05/08/JVM/image-20220609163921066.png" alt="异常处理表"></p><h2 id="5-9、一些附加信息"><a href="#5-9、一些附加信息" class="headerlink" title="5.9、一些附加信息"></a>5.9、一些附加信息</h2><p>栈帧中还允许携带与java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息</p><h2 id="5-10、相关面试题"><a href="#5-10、相关面试题" class="headerlink" title="5.10、相关面试题"></a>5.10、相关面试题</h2><p><strong>分配的栈内存越大越好么？</strong></p><ul><li>不是，过大的栈内存会影响到其余区域的大小，一个栈的空间大了，内存空间的大小是有限的，一个栈大了，就可能导致线程数变小了。</li></ul><p><strong>垃圾回收是否会涉及到虚拟机栈？</strong></p><ul><li>不会，栈只有进栈，出栈 </li></ul><p><strong>方法中定义的局部变量是否线程安全？</strong></p><ul><li>具体问题具体分析 如果方法内部局部变量没有逃离方法的作用范围它就是安全的，是线程私有的 ，不会产生在多个线程下产生线程干扰。<br>如果局部变量引用了对象，并逃离方法的作用范围，它就不是线程安全的。<br>（例如：参数变量不是线程安全，会被返回得局部变量不是线程安全的，他们都逃离了方法的作用范围）</li></ul><p> <strong>判断线程是否安全？</strong></p><ul><li>如果内部的变量在内部产生且消亡的就安全，如果不是内部产生或者内部产生之后返回到外面就是不安全的</li></ul><h1 id="六、本地方法接口"><a href="#六、本地方法接口" class="headerlink" title="六、本地方法接口"></a>六、本地方法接口</h1><p><strong>什么是本地方法？</strong></p><p>一个本地方法就是一个Java调用非Java代码的接口。</p><p> <strong>为什么要使用本地方法？</strong></p><ul><li><p>与Java环境外交互。（存在的主要原因）</p></li><li><p>与操作系统交互。</p></li><li><p>Sun‘s   Java。</p></li></ul><p><img src="/2022/05/08/JVM/image-20220610111042807.png"></p><h1 id="七、本地方法栈"><a href="#七、本地方法栈" class="headerlink" title="七、本地方法栈"></a>七、本地方法栈</h1><ul><li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法用于管理本地方法的调用</strong></li><li>本地方法栈也是线程私有的</li><li>允许被实现成固定或者是可动态扩展的内存大小(在内存溢出方面是相同的)</li><li>本地方法是用C语言实现的</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库</li></ul><h1 id="八、堆"><a href="#八、堆" class="headerlink" title="八、堆"></a>八、堆</h1><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>一个JVM实例<strong>只存在一个</strong>堆内存，堆也是Java内存管理的核心区域。</li><li>Java堆区在JVM启动时即被创建了，其空间大小也就确定了，是JVM管理的最大一块内存空间。<ul><li>堆空间的大小是可以调节的。</li></ul></li><li>堆可以在<strong>物理上不连续</strong>的内存空间中，但是<strong>逻辑上应该被视为连续</strong>的。</li><li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(TLAB)。</li><li>**”几乎”**所有的对象实例以及数组都应该在运行时分配在堆上。</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向的是对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象<strong>不会马上被移除</strong>，仅仅在垃圾收集的时候才会被移除(意思是不会被马上移除，当堆空间不足之后执行垃圾回收才会移除，如果马上移除的话，gc的频率就会过高)。</li><li>堆是GC(垃圾收集器)执行垃圾回收的重点区域。</li></ul><p><strong>堆空间的细分</strong></p><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</p><ul><li>Java7及之前堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>永久区</strong><ul><li>新生区又被分为eden(伊甸)区和Survivor(幸存者)区 幸存者区又分为幸存者1区(from区)和幸存者2区(to区)</li></ul></li><li>Java8及之后堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>元空间</strong></li><li>新生区&lt;=&gt;新生代&lt;=&gt;年轻代 养老区&lt;=&gt;老年区&lt;=&gt;老年代 永久区&lt;=&gt;永久代</li><li>堆大小=新生区+养老区，元空间或者永久区有他自己的大小</li><li><strong>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>圆圈中最后剩下的数字</title>
    <link href="/2022/05/07/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/05/07/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/07/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/image-20220507154914849.png" alt="圆圈中最后剩下的数字"></p><p><strong>解题思路：</strong></p><p>实际上是<strong>约瑟夫环</strong><a href="https://blog.csdn.net/u011500062/article/details/72855826"> 约瑟夫环——公式法（递推公式）</a></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 最后一轮剩下2个人，所以从2开始反推</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            ans = (ans + m) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和为s的连续正数序列</title>
    <link href="/2022/05/07/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <url>/2022/05/07/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/07/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/image-20220507102513722.png" alt="和为s的连续正数序列"></p><p><strong>解法一：(双指针)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 定义左指针，右指针与左右指针之间的数字的和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 定义结果数组集合</span><br>        ArrayList&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                <span class="hljs-comment">// 遍历 sum == target的时候的i与j之间的元素</span><br>                <span class="hljs-comment">// 并把这些元素添加到res集合中</span><br>                <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[j - i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++) &#123;<br>                    ans[k - i] = k;<br>                &#125;<br>                res.add(ans);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>                sum -= i;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>                sum += j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剪绳子</title>
    <link href="/2022/05/06/%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2022/05/06/%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/06/%E5%89%AA%E7%BB%B3%E5%AD%90/image-20220506200733812.png" alt="剪绳子"></p><p><strong>解法一：(贪心算法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 最优 一根绳子完美的切成多个3 n % 3 == 0</span><br>        <span class="hljs-comment">// 次优 一根绳子切成 多个3与一个2 n % 3 == 2</span><br>        <span class="hljs-comment">// 最差 一根绳子除以3 余数为1 那么一个切法变成 1*3 =&gt; 2*2 n % 3 == 1</span><br>        <span class="hljs-comment">// 3 * 1 &lt; 2 * 2</span><br>        <span class="hljs-comment">// 3是最优的 优先考虑3</span><br><br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断 n 能被几个3整除</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// n 除以三的余数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (Math.pow(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        对于 8 而言</span><br><span class="hljs-comment">        1、8 / 3 = 2</span><br><span class="hljs-comment">        2、8 % 3 = 2</span><br><span class="hljs-comment">        b == 2 所以为 3的二次方*2 也就是 2*3*3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        对于 6 而言</span><br><span class="hljs-comment">        1、6 / 3 = 2</span><br><span class="hljs-comment">        2、6 % 3 = 0</span><br><span class="hljs-comment">        b == 0 所以 3的二次方 也就是 3*3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        对于7而言</span><br><span class="hljs-comment">        1、7 / 3 = 2</span><br><span class="hljs-comment">        2、7 % 3 = 1</span><br><span class="hljs-comment">        b == 1 所以 3的一次方 也就是 3 * 4</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建乘积数组</title>
    <link href="/2022/05/06/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <url>/2022/05/06/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/06/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/image-20220506103032263.png" alt="构建乘积数组"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 上三角的乘</span><br>        <span class="hljs-comment">// 计算上三角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 计算下三角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp *= a[i + <span class="hljs-number">1</span>];<br>            b[i] *= tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="/2022/05/06/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/05/06/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/06/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/image-20220506100232721.png" alt="数组中出现次数超过一半的数字"></p><p><strong>解法一：排序求中点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nums[nums.length/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：摩尔投票法</strong></p><p><strong>摩尔投票法：</strong> 核心理念为 <strong>票数正负抵消</strong> 。此方法时间和空间复杂度分别为 O(N)<em>O</em>(<em>N</em>) 和 O(1)<em>O</em>(1) </p><p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。 核心就是 <strong>对拼消耗</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//上场</span><br>                res = num;<br>            &#125;<br>            <span class="hljs-comment">//如果这个人上场，已经有人了，判断这个人是不是一个国家的</span><br>            <span class="hljs-comment">//是的话就站在一起</span><br>            <span class="hljs-keyword">if</span> (num == res) &#123;<br>                sum++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//不是则和一个同归于尽</span><br>                sum--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后上场已无敌军</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中数字出现的次数Ⅱ</title>
    <link href="/2022/05/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E2%85%A1/"/>
    <url>/2022/05/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E2%85%A1/image-20220505235148555.png" alt="数组中数字出现的次数Ⅱ"></p><p><strong>解法一：哈希表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 哈希表</span><br>        HashMap&lt;Integer, Boolean&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 第一次存进去的数字只出现了一次，所以为false，第二次出现以及以后再出现就是true，所以只出现一次的为false</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.containsKey(num));<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (!map.get(num)) &#123;<br>                res = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：位运算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 位运算</span><br>        <br>        <span class="hljs-comment">// counts 是nums数组中每一个数字转换为二进制之后所在地方有几个1</span><br>        <span class="hljs-type">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j++) &#123;<br>                counts[j] += num &amp; <span class="hljs-number">1</span>;<br>                num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 从nums的第一个数字开始 每遍历一次 num往右移一位</span><br>                <span class="hljs-comment">// 也就是说num从最后一位开始往左判断每一位的1的个数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            res &lt;&lt;= <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 从高位开始对3取余 与 res进行或运算 有1就 res的当前位的二进制变为1</span><br>            <span class="hljs-comment">// 然后res左移开始判断次高位</span><br>            res |= counts[<span class="hljs-number">31</span>-i] % <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中数字出现的次数</title>
    <link href="/2022/05/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/05/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/image-20220505223136880.png" alt="数组中数字出现的次数"></p><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length ; i++) &#123;<br>            res ^= nums[i]; <span class="hljs-comment">// 得到m与n两个只出现一次的数字</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">div</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// &amp;操作都为1结果为1，否则结果为0</span><br>        <span class="hljs-comment">// 从右往左找到第一位为1</span><br>        <span class="hljs-keyword">while</span> ((div &amp; res) == <span class="hljs-number">0</span>) &#123;<br>            div &lt;&lt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// div左移一位</span><br>        &#125;<br><br>        <span class="hljs-comment">// 根据div将数组分为两个数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> ((num &amp; div) != <span class="hljs-number">0</span>) &#123;<br>                a ^= num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b ^= num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;a,b&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：</strong></p><p>​    见<a href="http://www.eliseo.top/2022/05/02/%E5%BC%82%E6%88%96/">异或 - Eliseo的小屋</a>这篇文章进阶</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不用加减乘除做加法</title>
    <link href="/2022/05/05/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <url>/2022/05/05/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/05/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/image-20220505154715941.png" alt="不用加减乘除做加法"></p><p><strong>题解：</strong></p><p><img src="/2022/05/05/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/image-20220505154830988.png" alt="题解1"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当进位为 0 时跳出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// c = 进位</span><br>            a ^= b; <span class="hljs-comment">// a = 非进位和</span><br>            b = c; <span class="hljs-comment">// b = 进位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="/2022/05/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/05/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/image-20220505153708668.png" alt="二进制中1的个数"></p><p><strong>解法：（位运算）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 判断最后一位是不是1</span><br>            res += n &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 无符号为右移</span><br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：(巧用 n &amp; (n-1))</strong></p><p>n&amp;(n-1)运算结果为消去二进制最右边的1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            res++;<br>n = n &amp; (n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2022/05/05/Linux/"/>
    <url>/2022/05/05/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="一、网络连接的三种方式"><a href="#一、网络连接的三种方式" class="headerlink" title="一、网络连接的三种方式"></a>一、网络连接的三种方式</h1><h2 id="1-1、桥接模式"><a href="#1-1、桥接模式" class="headerlink" title="1.1、桥接模式"></a>1.1、桥接模式</h2><p>虚拟系统可以和外部系统<strong>相互</strong>通讯，但是容易造成ip冲突(超过255个机器)</p><h2 id="1-2、NAT模式（网络地址转换模式）"><a href="#1-2、NAT模式（网络地址转换模式）" class="headerlink" title="1.2、NAT模式（网络地址转换模式）"></a>1.2、NAT模式（网络地址转换模式）</h2><p>NAT模式，网络地址转换模式，虚拟系统可以和外部系统<strong>单方面通讯(外部不可以直接访问内部)，</strong>不造成IP冲突，相当于给你虚拟机虚拟一个ip，然后在需要访问外部的时候，自动转换成你母机ip去访问外部</p><h2 id="1-3、主机模式"><a href="#1-3、主机模式" class="headerlink" title="1.3、主机模式"></a>1.3、主机模式</h2><p>可以看作一个独立的系统，不与外界进行联系</p><p><img src="/2022/05/05/Linux/image-20220505162247042.png" alt="网络连接的三种方式"></p><h1 id="二、Linux目录结构"><a href="#二、Linux目录结构" class="headerlink" title="二、Linux目录结构"></a>二、Linux目录结构</h1><p>1、linux的文件系统是采用层级式的树状目录结构，最上层是根目录”/“，然后在此目录下创建其他的目录。</p><p>2、<strong>在Linux的世界里，一切皆文件</strong></p><ul><li><p>/bin (/usr/bin、/usr/local/bin),是Binary的缩写，存放着最常使用的命令<strong>【常用】</strong></p></li><li><p>/sbin 存放的是系统管理员使用的系统管理程序</p></li><li><p>/home 存放普通用户的主目录，在linux中每个用户都有自己的目录<strong>【常用】</strong></p></li><li><p>/root 系统管理员，也成为超级权限者的用户主目录<strong>【常用】</strong></p></li><li><p>/lib 系统开机所需要的最基本的动态连接共享库</p></li><li><p>/lost+found 一般情况是空的，当系统非法关机后，这里就存放了一些文件</p></li><li><p>/etc 所有的系统管理所需要的配置文件和子目录，例如mysql的my.conf<strong>【常用】</strong></p></li><li><p>/usr 用户的很多应用程序和文件都放在这个目录下，类似于windows的program files目录<strong>【常用】！！</strong></p></li><li><p>/boot 存放的是启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件<strong>【常用】</strong></p></li><li><p>/proc 是一个虚拟目录，是系统内存的映射，访问这个目录来获取系统信息<strong>【不能动】</strong></p></li><li><p>/srv service的缩写，存放一些服务启动之后需要提取的数据<strong>【不能动】</strong></p></li><li><p>/sys linux2.6之后出现，安装了一个文件系统sysfs<strong>【不能动】</strong></p></li><li><p>/tmp 用来存放一些临时文件</p></li><li><p>/dev 类似于Windows的设备管理器，把所有的硬件用文件形式存储</p></li><li><p>/media 会自动识别一些例如u盘光驱等设备，识别后就将识别的设备挂载到这目录下<strong>【常用】</strong></p></li><li><p>/mnt 该目录是为了让用户挂载别的文件系统，可以将外部存储挂载在/mnt上，进入该目录查看<strong>【常用】</strong></p></li><li><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p></li><li><p>/opt 给主机额外<strong>安装软件</strong>的目录</p></li><li><p>/usr/local 另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序<strong>【常用】</strong></p></li><li><p>/var 存放一些不断扩张的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件<strong>【常用】</strong></p></li><li><p>/selinux [security-enhanced linux] 是一种安全的子系统，它能控制程序只访问特定文件，有三种工作模式，可以自行设置</p></li></ul><h1 id="三、vi和vim编辑器"><a href="#三、vi和vim编辑器" class="headerlink" title="三、vi和vim编辑器"></a>三、vi和vim编辑器</h1><h2 id="3-1、三种使用模式"><a href="#3-1、三种使用模式" class="headerlink" title="3.1、三种使用模式"></a>3.1、三种使用模式</h2><p><strong>正常模式(命令模式)</strong></p><p>​    以vim打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用「上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。</p><p><strong>插入模式</strong></p><p>​    按下i，I，o，O，a，A，r，R等任何一个字母之后才会进入编辑模式，一般按<strong>i</strong>即可</p><p><strong>命令行模式</strong></p><p>​    输入esc退出当前模式，再输入<code>:</code>进入命令行模式</p><p>​    可以提供相关指令，完成读取，存盘，替换，离开vim显示行号等动作。</p><h2 id="3-2、各种模式的切换"><a href="#3-2、各种模式的切换" class="headerlink" title="3.2、各种模式的切换"></a>3.2、各种模式的切换</h2><p><img src="/2022/05/05/Linux/image-20220505201406877.png" alt="各种模式的切换方式"></p><h2 id="3-3、vim操作"><a href="#3-3、vim操作" class="headerlink" title="3.3、vim操作"></a>3.3、vim操作</h2><p>在一般模式下:</p><ul><li>yy 拷贝当前行；5yy 拷贝当前向下的5行，p 粘贴 u撤销 x删除</li><li>dd 删除当前行；5dd：删除当前向下的5行</li><li>G 文档最末行，gg 最首行</li><li>先输入行号 在输入shift+g 表示移动到多少行</li></ul><p>在命令行模式下:</p><ul><li>wq(保存退出) q(退出) q!(强制退出不保存)</li><li>/关键字 回车 查找某个单词，输入n是查找下一个</li><li>set nu 设置文件的行号，set nonu 取消文件的行号</li></ul><h1 id="四、开机重启与用户登录注销"><a href="#四、开机重启与用户登录注销" class="headerlink" title="四、开机重启与用户登录注销"></a>四、开机重启与用户登录注销</h1><h2 id="4-1、开关机与重启"><a href="#4-1、开关机与重启" class="headerlink" title="4.1、开关机与重启"></a>4.1、开关机与重启</h2><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>立刻进行关机</td></tr><tr><td>shutdown -h 1</td><td>“hello，1分钟后会关机了”</td></tr><tr><td>shutdown -r now</td><td>现在重新启动计算机</td></tr><tr><td>halt</td><td>关机，作用和上面一样</td></tr><tr><td>reboot</td><td>现在重新启动计算机</td></tr><tr><td>sync</td><td>把内存的数据同步到磁盘</td></tr></tbody></table><p><strong>注意细节</strong></p><ul><li>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</li><li>目前的shutdown/reboot/halt等命令均已经在关机前进行了sync，但是还是自己执行一次比较好</li></ul><h2 id="4-2、用户登录和注销"><a href="#4-2、用户登录和注销" class="headerlink" title="4.2、用户登录和注销"></a>4.2、用户登录和注销</h2><p><strong>基本介绍</strong></p><ol><li>登录的时候尽量少使用root账号登录，因为他是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用“su - 用户名” 命令来切换成系统管理员身份</li><li>在提示符下输入logout即可注销用户</li></ol><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>su - 用户名</td><td>切换用户</td></tr><tr><td>logout</td><td>注销用户</td></tr></tbody></table><h1 id="五、Linux用户管理"><a href="#五、Linux用户管理" class="headerlink" title="五、Linux用户管理"></a>五、Linux用户管理</h1><p>linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><h2 id="5-1、用户基本操作"><a href="#5-1、用户基本操作" class="headerlink" title="5.1、用户基本操作"></a>5.1、用户基本操作</h2><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>useradd 用户名</td><td>添加用户，默认该用户的家目录在/home/用户名 下</td></tr><tr><td>useradd -d 指定目录 用户名</td><td>给新创建的用户指定家目录</td></tr><tr><td>useradd -g 用户组 用户名</td><td>增加用户时直接加上组</td></tr><tr><td>passwd 用户</td><td>给某个用户设置密码</td></tr><tr><td>pwd</td><td>显示当前用户所在目录</td></tr><tr><td>userdel 用户名</td><td>删除用户但保留对用home目录</td></tr><tr><td>userdel -r 用户名</td><td>删除用户并且删除对应home目录</td></tr><tr><td>id 用户名</td><td>查询用户信息</td></tr><tr><td>su - 切换的用户名</td><td>切换用户，高权限切换地全选不需要密码，反之需要</td></tr><tr><td>exot/logout</td><td>返回到原来用户</td></tr><tr><td>who am i/ whoami</td><td>查看当前用户，不加空格是当前操作的用户，加空格是第一次登录的用户的信息</td></tr></tbody></table><h2 id="5-2、用户组"><a href="#5-2、用户组" class="headerlink" title="5.2、用户组"></a>5.2、用户组</h2><p><strong>介绍：</strong></p><p>类似于角色，系统可以对有共性/权限的多个用户进行统一的管理，所有在一个组的用户都会有这个组的权限</p><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>groupadd 组名</td><td>新增组</td></tr><tr><td>groupdel 组名</td><td>删除组</td></tr><tr><td>useradd -g 用户组 用户名</td><td>增加用户时直接加上组</td></tr></tbody></table><p>如果直接添加用户而不指定组，则虚拟机会默认创建一个以用户名为名的组并将其放入组中</p><h2 id="5-3、用户和组相关文件"><a href="#5-3、用户和组相关文件" class="headerlink" title="5.3、用户和组相关文件"></a>5.3、用户和组相关文件</h2><ul><li>/etc/passwd 文件</li></ul><p>用户(user)的配置文件，记录用户的各种信息</p><p>每一行都是一个用户：含义: <strong>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录shell</strong></p><ul><li>/etc/shadow文件</li></ul><p>口令配置文件,每行的含义:<strong>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</strong></p><ul><li>/etc/group文件</li></ul><p>组的配置文件，记录linux中组的信息，每行含义:<strong>组名:口令:组标识号:组内用户列表</strong></p><h1 id="六、实用指令"><a href="#六、实用指令" class="headerlink" title="六、实用指令"></a>六、实用指令</h1><h2 id="6-1、运行级别"><a href="#6-1、运行级别" class="headerlink" title="6.1、运行级别"></a>6.1、运行级别</h2><p>运行级别说明</p><ol start="0"><li><p>关机</p></li><li><p>单用户[找回丢失的密码]</p></li><li><p>多用户状态没有网络服务</p></li><li><p>多用户状态有网络服务</p></li><li><p>系统未使用保留给用户</p></li><li><p>图形界面</p></li><li><p>系统重启</p></li></ol><p>常用的运行级别是3和5，也可以指定默认运行级别</p><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>init[0123456]</td><td>切换不同的运行级别</td></tr><tr><td>systemctl get-default</td><td>查看目前的运行级别</td></tr><tr><td>systemctl set-default mult-user.target/systemctl set-default graphical.target</td><td>设置运行级别，前者相当于3，后者相当于5</td></tr></tbody></table><h2 id="6-2、找回root密码-Centos7-6-以后"><a href="#6-2、找回root密码-Centos7-6-以后" class="headerlink" title="6.2、找回root密码(Centos7.6 以后)"></a>6.2、找回root密码(Centos7.6 以后)</h2><ol><li>启动系统，进入开机页面，在页面中按‘e’进入编辑界面 (5s之内)</li><li>进入之后使用键盘的上下键移动光标，找到以“Linux 16”开头所在的行数，在行的最后输入<code>:init=/bin/sh</code></li><li>输入之后按快捷键<code>Ctrl + x</code> 进入单用户模式</li><li>在光标闪烁的位置输入<code>mount -o remount,rw /</code> (单词间有空格)，然后按回车</li><li>在新的一行最后面输入<code>passwd</code>。完成后按回车输入密码，然后再次确认密码即可</li><li>接着在鼠标闪烁的位置输入<code>: touch /.autorelabel</code>(touch 后面有空格),之后继续按回车</li><li>接着在光标闪烁的位置输入 <code>exec /sbin/init</code> 之后按回车键，等待系统修改密码(过程时间有点长)，完成后系统会自动重启</li></ol><h2 id="6-3、帮助指令"><a href="#6-3、帮助指令" class="headerlink" title="6.3、帮助指令"></a>6.3、帮助指令</h2><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>man [命令或配置文件]</td><td>获得帮助信息</td></tr><tr><td>help 命令</td><td>获得shell内置命令的帮助信息</td></tr></tbody></table><h2 id="6-4、文件目录类"><a href="#6-4、文件目录类" class="headerlink" title="6.4、文件目录类"></a>6.4、文件目录类</h2><ul><li><strong>pwd</strong> 显示当前工作目录的绝对路径</li><li><strong>ls</strong> 显示目录:常用选项: <strong>-a</strong>,显示所有，包括隐藏的，**-l** 以列表 <strong>-lh</strong> (h是human的意思)指的是按照人类比较容易看的方式显示</li><li><strong>cd</strong> 定位相对路径或绝对路径 **cd~<strong>回到自己的home目录，</strong>cd..**回到上级目录</li><li><strong>mkdir</strong> 创建目录 mkdir [选项] 要创建的目录 <strong>-p</strong>为创建多级目录</li><li><strong>rmdir</strong> 删除目录 mkdir[选项] 要删除的空目录 ，如果需要删除非空目录，需要使用<strong>rm -rf</strong> 要删除的目录 <strong>-r</strong>表示递归，<strong>f</strong>表示强制删除</li><li><strong>touch</strong> 创建空文件</li><li><strong>cp</strong> 拷贝文件到指令目录 <strong>cp [选项] 文件 指定目录</strong> 选项:<strong>-r</strong> 递归复制整个文件夹 **\cp [选项] 文件 指定目录 ** 强制覆盖不提示</li><li><strong>rm</strong> 移除文件或目录 rm[选项] 要删除的文件或目录，**-r**递归 <strong>-f</strong>强制删除不提示</li><li><strong>mv</strong> 移动文件或重命名 重命名:<strong>mv old文件名 new文件名</strong> 移动: <strong>mv /old位置 /new位置</strong></li><li><strong>cat</strong> 查看文件内容 <strong>-n</strong>显示行号 为了浏览方便一般会加上 <strong>|more</strong></li><li><strong>more</strong> 要查看的文件 ，指令中内置了快捷键，可以独立使用 也可以与<strong>cat</strong>命令一起使用<ul><li>空格键(space) 向下翻一页</li><li>回车键(Enter) 向下翻一行</li><li>q 立刻离开</li><li>Ctrl+f 向下滚动一屏</li><li>Ctrl+B 返回上一屏</li><li>= 输出当前行的行号</li><li>:f 输出文件名和当前行的行号</li></ul></li><li><strong>less</strong> 分屏查看文件内容，与more类似却更加强大，他是懒加载模式<ul><li>空格键(space) 向下翻一页</li><li>下键(pagedown) 向下翻一页</li><li>上建(pageup) 向上翻一页</li><li>/ 向下搜索字串功能 n向下查找；N向上查找</li><li>？ 向上搜索字串功能 n向上查找；N向下查找</li><li>q 立刻离开</li></ul></li><li><strong>echo</strong> 输出内容到控制台，例如要输出环境变量 echo $PATH</li><li><strong>head</strong> 显示文件开头的部分内容，默认十行 <strong>head -n 任意数字</strong>，查看前任意行</li><li><strong>tail</strong> 显示文件中尾部内容，默认十行 <strong>tail -n 任意数字</strong> 查看尾n行 <strong>tail -f</strong> 实时追踪文件更新</li><li><strong>&gt;与&gt;&gt;</strong> 输出重定向(覆盖)和追加 <ul><li>ls -l &gt; 文件 列表的内容写入到文件中(覆盖)</li><li>ls -al &gt;&gt;文件 列表内容追加到文件的末尾</li><li>cat 文件1&gt;文件2 文件1内容覆盖到文件2(覆盖) </li><li>echo “内容” &gt;&gt; 文件 将内容追加到文件末尾</li></ul></li><li><strong>ln</strong> 软连接，也被称为符号链接，类似于Windows的快捷方式 l<strong>n -s [源文件或目录] [软连接名]</strong> 删除软连接<strong>rm</strong>的时候最后不要带上/</li><li><strong>history</strong> 查看已经执行过的历史命令 后面加数字是查看最近的n个命令，查看的命令前会带有参数，可以直接**!+参数**来执行命令</li></ul><h2 id="6-5、时间日期类"><a href="#6-5、时间日期类" class="headerlink" title="6.5、时间日期类"></a>6.5、时间日期类</h2><ul><li>date指令-显示当前日期<ul><li>date          （功能描述：显示当前时间）</li><li>date + %Y   (功能描述：显示当前年份)</li><li>date + %m  (功能描述：显示当前月份)</li><li>date + %d   (功能描述：显示当前是哪一天)</li><li>date  “+%Y-%m-%d %H:%M:%S” (功能描述：显示年月日时分秒)</li><li>date -s 字符串时间 设置日期</li></ul></li><li>cal +选项 查看日历，不加选项默认本月,加了就是参数当年的日历</li></ul><h2 id="6-6、搜索查找类"><a href="#6-6、搜索查找类" class="headerlink" title="6.6、搜索查找类"></a>6.6、搜索查找类</h2><ul><li><p><strong>find</strong>从指定目录<strong>向下递归遍历</strong>其各个子目录，将满足条件的文件或目录显示在终端，<strong>语法:find [搜索范围] [选项]</strong> 选项: -name&lt;查询方式&gt; 按照指定的文件名查找模式查找文件， -user&lt;用户名&gt; 查找属于指定用户名的所有文件 -size&lt;文件大小&gt; 按照指定的文件大小查找文件</p><p><img src="/2022/05/05/Linux/image-20220513203955356.png" alt="应用实例"></p></li><li><p><strong>locate</strong>快速定位文件路径，locate指令利用事先建立的系统中所有文件名称以及路径的locate数据库实现快速定位给定的文件需遍历整个系统，速度较快，但为了保证查询结果的准确度，管理员必须定期更新locate时刻。  <strong>语法：</strong>locate 搜索文件,<strong>执行之前 必须先执行updatedb</strong></p><div class="note note-success">            <p>由于locate指令基于数据库查询，所以第一次查找前必须使用updatedb指令来创建一个新的locate库</p>          </div></li><li><p>which 可以查看某个指令在哪个目录下，比如 ls 指令在哪个目录，which ls</p></li><li><p>grep和管道符”|” 过滤查找，管道符”|”表示<strong>将前一个命令的处理结果输出传递给后面的命令</strong>处理，基本语法: grep [选项] 查找内容，源文件 -n显示匹配行及行号，-i忽略字母大小写</p></li></ul><h2 id="6-7、压缩和解压类"><a href="#6-7、压缩和解压类" class="headerlink" title="6.7、压缩和解压类"></a>6.7、压缩和解压类</h2><ul><li>gzip/gunzip 压缩(压缩成*.gz文件)/解压文件 <ul><li><strong>基本语法：</strong>gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz文件）</li><li><strong>基本语法：</strong>gunzip 文件.gz  （功能描述：解压缩文件命令）</li></ul></li><li>zip/unzip 压缩/解压缩  -r递归压缩， -d&lt;目录&gt; 指定解压后文件存放目录<ul><li><strong>基本语法：</strong>zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）</li><li><strong>基本语法：</strong>unzip [选项] XXX.zip（功能描述：解压缩文件）</li></ul></li><li>tar 压缩和解压缩 ，最后打包的是.tar.gz文件 <ul><li><strong>基本语法：</strong>tar [选项] XXX.tar.gz 打包的内容(功能描述：打包目录，压缩后的文件格式.tar.gz)</li><li>-c 产生.tar打包文件</li><li>-v 显示详细信息</li><li>-f 指定压缩后的文件名</li><li>-z 打包同时压缩/解压 <strong>有x时解压，有c是压缩</strong></li><li>-x 解包.tar文件</li></ul></li></ul><p><img src="/2022/05/05/Linux/image-20220514010601987.png" alt="应用实例"></p><h1 id="七、组管理和权限管理"><a href="#七、组管理和权限管理" class="headerlink" title="七、组管理和权限管理"></a>七、组管理和权限管理</h1><p>在linux中每一个用户都必须属于一个组，不能独立与组外，在linux中每个<strong>文件有所有者、所在组、其他组</strong>的概念。</p><h2 id="7-1、文件-目录-所有者"><a href="#7-1、文件-目录-所有者" class="headerlink" title="7.1、文件/目录 所有者"></a>7.1、文件/目录 所有者</h2><p>一般为文件的创建者，谁创建了该文件，就成为该文件的所有者</p><ul><li><strong>ls -ahl</strong> 查看文件的所有者</li><li><strong>chown 用户名 文件名/目录名</strong> 修改文件/目录所有者</li><li><strong>chown 用户名: 组名 文件/目录</strong> 修改文件/目录的所有者和所在组 <strong>-R递归</strong></li></ul><h2 id="7-2、创建组"><a href="#7-2、创建组" class="headerlink" title="7.2、创建组"></a>7.2、创建组</h2><ul><li>groupadd 组名</li></ul><p><img src="/2022/05/05/Linux/image-20220514012502959.png" alt="应用实例"></p><h2 id="7-3、修改文件-目录所在组"><a href="#7-3、修改文件-目录所在组" class="headerlink" title="7.3、修改文件/目录所在组"></a>7.3、修改文件/目录所在组</h2><p>当一个用户创建了一个文件之后，这个文件的所在组就是该用户所在的组。 </p><ul><li>chgrp 组名 文件名/目录名      【改变所在组】</li></ul><p><img src="/2022/05/05/Linux/image-20220514014231668.png" alt="应用实例"></p><h2 id="7-4、改变用户所在组"><a href="#7-4、改变用户所在组" class="headerlink" title="7.4、改变用户所在组"></a>7.4、改变用户所在组</h2><ul><li>usermod -g 组名 用户名 </li><li>usermod -d 目录名 用户名 改变该用户登陆的初始目录。<strong>特别说明：</strong>用户需要有进入到新目录的权限。</li></ul><h2 id="7-5、权限的基本介绍"><a href="#7-5、权限的基本介绍" class="headerlink" title="7.5、权限的基本介绍"></a>7.5、权限的基本介绍</h2><h3 id="7-5-1、rwx权限"><a href="#7-5-1、rwx权限" class="headerlink" title="7.5.1、rwx权限"></a>7.5.1、rwx权限</h3><p>ls -l 中显示的内容如下：</p><p>-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc</p><p>0-9位说明：</p><ol><li>第0为确定文件类型(d,-,l,c,b)<ol><li><strong>l是链接，</strong>相当于windows的快捷方式</li><li><strong>d是目录</strong>，相当于windows的文件夹</li><li><strong>c是字符设备文件</strong>，鼠标，键盘</li><li><strong>b是块设备</strong>，比如硬盘</li><li>-是普通文件</li></ol></li><li>第1-3位确定所有者(该文件的所有者)拥有该文件的权限。 —User</li><li>第4-6位确定所属组(同用户组的)拥有该文件的权限。 —Group</li><li>第7-9位确定其他用户拥有该文件的权限。 —Other</li></ol><p>1:文件:硬连接数 目录:子目录数(包括隐藏的.和..)+子文件数</p><p>root: 用户</p><p>root: 组</p><p>12123 文件大小(字节)，如果是文件夹，显示4069字节</p><p>feb…：最后修改日期</p><p>abc:文件名</p><h3 id="7-5-2、rwx作用到文件"><a href="#7-5-2、rwx作用到文件" class="headerlink" title="7.5.2、rwx作用到文件"></a>7.5.2、rwx作用到文件</h3><ol><li>[r] 代表可读(read)：可以读取，查看</li><li>[w]代表可读(write)：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件</li><li>[x]代表可以执行(execute)：可以被执行</li></ol><h3 id="7-5-3、rwx作用到目录"><a href="#7-5-3、rwx作用到目录" class="headerlink" title="7.5.3、rwx作用到目录"></a>7.5.3、rwx作用到目录</h3><ol><li>[r] 代表可读(read)：可以读取，可以ls显示目录内容</li><li>[w]代表可读(write)：可以修改，可以在该目录中创建+删除+重命名目录中的文件</li><li>[x]代表可以执行(execute)：可以进入该目录 (意思是可以cd到目录，但不可以ls目录，如果对目录下的文件有修改功能，也是可以 修改的)</li></ol><h3 id="7-5-4、修改权限-chmod"><a href="#7-5-4、修改权限-chmod" class="headerlink" title="7.5.4、修改权限-chmod"></a>7.5.4、修改权限-chmod</h3><p>通过chomd指令，可以修改文件或者目录的权限，权限可用数字表示，r为4，w为2，x为1。</p><ul><li><p>+、-、+变更权限</p><ul><li> u为所有者,g为所在组,o为其他人</li><li>1、chmod u=rwx,g=rx,o=x 文件/目录</li><li>2、chmod o+w 文件/目录名</li><li>3、chmod a-x 文件/目录名</li></ul></li><li><p>通过数字变更权限</p><ul><li>r=4 w=2 x=1 r+w+x=4+2+1=7</li><li>chmod u=rwx,g=rx,o=x 文件/目录相当于chmod 751 文件/目录</li></ul></li></ul><h1 id="八、定时任务调度"><a href="#八、定时任务调度" class="headerlink" title="八、定时任务调度"></a>八、定时任务调度</h1><h2 id="8-1、crond任务调度"><a href="#8-1、crond任务调度" class="headerlink" title="8.1、crond任务调度"></a>8.1、crond任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p><p>任务调度分类：系统工作：有些重要的工作必须<strong>周而复始</strong>地执行。如病毒扫描。</p><p>个别用户工作：个别用户可能希望执行某些程序，比如mysql程序的备份</p><ul><li><p>基本语法： <strong>crontab [选项]</strong>  <strong>service crond restart [重启任务调度]</strong></p></li><li><p>常用选项</p><ul><li>-e    编辑crontab定时任务</li><li>-l     查询crontab任务</li><li>-r    删除当前用户所有的crontab任务</li></ul></li></ul><p><strong>快速入门：</strong></p><p>​    设置任务调度文件：/etc/crontab</p><p>​    设置个人任务调度。执行crontab -e命令。</p><p>​    接着输入任务到调度文件</p><p>如：*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt（将etc目录下的内容显示出来 然后重定向到/tmp/to.txt中）</p><p>意思是：每小时的每分钟执行ls -l /etc/ &gt; /tmp/to.txt命令</p><p>占位符：</p><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个 ”*“</td><td>一小时当中的第几分钟</td><td>0~59</td></tr><tr><td>第二个 ”*“</td><td>一天当中的第几小时</td><td>0~23</td></tr><tr><td>第三个 ”*“</td><td>一个月当中的第几天</td><td>1~31</td></tr><tr><td>第四个 ”*“</td><td>一年当中的第几个月</td><td>1~12</td></tr><tr><td>第五个 ”*“</td><td>一周当中的星期几</td><td>0~7(0和7都代表星期日)</td></tr></tbody></table><p>特殊符号说明</p><table><thead><tr><th align="left">特殊符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">代表任何时间，比如第一个*代表一小时中的每一分钟都执行一次的意思</td></tr><tr><td align="left">，</td><td align="left">代表不连续的时间，比如“0 8,12,16 * * *”代表每天的8:00,12:00,16:00都会执行</td></tr><tr><td align="left">-</td><td align="left">代表连续的时间范围，如“0 5 * * 1-6”代表周一到周六的凌晨5:00执行命令</td></tr><tr><td align="left">*/n</td><td align="left">代表每隔多久执行一次,如“*/10 * * * *”代表每隔十分钟执行一次命令</td></tr></tbody></table><p><img src="/2022/05/05/Linux/image-20220515233916791.png" alt="特殊时间执行任务案例"></p><p><img src="/2022/05/05/Linux/image-20220516002043141.png" alt="crond任务调度应用实例"></p><h2 id="8-2、at定时任务"><a href="#8-2、at定时任务" class="headerlink" title="8.2、at定时任务"></a>8.2、at定时任务</h2><ul><li>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行</li><li>默认情况atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</li><li>at命令是一次性定时计划任务，执行完一个任务后就不再执行此任务了</li><li>在使用at命令的时候，一定要保证atd进行的启动</li></ul><ul><li><strong>at [选项] [时间]</strong> ctrl+D代表命令输入结束(需要输入<strong>两次</strong>) 如果输入错误 摁 Ctrl+backspace删除</li><li><strong>atq</strong> 列出所有的任务</li><li><strong>atrm 编号</strong> 删除指定任务</li></ul><p><strong>at命令选项：</strong></p><p><img src="/2022/05/05/Linux/image-20220516151338972.png" alt="at命令选项"></p><p><strong>at时间定义：</strong></p><p><img src="/2022/05/05/Linux/image-20220516151228718.png" alt="at时间定义"></p><h1 id="九、磁盘分区与挂载"><a href="#九、磁盘分区与挂载" class="headerlink" title="九、磁盘分区与挂载"></a>九、磁盘分区与挂载</h1><h2 id="9-1、linux分区"><a href="#9-1、linux分区" class="headerlink" title="9.1、linux分区"></a>9.1、linux分区</h2><p>linux只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分</p><p>linux采用了一种叫”载入”的处理方法，他的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使得它的存储空间在一个目录下获得</p><p><img src="/2022/05/05/Linux/image-20220516164213813.png" alt="示意图"></p><h2 id="9-2、linux硬盘"><a href="#9-2、linux硬盘" class="headerlink" title="9.2、linux硬盘"></a>9.2、linux硬盘</h2><p>硬盘说明：</p><p>​    1、linux分为IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p><p>​    2、对于IDE硬盘，驱动器标识符为“hdx~”，hd表示分区所在设备的类型，”x“为盘号(a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘)，” ~ “代表分区，前四个分区用数字1到4表示，他们是主分区或扩展分区，从5开始就是逻辑分区。</p><p>​    3、对于SCSI硬盘，驱动器标识符为“sdx~”，其余和IDE硬盘的表示方法一样</p><p><strong>指令：</strong></p><ul><li><strong>lsblk 或者 lsblk -f</strong> 查看所有设备挂载情况</li><li><strong>fdisk</strong> 分区<ul><li><strong>m</strong>显示命令列表；</li><li><strong>p</strong>显示磁盘分区，同<strong>fdisk -l</strong>；</li><li><strong>n</strong>新增分区，</li><li><strong>d</strong>删除分区，</li><li><strong>w</strong>写入并退出；</li><li><strong>分区操作：</strong>开始分区后<strong>输入n</strong>，新增分区，然后<strong>选择p</strong>，分区类型为主分区。<strong>两次回车</strong>默认剩余全部空间，最后<strong>输入w写入分区并退出，若不保存退出输入q</strong></li></ul></li><li><strong>mkfs [选项] [-t 分区格式(ext4)] 分区路径</strong> 格式化分区</li><li><strong>mount 设备名称 挂载目录</strong> 挂载分区</li><li><strong>umount 设备名称 或者 挂载目录</strong> 卸载分区</li></ul><p>使用命令行挂载之后，重启之后会失效</p><ul><li><strong>永久挂载：</strong>修改/etc/fstab实现挂载，添加完成之后，执行mount -a 即刻生效</li></ul><div class="note note-success">            <p>使用命令行挂载之后，重启之后会失效</p>          </div><p><strong>虚拟机增加硬盘步骤</strong></p><p>1、在菜单中选择设置，在设备列表里添加硬盘，然后一直下一步。</p><p>2、使用分区命令开始分区。</p><p><img src="/2022/05/05/Linux/image-20220517170419032.png"></p><p>3、格式化磁盘</p><p>4、使用命令进行挂载，但是<strong>重启以后会失效</strong></p><p>5、永久挂载，通过修改/etc/fstab 实现，添加完成以后，执行mount -a即刻生效</p><h2 id="9-3-、磁盘情况查询"><a href="#9-3-、磁盘情况查询" class="headerlink" title="9.3 、磁盘情况查询"></a>9.3 、磁盘情况查询</h2><ul><li><p><strong>df -h</strong> 查询系统整体磁盘使用情况</p></li><li><p><strong>du -h /目录</strong> 查询指定目录的磁盘占用情况，默认为当前目录</p><ul><li><strong>-s</strong>指定目录占用大小汇总</li><li><strong>-h</strong>带计量单位</li><li><strong>-a</strong>含文件</li><li><strong>–max-depth=1</strong> 子目录深度</li><li><strong>-c</strong> 列出明细的同时，增加汇总值</li></ul><p><img src="/2022/05/05/Linux/image-20220517162700644.png" alt="应用实例"></p><p><img src="/2022/05/05/Linux/image-20220517163733675.png" alt="工作实用指令"></p></li></ul><h1 id="十、网络配置"><a href="#十、网络配置" class="headerlink" title="十、网络配置"></a>十、网络配置</h1><p><img src="/2022/05/05/Linux/image-20220517170824281.png" alt="原理图"></p><ul><li><strong>ipconfig</strong>查看windows的VMnet8网络配置</li><li><strong>ifconfig</strong>查看linux的配置 </li><li><strong>ping 目的主机</strong> 测试当前服务器是否可以连接目的主机</li></ul><p>只要在一个网段可以ping通，那么说明了他们可以互相通讯</p><h2 id="10-1、linux网络环境配置"><a href="#10-1、linux网络环境配置" class="headerlink" title="10.1、linux网络环境配置"></a>10.1、linux网络环境配置</h2><p><strong>如何获取ip？</strong></p><p>第一种方式(自动获取)：通过界面的来设置自动获取ip，特点：linux启动后会自动获取IP，缺点：每次获取的ip可能不一样</p><p>第二种方式(指定ip)：直接修改配置文件来指定IP，并可以连接到外网(程序员推荐)。</p><p>方法： 编辑 vi /etc/sysconfig/network-scripts/ifcfg-ens33  </p><p>要求：将ip地址配置的静态的</p><p><img src="/2022/05/05/Linux/image-20220518154349391.png" alt="ifcfg-ens33 文件说明"></p><p>重启网络服务或者重启系统生效</p><p><strong>service newwork restart 或者 reboot</strong></p><h2 id="10-2、设置主机名和hosts映射"><a href="#10-2、设置主机名和hosts映射" class="headerlink" title="10.2、设置主机名和hosts映射"></a>10.2、设置主机名和hosts映射</h2><p><strong>设置主机名</strong></p><ol><li><strong>hostname</strong> 查看主机名</li><li>修改文件在 /etc/hostname 指定</li><li>修改后，重启生效</li></ol><p><strong>设置hosts映射</strong></p><p>windows中 在<strong>C:\Windows\System32\drivers\etc\hosts</strong>中指定</p><p>linux中 在 <strong>/etc/hosts</strong> 文件中指定</p><p><strong>应用实例：用户在浏览器中输入了<a href="http://www.baidu.com/">www.baidu.com</a></strong></p><p>1、浏览器先检查浏览器缓存中有没有该域名解析ip地址，有就调用这个IP完成解析，如果没有就检查DNS解析器缓存，如果有则直接返回IP完成解析。这两个缓存可以理解为本地解析器缓存</p><p>2、一般来说当电脑第一次成功访问某网站，在一定时间内，浏览器或操作系统会缓存它的ip地址(DNS解析记录)如在cmd窗口中输入 ipconfig/displaydns 表示DNX域名解析缓存，ipconfig/flushdns表示手动清理DNS缓存</p><p>3、如果本地解析器没有找到对应映射，检查系统中hosts文件中有没有配置对应的ip映射，如果有，则完成解析并缓存</p><p>4、如果均没有，则到域名服务DNS进行解析域</p><p><img src="/2022/05/05/Linux/image-20220520162025078.png" alt="示意图"></p><h1 id="十一、进程管理"><a href="#十一、进程管理" class="headerlink" title="十一、进程管理"></a>十一、进程管理</h1><h2 id="11-1、进程管理"><a href="#11-1、进程管理" class="headerlink" title="11.1、进程管理"></a>11.1、进程管理</h2><p><strong>基本介绍：</strong></p><p>1、在linux中，每个<strong>执行的程序</strong>都被称为一个进程，每一个进程都分配一个ID号(pid，进程号)。</p><p>2、每个进程都可以以 <strong>前台和后台</strong> 两种方式存在，前台在屏幕上可以看见，后台在屏幕上看不见。</p><p>3、一般系统的服务都是以后台进程的方式存在，而且会常驻在系统中，直到关机才结束。</p><h3 id="11-1-1、查看进程"><a href="#11-1-1、查看进程" class="headerlink" title="11.1.1、查看进程"></a>11.1.1、查看进程</h3><ul><li><strong>ps [选项]</strong> 查看当前系统中，有哪些正在执行，以及他们的执行情况。 <strong>可以不加参数</strong><ul><li>ps -a 显示当前终端中所有的进程信息 </li><li>ps -u 以用户的格式显示进程信息</li><li>ps -x 显示后台进程运行的参数</li><li>ps -e 显示所有进程</li><li>ps -f 全格式</li></ul></li></ul><p><img src="/2022/05/05/Linux/image-20220521100851299.png" alt="ps显示的信息选项"></p><p><img src="/2022/05/05/Linux/image-20220521112337811.png"></p><p><strong>ps详解：</strong></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>用户信息</td></tr><tr><td>PID</td><td>进程号</td></tr><tr><td>TTY</td><td>完整的终端名称</td></tr><tr><td>TIME</td><td>CPU时间，即进程使用CPU的总时间</td></tr><tr><td>CMD</td><td>启动进程所用的命令和参数</td></tr><tr><td>%CPU</td><td>进程占用CPU的百分比</td></tr><tr><td>%MEM</td><td>进程占用物理内存的百分比</td></tr><tr><td>VSZ</td><td>进程占用的虚拟内存大小(单位：KB)</td></tr><tr><td>RSS</td><td>进程占用的物理内存大小(单位：KB)</td></tr><tr><td>TT</td><td>终端名称，缩写</td></tr><tr><td>STAT</td><td>进程状态，S-睡眠 s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止</td></tr><tr><td>STARTED</td><td>进程的启动时间</td></tr><tr><td>C</td><td>CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低;数值越小，表明进程是I/O密集型运算，执行优先级会提高</td></tr><tr><td>COMMAND</td><td>启动进程所用的命令和参数。过长会被截断</td></tr></tbody></table><h3 id="11-1-2、终止进程"><a href="#11-1-2、终止进程" class="headerlink" title="11.1.2、终止进程"></a>11.1.2、终止进程</h3><ul><li><strong>kill [选项] 进程号</strong> 通过进程号杀死进程</li><li><strong>killall 进程名称</strong> 通过进程名称杀死进程，也支持通配符<ul><li>-9 表示强迫进程立即停</li></ul></li></ul><p><img src="/2022/05/05/Linux/image-20220522162804784.png" alt="应用实例"></p><h3 id="11-1-3、查看进程树"><a href="#11-1-3、查看进程树" class="headerlink" title="11.1.3、查看进程树"></a>11.1.3、查看进程树</h3><ul><li><strong>pstree [选项]</strong> 可以更加直观的来看进程信息<ul><li>-p：显示进程的PID</li><li>-u：显示进程的所属用户</li></ul></li></ul><p><img src="/2022/05/05/Linux/image-20220522163701710.png" alt="应用实例"></p><h2 id="11-2、服务-service-管理"><a href="#11-2、服务-service-管理" class="headerlink" title="11.2、服务(service)管理"></a>11.2、服务(service)管理</h2><p>本质就是进程，但是是运行在后台的，同城会监听某个端口，等待其他程序的请求，所以又称为守护进程</p><ul><li><strong>service 服务名 [start| stop | restart | reload | status]</strong> </li><li>但是 在CentOS7.0之后，很多服务不再使用<strong>service</strong>，而是<strong>systemctl</strong></li><li>被service指令管理的服务在 /etc/init.d查看</li></ul><p><img src="/2022/05/05/Linux/image-20220522170720300.png"></p><h3 id="11-2-1、查看服务名"><a href="#11-2-1、查看服务名" class="headerlink" title="11.2.1、查看服务名"></a>11.2.1、查看服务名</h3><ul><li><strong>setup 选择 系统服务</strong>查看全部服务</li><li><strong>ls -l /etc/init.d/</strong> 看到service指令管理的服务</li></ul><h3 id="11-2-2、查看运行级别"><a href="#11-2-2、查看运行级别" class="headerlink" title="11.2.2、查看运行级别"></a>11.2.2、查看运行级别</h3><table><thead><tr><th align="left">运行级别</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0级</td><td align="left">系统停机状态，系统默认的运行级别不能设为0，否则不能正常启动</td></tr><tr><td align="left">1级</td><td align="left">单用户工作状态，root权限，用于系统维护，禁止远程登录</td></tr><tr><td align="left">2级</td><td align="left">多用户状态(没有NFS),不支持网络</td></tr><tr><td align="left">3级</td><td align="left">完全的多用户状态(有NFS)，登陆后进入控制台命令行模式**(常用)**</td></tr><tr><td align="left">4级</td><td align="left">系统未使用，保留</td></tr><tr><td align="left">5级</td><td align="left">x11控制台，登陆后进入图像GUI模式**(常用)**</td></tr><tr><td align="left">6级</td><td align="left">系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</td></tr></tbody></table><h5 id="linux开机流程"><a href="#linux开机流程" class="headerlink" title="linux开机流程"></a>linux开机流程</h5><p>开机 =&gt; BIOS =&gt; /boot =&gt; system进程1 =&gt; 运行级别 =&gt; 运行级对应的服务</p><table><thead><tr><th>命令</th><th>用法</th></tr></thead><tbody><tr><td>systemctl get-default</td><td>查看目前的运行级别</td></tr><tr><td>systemctl set-default mult-user.target/systemctl set-default graphical.target</td><td>设置运行级别，前者相当于3，后者相当于5</td></tr></tbody></table><h3 id="11-2-3、chkconfig指令"><a href="#11-2-3、chkconfig指令" class="headerlink" title="11.2.3、chkconfig指令"></a>11.2.3、chkconfig指令</h3><ul><li>可以给服务的各个运行级别设置自 启动/关闭</li><li>chkconfig 指令管理的服务在 /etc/init.d 查看</li><li><strong>chkconfig –list [| grep XXX]</strong> 查看服务</li><li><strong>chkconfig 服务名 –list</strong> 查看某一项服务</li><li>**chkconfig –level 5 服务名 on/off ** 将某一个服务在某一个指定的运行级别下是自启动还是关闭自启动</li><li>chkconfig 重新设置服务后自启动或关闭 需要<strong>reboot</strong>生效</li></ul><h3 id="11-2-4、systemctl-管理指令"><a href="#11-2-4、systemctl-管理指令" class="headerlink" title="11.2.4、systemctl 管理指令"></a>11.2.4、systemctl 管理指令</h3><ul><li><strong>systemctl [start| stop | restart | status] 服务名</strong> </li><li>systemctl指令管理的服务在 /usr/lib/systemd/system查看</li><li><strong>systemctl list-unit-files | grep 服务名</strong>查看服务开机启动状态 grep可以进行过滤</li><li><strong>systemctl enable 服务名</strong> 设置服务开机启动（自动默认在运行级别3和5都实现）</li><li><strong>systemctl disable 服务名</strong> 关闭服务开机启动（自动默认在运行级别3和5都实现）</li><li><strong>systemctl is-enable 服务名</strong> 查询某个服务是否是自启动 </li><li>以上的方式只是临时生效，如果要永久生效那么使用 <strong>ststemctl [enable|disable] 服务名</strong></li></ul><h3 id="11-2-5、打开与关闭指定端口"><a href="#11-2-5、打开与关闭指定端口" class="headerlink" title="11.2.5、打开与关闭指定端口"></a>11.2.5、打开与关闭指定端口</h3><ul><li><strong>firewall-cmd –permanent -add-port=端口号/协议</strong> 打开端口</li><li><strong>firewall-cmd –permanent -remove-port=端口号/协议</strong> 关闭端口</li><li> <strong>firewall-cmd –reload</strong>重新载入才能生效</li><li><strong>firewall-cmd –query-port=端口号/协议</strong> 查询端口是否开放</li><li><strong>netstat -anp | more</strong> 可以查询出来端口号对应的协议</li></ul><h2 id="11-3、动态监控进程"><a href="#11-3、动态监控进程" class="headerlink" title="11.3、动态监控进程"></a>11.3、动态监控进程</h2><ul><li><p><strong>top [选项]</strong></p><ul><li><strong>-d 秒数</strong> 指定top命令几秒更新 默认是3s</li><li><strong>-i</strong> 使top不显示任何闲置或者僵死进程<ul><li><strong>-p</strong> 通过指定监控进程id来仅仅监控某个进程的状态</li></ul></li></ul></li><li><p><strong>top交互操作说明</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table></li></ul><h2 id="11-4、监控网络状态"><a href="#11-4、监控网络状态" class="headerlink" title="11.4、监控网络状态"></a>11.4、监控网络状态</h2><ul><li><strong>netstat [选项]</strong><ul><li><strong>-an</strong> 按一定顺序排列输出</li><li><strong>-p</strong> 显示那个进程在调用</li></ul></li></ul><h1 id="十二、RPM与YUM"><a href="#十二、RPM与YUM" class="headerlink" title="十二、RPM与YUM"></a>十二、RPM与YUM</h1><h2 id="12-1、rpm包的管理"><a href="#12-1、rpm包的管理" class="headerlink" title="12.1、rpm包的管理"></a>12.1、rpm包的管理</h2><p><strong>介绍：</strong>npm用于互联网下载包的打包及安装工具，RPM是RedHat Package Manager(RedHat软件包管理工具）的缩写</p><h3 id="12-1-1、安装rpm包"><a href="#12-1-1、安装rpm包" class="headerlink" title="12.1.1、安装rpm包"></a>12.1.1、安装rpm包</h3><ul><li><strong>rpm -qa|grep xx</strong> 查询已安装的rpm列表</li><li><strong>rpm -qa</strong> 查询安装的所有rpm软件包</li><li><strong>rpm -q 软件包名</strong> 查询软件包是否安装</li><li><strong>rpm -qi 软件包名</strong> 查询软件包信息</li><li><strong>rpm -ql 软件包名</strong> 查询软件包中的文件</li><li><strong>rpm -qf 文件全路径名</strong> 查询文件所属的软件包</li></ul><p><img src="/2022/05/05/Linux/image-20220526111715774.png" alt="rpm包名基本格式"></p><h3 id="12-1-2、卸载rpm包"><a href="#12-1-2、卸载rpm包" class="headerlink" title="12.1.2、卸载rpm包"></a>12.1.2、卸载rpm包</h3><ul><li><strong>rpm -e RPM包的名称</strong> 卸载rpm包<ul><li><strong>rpm -e –nodeps RPM包的名称</strong> 强行卸载</li></ul></li><li><strong>rpm -ivh RPM包全路径名称</strong> 安装rpm包<ul><li><strong>i=install</strong> 安装</li><li><strong>v=verbose</strong>提示</li><li><strong>h=hash</strong>进度条</li></ul></li></ul><h2 id="12-2、yum"><a href="#12-2、yum" class="headerlink" title="12.2、yum"></a>12.2、yum</h2><ul><li><strong>yum list | grep xx软件列表</strong> 查询yum服务器是由有需要安装的软件</li><li><strong>yum install xxx</strong> 下载安装指定的yum包</li></ul><h1 id="十三、搭建JavaEE环境"><a href="#十三、搭建JavaEE环境" class="headerlink" title="十三、搭建JavaEE环境"></a>十三、搭建JavaEE环境</h1><p>我们需要 <strong>idea tomcat mysql jdk</strong> 四个软件</p><h2 id="13-1、安装JDK"><a href="#13-1、安装JDK" class="headerlink" title="13.1、安装JDK"></a>13.1、安装JDK</h2><p><img src="/2022/05/05/Linux/image-20220527170320229.png" alt="JDK的安装步骤"></p><h2 id="13-2、安装tomcat"><a href="#13-2、安装tomcat" class="headerlink" title="13.2、安装tomcat"></a>13.2、安装tomcat</h2><p><img src="/2022/05/05/Linux/image-20220527180809385.png" alt="tomcat的安装步骤"></p><h2 id="13-3、安装idae"><a href="#13-3、安装idae" class="headerlink" title="13.3、安装idae"></a>13.3、安装idae</h2><p><img src="/2022/05/05/Linux/image-20220527185615325.png" alt="idea的安装步骤"></p><h2 id="13-4、安装mysql5-7"><a href="#13-4、安装mysql5-7" class="headerlink" title="13.4、安装mysql5.7"></a>13.4、安装mysql5.7</h2><ol><li><p>新建文件夹/opt/mysql，并cd进去</p></li><li><p>运行wget <a href="http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar%EF%BC%8C%E4%B8%8B%E8%BD%BDmysql%E5%AE%89%E8%A3%85%E5%8C%85">http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar，下载mysql安装包</a> <strong>ps：wget命令是 linux下可以通过网络直接获取一个文件或者软件的命令</strong></p><p>PS：centos7.6自带的类mysql数据库是mariadb，会跟mysql冲突，要先删除。</p></li><li><p>运行<strong>tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</strong> </p></li><li><p>运行<strong>rpm -qa|grep mari</strong>，查询mariadb相关安装包</p></li></ol><p><img src="/2022/05/05/Linux/wps1.jpg" alt="img"> </p><ol start="5"><li><p>运行<strong>rpm -e –nodeps mariadb-libs</strong>，卸载</p></li><li><p>然后开始真正安装mysql，依次运行以下几条</p></li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs she">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><ol start="7"><li><p>运行<strong>systemctl start mysqld.service</strong>，启动mysql</p></li><li><p>然后开始设置root用户密码</p></li></ol><p>Mysql自动给root用户设置随机密码，运行<strong>grep “password” /var/log/mysqld.log</strong>可看到当前密码</p><p><img src="/2022/05/05/Linux/wps2.jpg" alt="img"> </p><ol start="9"><li><p>运行<strong>mysql -u root  -p</strong>，用root用户登录，提示输入密码可用上述的，可以成功登陆进入mysql命令行</p></li><li><p>设置root密码，对于个人开发环境，如果要设比较简单的密码（<strong>生产环境服务器要设复杂密码</strong>），可以运行<strong>set global validate_password_policy=0</strong>;  提示密码设置策略</p></li></ol><p>（validate_password_policy默认值1，）</p><p><img src="/2022/05/05/Linux/wps3.jpg" alt="img"> </p><ol start="11"><li><strong>set password for ‘root‘@’localhost’ =password(‘hspedu100’)</strong>;</li><li>运行<strong>flush privileges</strong>;使密码设置生效</li></ol><h1 id="十四、Shell编程"><a href="#十四、Shell编程" class="headerlink" title="十四、Shell编程"></a>十四、Shell编程</h1><h2 id="14-1、Shell是什么"><a href="#14-1、Shell是什么" class="headerlink" title="14.1、Shell是什么"></a>14.1、Shell是什么</h2><p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发生请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p><p><img src="/2022/05/05/Linux/image-20220531091236826.png" alt="示意图"></p><h2 id="14-2、Shell脚本的执行方式"><a href="#14-2、Shell脚本的执行方式" class="headerlink" title="14.2、Shell脚本的执行方式"></a>14.2、Shell脚本的执行方式</h2><p><strong>脚本格式要求：</strong></p><p>1、脚本以 <strong>#!/bin/bash</strong> 开头</p><p>2、脚本需要有可执行权限</p><p><strong>脚本的常用执行方式</strong></p><p>方式1：(输入脚本的绝对路径或相对路径)</p><p><strong>说明：</strong>首先要赋予hellowordl.sh脚本的+x权限，在执行脚本</p><p>方式2：(sh+脚本)</p><p><strong>说明：</strong>不用赋予脚本+x权限，直接执行即可。</p><p><img src="/2022/05/05/Linux/image-20220531092746464.png"></p><h2 id="14-3、Shell的变量"><a href="#14-3、Shell的变量" class="headerlink" title="14.3、Shell的变量"></a>14.3、Shell的变量</h2><hr><p><strong>Shell变量介绍</strong></p><p>1、分为系统变量和用户自定义变量</p><p>2、系统变量：$HOME、$PWD、$SHELL、$USER等</p><p>3、显示当前shell中所有变量：set</p><hr><p><strong>shell变量的定义</strong></p><p><strong>基本语法：</strong><br>1、定义变量：变量名=值(不能打空格)</p><p>2、撤销变量：unset 变量</p><p>3、声明静态变量：readonly变量，<strong>注意：不能unset</strong></p><p>4、输出变量：echo $变量名 或者echo 变量名=$变量名 或者echo “变量名=$变量名”；第一个输出结果为 变量名的值，后两个输出结果一样 都是 变量名=值</p><p><strong>定义变量的规则：</strong></p><p>1、变量名称可以有字母、数字、下划线组成，但是不能以数字开头</p><p>2、等号两侧不能有空格</p><p>3、变量名称一般习惯为大写，这是一个规范，也就是说哪怕定义的是小写也不会报错，但是 <code>不好</code></p><p><strong>将命令的返回值赋给变量</strong></p><p>1、A=`date`反引号，运行里面的命令，并且把结果返回给变量A，如果不加反引号，那么就是将date单词赋给A。</p><p>2、A=$(date) 等价于反引号</p><h2 id="14-4、设置环境变量"><a href="#14-4、设置环境变量" class="headerlink" title="14.4、设置环境变量"></a>14.4、设置环境变量</h2><p><strong>基本语法：</strong></p><table><thead><tr><th>语法</th><th>功能描述</th></tr></thead><tbody><tr><td>export 变量名=变量值</td><td>将shell变量输出为环境变量</td></tr><tr><td>source 配置文件</td><td>让修改后的配置信息立即生效</td></tr><tr><td>echo $变量名</td><td>查询环境变量的值</td></tr></tbody></table><p><img src="/2022/05/05/Linux/image-20220531100854207.png"></p><p><strong>快速入门：</strong></p><p>1、在/etc/profile文件中定义TOMCAT_HOME环境变量</p><p>2、查看环境变量TMOCAT_HOME的值</p><p>3、在另外一个shell程序中使用TOMCAT_HOME</p><p><code>注意：</code>在输出TOMCA_HOME环境变量前，需要让其生效 <strong>source /etc/profile</strong></p><p> 4、shell脚本的多行注释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">:&lt;&lt;! <br>内容<br>!<br></code></pre></td></tr></table></figure><h2 id="14-5、位置参数变量"><a href="#14-5、位置参数变量" class="headerlink" title="14.5、位置参数变量"></a>14.5、位置参数变量</h2><p><strong>介绍：</strong></p><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。</p><p><strong>基本语法：</strong></p><table><thead><tr><th>语法</th><th>功能描述</th></tr></thead><tbody><tr><td>$n</td><td>n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}</td></tr><tr><td>$*</td><td>这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</td></tr><tr><td>$@</td><td>这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</td></tr><tr><td>$#</td><td>这个变量代表命令行中所有参数的个数</td></tr></tbody></table><p><strong>应用实例：</strong></p><p><img src="/2022/05/05/Linux/image-20220531111350241.png" alt="shell脚本实现"></p><p><img src="/2022/05/05/Linux/image-20220531111318576.png" alt="运行截图"></p><h2 id="14-6、预定义变量-了解即可"><a href="#14-6、预定义变量-了解即可" class="headerlink" title="14.6、预定义变量(了解即可)"></a>14.6、预定义变量(了解即可)</h2><p><strong>基本介绍：</strong></p><p>就是shell设计者实现已经定义好的变量，可以直接在shell脚本中使用</p><p><strong>基本语法：</strong></p><table><thead><tr><th>语法</th><th>功能描述</th></tr></thead><tbody><tr><td>$$</td><td>当前进程的进程号(PID)</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的进程号(PID)</td></tr><tr><td>$?</td><td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，由命令自己决定)，则证明上一个命令执行不正确</td></tr></tbody></table><p><strong>应用实例：</strong></p><p><img src="/2022/05/05/Linux/image-20220531112254061.png" alt="shell脚本实现"></p><p><img src="/2022/05/05/Linux/image-20220531112401344.png" alt="运行截图"></p><h2 id="14-7、运算符"><a href="#14-7、运算符" class="headerlink" title="14.7、运算符"></a>14.7、运算符</h2><p><strong>基本语法：</strong></p><p>1、”$((运算式))” 或 “$[运算式]” 或者expr m + n</p><p>2、注意expr运算符之间要有空格，如果希望将 expr 的结果赋给某个变量，使用<code>反引号</code></p><p>3、expr m - n</p><p>4、expr \*,/,% 乘，除，取余</p><p><strong>应用实例：</strong></p><p><code>案例一：</code>计算(2+3) X4 的值</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">案例一：计算(2+3) X4 的值</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用第一种方式</span><br>RES1=$(((2+3)*4))<br>echo &quot;res1=$RES1&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用第二种方式,推荐使用</span><br>RES2=$[(2+3)*4]<br>echo &quot;res2=$RES2&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用第三种方式 <span class="hljs-built_in">expr</span></span><br>TEMP=`expr 2 + 3`<br>RES4=`expr $TEMP \* 4`<br>echo &quot;temp=$TEMP&quot;<br>echo &quot;res4=$RES4&quot;<br></code></pre></td></tr></table></figure><p><code>案例二：</code>请求出命令行的两个参数[整数] 的和。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">案例二：请求出命令行的两个参数[整数] 的和</span><br>SUM=$[$1+$2]<br>echo &quot;sum=$SUM&quot;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/05/Linux/image-20220531160816534.png" alt="运行结果"></p><h2 id="14-8、条件判断"><a href="#14-8、条件判断" class="headerlink" title="14.8、条件判断"></a>14.8、条件判断</h2><hr><p><strong>判断语句：</strong></p><p><strong>基本语法：</strong></p><p>[ condition ]（注意 condition前后要有空格）</p><p>#非空返回true，可使用$?验证（0为true，&gt;1为false）</p><p><strong>应用实例：</strong></p><p>[ hspEdu ]                                                         返回true</p><p>[ ]                                                                        返回false</p><p>[ condition ] &amp;&amp; echo OK || echo notok     条件满足，执行后面的语句</p><p><strong>常用判断条件：</strong></p><p><strong>1、字符串比较</strong></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>=</td><td>判断两个字符串是否相等</td></tr></tbody></table><p><strong>2、 两个整数的比较</strong></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>-lt</td><td>小于</td></tr><tr><td>-le</td><td>小于等于</td></tr><tr><td>-eq</td><td>等于</td></tr><tr><td>-gt</td><td>大于</td></tr><tr><td>-ge</td><td>大于等于</td></tr><tr><td>-ne</td><td>不等于</td></tr></tbody></table><p><strong>3、按照文件权限进行判断</strong></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>有读的权限</td></tr><tr><td>-w</td><td>有写的权限</td></tr><tr><td>-x</td><td>有执行的权限</td></tr></tbody></table><p><strong>4、按照文件类型进行判断</strong></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>文件存在并且是一个常规的文件</td></tr><tr><td>-e</td><td>文件存在</td></tr><tr><td>-d</td><td>文件存在并且是一个目录</td></tr></tbody></table><p><strong>应用实例：</strong></p><p><code>案例1：</code>“ok”是否等于”ok”</p><p>判断语句：使用 =</p><p><code>案例2：</code>23是否大于等于22</p><p>判断语句：使用 -ge</p><p><code>案例3：</code>/root/shcode/aaa.text 目录中的文件是否存在</p><p>判断语句： 使用 -f</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531163857748.png" alt="代码实现"></p><p><strong>运行结果：</strong></p><p><img src="/2022/05/05/Linux/image-20220531192332755.png" alt="运行结果"></p><h2 id="14-9、流程控制"><a href="#14-9、流程控制" class="headerlink" title="14.9、流程控制"></a>14.9、流程控制</h2><h3 id="14-9-1、if判断"><a href="#14-9-1、if判断" class="headerlink" title="14.9.1、if判断"></a>14.9.1、if判断</h3><p><strong>基本语法：</strong></p><p><img src="/2022/05/05/Linux/image-20220531165206409.png" alt="基本语法"></p><p><strong>注意事项：</strong>[ 条件判断式 ]，中括号和条件判断式之间必须有空格</p><p><strong>应用实例：ifCase.sh</strong></p><p><code>案例：</code>请编写一个shell程序，如果输入的参数大于等于60，则输出”及格了“，日过小于60，则输出”不及格“</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531170146623.png" alt="代码实现"></p><p><strong>运行结果：</strong></p><p><img src="/2022/05/05/Linux/image-20220531192249944.png" alt="运行结果"></p><h3 id="14-9-2、case语句"><a href="#14-9-2、case语句" class="headerlink" title="14.9.2、case语句"></a>14.9.2、case语句</h3><p><strong>基本语法：</strong></p><p><img src="/2022/05/05/Linux/image-20220531170652323.png" alt="基本语法"></p><p><strong>应用实例 testCase.sh:</strong></p><p><code>案例1：</code>当命令行参数是1时，输出”周一“，是2时，输出”周二“，其他情况输出”other“</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531171347748.png" alt="代码实现"></p><p><strong>运行结果：</strong></p><p><img src="/2022/05/05/Linux/image-20220531192147718.png" alt="运行结果"></p><h3 id="14-9-3、for循环"><a href="#14-9-3、for循环" class="headerlink" title="14.9.3、for循环"></a>14.9.3、for循环</h3><p><strong>基本语法1：</strong></p><p><img src="/2022/05/05/Linux/image-20220531171442062.png" alt="基本语法1"></p><p><strong>应用实例 testFor1.sh：</strong></p><p><code>案例1：</code>打印命令行输入的参数 [这里可以看出$*和$@的区别]</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531192001601.png" alt="代码实现"></p><p><strong>运行结果：</strong></p><p><img src="/2022/05/05/Linux/image-20220531192116077.png" alt="运行结果"></p><p><strong>基本语法2：</strong></p><p><img src="/2022/05/05/Linux/image-20220531171517671.png" alt="基本语法2"></p><p><strong>应用实例 testFor2.sh：</strong></p><p><code>案例1：</code>从1加到100的值输出显示</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531205527628.png" alt="代码实现"></p><p><strong>实验结果：</strong></p><p><img src="/2022/05/05/Linux/image-20220531205607901.png" alt="实验结果"></p><h3 id="14-9-4、while循环"><a href="#14-9-4、while循环" class="headerlink" title="14.9.4、while循环"></a>14.9.4、while循环</h3><p><strong>基本语法1：</strong></p><p><img src="/2022/05/05/Linux/image-20220531210054290.png" alt="基本语法1"></p><p><strong>应用实例：</strong></p><p><code>案例1：</code>从命令行输入一个数n，统计从1+…+n的值是多少？</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531210355007.png" alt="代码实现"></p><p><strong>执行结果：</strong></p><p><img src="/2022/05/05/Linux/image-20220531210438484.png" alt="执行结果"></p><h2 id="14-10、read读取控制台输入"><a href="#14-10、read读取控制台输入" class="headerlink" title="14.10、read读取控制台输入"></a>14.10、read读取控制台输入</h2><p><strong>基本语法：</strong></p><ul><li>read(选项)(参数)<ul><li>选项：<ul><li>-p：指定读取时的提示符；</li><li>-t：指定读取值时等待的时间(秒)，如果没有在指定的时间内输入，就不再等待了。。</li></ul></li><li>参数：<ul><li>变量：指定读取值的变量名</li></ul></li></ul></li></ul><p><strong>应用实例 testRead.sh：</strong></p><p><code>案例1：</code>读取控制台输入一个num值</p><p><code>案例2：</code>读取控制台输入一个sum值，在10s内输入</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531212111780.png" alt="代码实现"></p><p><strong>运行截图：</strong></p><p><img src="/2022/05/05/Linux/image-20220531212042267.png" alt="运行截图"></p><h2 id="14-11、函数"><a href="#14-11、函数" class="headerlink" title="14.11、函数"></a>14.11、函数</h2><h3 id="14-11-1、函数介绍"><a href="#14-11-1、函数介绍" class="headerlink" title="14.11.1、函数介绍"></a>14.11.1、函数介绍</h3><p>shell编程和其他编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个</p><h3 id="14-11-2、系统函数"><a href="#14-11-2、系统函数" class="headerlink" title="14.11.2、系统函数"></a>14.11.2、系统函数</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>basename</td><td>返回完成路径最后 / 的部分，常用于获取文件名</td></tr><tr><td>basename  [pathname] [suffix]</td><td>basename命令会删掉所有的前缀包括最后一个(‘/‘)字符没然后将字符串显示出来</td></tr><tr><td>basename  [string] [suffix]</td><td>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</td></tr></tbody></table><hr><p><strong>basename基本语法</strong></p><ul><li>功能：  返回完成路径最后 / 的部分，常用于获取文件名</li><li>basename  [pathname] [suffix] </li><li>basename  [string] [suffix]   （功能描述：basename命令会删掉所有的前缀包括最后一个(‘/‘)字符没然后将字符串显示出来）</li><li>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</li></ul><p><strong>应用实例：</strong></p><p><code>案例1：</code>请返回 /home/aaa/test.txt 的”test.txt”部分</p><p><img src="/2022/05/05/Linux/image-20220531213015225.png"></p><p><img src="/2022/05/05/Linux/image-20220531213046581.png"></p><hr><p><strong>dirname基本语法</strong></p><ul><li>功能：返回完整路径最后 / 的前面的部分，常用于返回路径部分</li><li>dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中取出文件名（非目录的部分），然后返回剩下的路径（目录的部分））</li></ul><p><strong>应用实例：</strong></p><p><code>案例1：</code>请返回 /home/aaa/test.txt 的/home/aaa</p><p><img src="/2022/05/05/Linux/image-20220531213340808.png"></p><h3 id="14-11-3、自定义函数"><a href="#14-11-3、自定义函数" class="headerlink" title="14.11.3、自定义函数"></a>14.11.3、自定义函数</h3><p><strong>基本语法：</strong></p><p><img src="/2022/05/05/Linux/image-20220531213835929.png" alt="基本语法"></p><p><strong>应用实例：</strong></p><p><code>案例1：</code>计算输入两个参数的和(动态的获取)，getSum</p><p><strong>代码实现：</strong></p><p><img src="/2022/05/05/Linux/image-20220531214611797.png" alt="代码实现"></p><p><strong>运行截图：</strong></p><p><img src="/2022/05/05/Linux/image-20220531214531854.png" alt="运行截图"></p><h3 id="14-12、Shell编程综合案例"><a href="#14-12、Shell编程综合案例" class="headerlink" title="14.12、Shell编程综合案例"></a>14.12、Shell编程综合案例</h3><hr><p><strong>需求分析：</strong></p><p>1、每天凌晨 2:30 备份数据库 hspedu 到 /data/backyp/db</p><p>2、备份开始和备份结束能够给出相应的提示信息</p><p>3、备份后的文件要求以备份时间为文件名，并打包成 .tar.gz 的形式</p><p>4、在备份的同时，检查是否有10天前备份的数据库文件，如果有就删除</p><p><strong>数据库备份的步骤示意图：</strong></p><p><img src="/2022/05/05/Linux/image-20220531224938997.png" alt="思路分析图"></p><hr><p><strong>代码 /usr/sbin/mysql_db.backup.sh</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份文件</span><br>BACKUP=/data/backup/db<br><span class="hljs-meta prompt_">#</span><span class="language-bash">当前时间</span><br>DATETIME=$(date +%Y-%m-%d_%H%M%S)<br>echo $DATETIME<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库的地址</span><br>HOST=localhost<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库的用户名</span><br>DB_USER=****<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库的密码</span><br>DB_PW=****<br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份的数据库名</span><br>DATABASE=hspedu<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建备份目录，如果不存在，就创建</span><br>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份数据库</span><br>mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --hose=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将文件处理成 tar.gz的形式</span><br>cd $&#123;BACKUP&#125;<br>tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除对应的备份目录</span><br>rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除10天前的备份文件</span><br>find $&#123;BACKUP&#125; -atime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;<br>echo &quot;备份数据库$&#123;DATABASE&#125; 成功~&quot;<br></code></pre></td></tr></table></figure><p><strong>添加定时任务调度：</strong></p><p><strong>1、crontab -e</strong></p><p><img src="/2022/05/05/Linux/image-20220601004018605.png"></p><p><strong>2、在界面中输入  30 2 * * * /usr/sbin/mysql_db_backup.sh</strong></p><p> <img src="/2022/05/05/Linux/image-20220601004034382.png"></p><h1 id="十五、日志管理"><a href="#十五、日志管理" class="headerlink" title="十五、日志管理"></a>十五、日志管理</h1><h2 id="15-1、基本介绍"><a href="#15-1、基本介绍" class="headerlink" title="15.1、基本介绍"></a>15.1、基本介绍</h2><p>1、日志文件是重要的系统信息文件，记录了许多 <strong>重要的系统事件</strong></p><p>2、日志对于 <strong>安全来说也很重要</strong>，可以通过日志来检查错误发生的原因</p><p>3、<strong>日志是用来记录重大事件的工具</strong></p><h2 id="15-2、系统常用的日志"><a href="#15-2、系统常用的日志" class="headerlink" title="15.2、系统常用的日志"></a>15.2、系统常用的日志</h2><p>/var/log/ 目录就是系统日志文件的保存位置。</p><p><img src="/2022/05/05/Linux/image-20220529154008532.png" alt="系统常用的日志"></p><h2 id="15-3、日志管理服务rsyslogd"><a href="#15-3、日志管理服务rsyslogd" class="headerlink" title="15.3、日志管理服务rsyslogd"></a>15.3、日志管理服务rsyslogd</h2><p>Centos7.6日志服务是rsyslogd，Centos6.x日志服务是syslogd，rsyslogd更强大。</p><p><img src="/2022/05/05/Linux/image-20220530094005686.png" alt="原理示意图"></p><p><strong>应用实例</strong></p><p><strong>ps aux | grep “rsyslogd” | grep -v “gerp”</strong> 查询linux中的rsyslogd服务是否启动</p><p><strong>systemctl list-unit-files | grep rsyslog</strong> 查询rsyslogd服务的自启动状态</p><p><img src="/2022/05/05/Linux/image-20220529155432292.png" alt="应用实例"></p><p><strong>grep -v “关键字”</strong> 代表挑选出不包含关键字的</p><p><img src="/2022/05/05/Linux/image-20220530094254764.png"></p><p><strong>配置文件相关的信息说明</strong></p><p>编辑文件时的格式为: * . *             存放日志文件<br>其中第一个 * 代表日志类型，第二个 * 代表日志级别</p><p>1.日志类型分为:</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>auth</td><td>##pam产生的日志</td></tr><tr><td>authpriv</td><td>##ssh、ftp等登录信息的验证信息</td></tr><tr><td>corn</td><td>##时间任务相关</td></tr><tr><td>kern</td><td>##内核</td></tr><tr><td>lpr</td><td>##打印</td></tr><tr><td>mail</td><td>##邮件</td></tr><tr><td>mark(syslog)-rsyslog</td><td>##服务内部的信息，时间标识</td></tr><tr><td>news</td><td>##新闻组</td></tr><tr><td>user</td><td>##用户程序产生的相关信息</td></tr><tr><td>uucp</td><td>##unix to nuix copy主机之间相关的通信</td></tr><tr><td>local 1-7</td><td>##自定义的日志设备</td></tr></tbody></table><p>2.日志级别分为：</p><table><thead><tr><th>级别</th><th>说明</th></tr></thead><tbody><tr><td>debug</td><td>##有调试信息的，日志通信最多</td></tr><tr><td>info</td><td>##—般信息日志，最常用</td></tr><tr><td>notice</td><td>##最具有重要性的普通条件的信息</td></tr><tr><td>warning</td><td>##警告级别</td></tr><tr><td>err</td><td>##错误级别，阻止某个功能或者模块不能正常工作的信息</td></tr><tr><td>crit</td><td>##严重级别，阻止整个系统或者整个软件不能正常工作的信息</td></tr><tr><td>alert</td><td>##需要立刻修改的信息</td></tr><tr><td>emerg</td><td>##内核崩溃等重要信息</td></tr><tr><td>none</td><td>##什么都不记录</td></tr></tbody></table><p><strong>注意:从上到下，级别从低到高，记录信息越来越少</strong></p><p>由日志服务rsyslogd记录的日志文件，日志文件的格式包含以下4列:</p><p>事件产生的时间</p><p>产生事件的服务器的主机名</p><p>产生事件的服务名或程序名</p><p>事件的具体信息</p><p><strong>日志如何查看实例</strong></p><p>查看/var/log/secure日志，这个日志中记录的是用户验证和授权方面的信息</p><p><img src="/2022/05/05/Linux/image-20220530095627463.png"></p><p><strong>增加自定义的日志步骤</strong></p><p>1、vim /etc/rsyslog.conf</p><p><img src="/2022/05/05/Linux/image-20220530095927797.png"></p><p>2、创建自定义的日志文件</p><p><img src="/2022/05/05/Linux/image-20220530100016234.png"></p><p>3、重启(reboot) linux 查看/var/log/hsp.log文件</p><p><img src="/2022/05/05/Linux/image-20220530100226443.png"></p><h2 id="15-4、日志轮替"><a href="#15-4、日志轮替" class="headerlink" title="15.4、日志轮替"></a>15.4、日志轮替</h2><p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧的日志文件超出保存的范围之后，就会进行删除</p><p><strong>日志轮替文件命名</strong></p><ol><li>centos7使用logrotate进行日志轮替管理，要想改变日志轮替文件名字，通过/etc/logrotate.conf配置文件中“dateext”参数:</li><li>如果配置文件中有“dateext”参数，那么日志会用<strong>日期</strong>来作为日志文件的后级，例如“secure-20201010”。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。</li><li>如果配置文件中没有“dateext”参数，日志文件就需要进行改名了。当第一次进行日志轮替时，当前的<strong>“secure”日志会自动改名为”secure.1”，然后新建”secure”日志，用来保存新的日志。</strong>当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为”secure.1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。</li></ol><p><strong>logrotate配置文件</strong></p><p><img src="/2022/05/05/Linux/image-20220530103720000.png" alt="配置文件"></p><p><strong>参数说明：</strong></p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>daily</td><td>日志的轮替周期是每天</td></tr><tr><td>weekly</td><td>日志的轮替周期是每周</td></tr><tr><td>monthly</td><td>日志的轮替周期是每月</td></tr><tr><td>rotate数字</td><td>保留的白志文件的个数。0指没有备份</td></tr><tr><td>compress</td><td>日志轮替时，旧的日志进行压缩</td></tr><tr><td>create mode owner group</td><td>建立新日志，同时指定新日志的权限与所有者和所属组</td></tr><tr><td>mail address</td><td>当日志轮替时，输出内容通过邮件发送到指定的邮件地址。</td></tr><tr><td>missingok</td><td>如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志为空文件，则不进行日志轮替</td></tr><tr><td>minsize大小</td><td>日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td></tr><tr><td>size大小</td><td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件的后缀。</td></tr><tr><td>sharedscripts</td><td>在此关键字之后的脚本只执行一次。</td></tr><tr><td>prerotate/endscript</td><td>在日志轮替之前执行脚本命令。</td></tr><tr><td>postrotate/endscript</td><td>在日志轮替之后执行脚本命令。</td></tr></tbody></table><p><strong>将自己的日志加入日志轮替的方法：</strong></p><p>第一种方法是直接在 /etc/logrotate.conf 配置文件中写入该日志的轮替策略<br>第二种方法是在 /etc/logrotate.d/ 目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被 “include” 到主配置文件中，所以也可以把日志加入轮替。<br><strong>推荐使用第二种方法</strong>，因为系统中需要轮替的日志非常多，如果全都直接写入/etc/logrotate.conf配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</p><p><img src="/2022/05/05/Linux/image-20220530122433278.png"></p><p><strong>日志轮替机制原理</strong></p><p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在/etc/cron.daily/目录，就会发现这个目录中是有logrotate文件(可执行)，logrotate通过这个文件依赖定时任务执行的。</p><p><img src="/2022/05/05/Linux/image-20220530110237896.png"></p><p><img src="/2022/05/05/Linux/image-20220530094005686.png" alt="原理示意图"></p><h2 id="15-5、查看内存日志"><a href="#15-5、查看内存日志" class="headerlink" title="15.5、查看内存日志"></a>15.5、查看内存日志</h2><ul><li><strong>journalctl</strong> ##查看全部</li><li><strong>journalctl -n 3</strong> ##查看最新3条</li><li><strong>journalctl –since 19:00 –until 19:10:10</strong> #查看起始时间到结束时间的日志可加日期</li><li><strong>journalctl -p err</strong> ##报错日志</li><li><strong>journalctl -o verbose</strong> ## 日志详细内容</li><li><strong>journalctl _PID=1245 _COMM=sshd或者journalctl | gerp ssh</strong> ##查看包含这些参数的日志</li><li><strong>journalctl</strong> 查看的是<strong>内存日志</strong>，重启清空</li></ul><h1 id="十六、定制自己的Linux系统"><a href="#十六、定制自己的Linux系统" class="headerlink" title="十六、定制自己的Linux系统"></a>十六、定制自己的Linux系统</h1><hr><p><strong>基本原理</strong></p><p><strong>启动流程介绍：</strong></p><p>1、首先Linux要通过自检，检查硬件设备有没有故障</p><p>2、如果有多快启动盘的话，需要在BIOS中选择启动磁盘</p><p>3、启动MBR中的bootloader引导程序</p><p>4、加载所有内核</p><p>5、执行所有进程的父进程、老祖宗system</p><p>6、欢迎界面</p><p>在Linux的启动流程中，加载内核文件时关键文件：</p><p>1）kernel文件：vmlinuz-3.10.0-957.el7.x86_64</p><p>2）initrd文件：inittamfs-3.10.0-957.e;7.x86_64.img</p><hr><p><strong>思路分析</strong></p><p>1、在现有的Linux系统(centos7.6)上加一块硬盘/dev/sdb，在硬盘上分两个分区，一个是/boot，一个是/，并将其格式化。需要明确的是，现在加的这个硬盘在现有的Linux系统中是/dev/sdb，但是，当我们把东西全部设置好时，要把这个硬盘拔除，放在新系统上，此时，就是/dev/sda</p><p>2、在/dev/sdb硬盘上，将其打造成独立的Linux系统，里面的所有文件是需要拷贝进去的。</p><p>3、作为能独立运行的Linux系统，内核是一定不能少，要把内核文件和initramfs文件也一起拷到/dev/sdb上</p><p>4、自制Linux就完成，创建一个新的linux虚拟机，将其硬盘指向我们创建的硬盘，启动即可。</p><p><strong>示意图：</strong></p><p><img src="/2022/05/05/Linux/image-20220601095455981.png" alt="示意图"></p><hr><p><strong>制作流程：</strong></p><p><strong>1、分出硬盘：</strong></p><p>1）首先，我们在现有的linux添加一块大小为20G的硬盘</p><p><img src="/2022/05/05/Linux/image-20220601101803357.png"></p><p><img src="/2022/05/05/Linux/image-20220601102012216.png"></p><p><img src="/2022/05/05/Linux/image-20220601101843964.png"></p><p><img src="/2022/05/05/Linux/image-20220601102050562.png"></p><p><img src="/2022/05/05/Linux/image-20220601101855046.png"></p><p><img src="/2022/05/05/Linux/image-20220601102114474.png"></p><p><img src="/2022/05/05/Linux/image-20220601102128198.png"></p><p><strong>2、分区：</strong></p><p>1）执行 <code>fdisk /dev/sdb</code></p><p><img src="/2022/05/05/Linux/image-20220601101147406.png" alt="boot分区"></p><p>输入 <code>n</code> 添加新的分区，输入 <code>p</code>将分区分为 primary</p><p>分区号直接回车 默认为第一块</p><p>起始扇区直接回车 使用默认值</p><p>第一块分区给予 +500M 也就是将来对应的boot分区</p><p><img src="/2022/05/05/Linux/image-20220601101324787.png" alt="根分区"></p><p>输入 <code>n</code> 添加新的分区，输入 <code>p</code>将分区分为 primary</p><p>分区号直接回车 默认为第二块</p><p>起始扇区直接回车 使用默认值</p><p>将剩下的所有内存给予第二块分区</p><p><img src="/2022/05/05/Linux/image-20220601101507157.png"></p><p>最后输入 <code>w</code>写入分区</p><p><strong>3、对/dev/sdb 的分区进行格式化</strong></p><p><img src="/2022/05/05/Linux/image-20220601102329488.png"></p><p><img src="/2022/05/05/Linux/image-20220601102347134.png"></p><p><strong>4、挂载</strong></p><p><img src="/2022/05/05/Linux/image-20220601102727983.png"></p><p><strong>5、安装 grub，内核文件拷贝纸目标磁盘</strong></p><p>安装grub</p><p><img src="/2022/05/05/Linux/image-20220601103030337.png" alt="安装grub"></p><p>查看是否安装成功二进制</p><p><img src="/2022/05/05/Linux/image-20220601103114381.png"></p><p>将 sda中的boot下的所有文件拷贝到 sdb中的boot下</p><p><img src="/2022/05/05/Linux/image-20220601103302174.png"></p><p><strong>6、修改 grub2/grub.cfg 文件</strong></p><p><img src="/2022/05/05/Linux/image-20220601105233770.png"></p><p> 在grub.cfg文件中 , 红色部分用 上面 sdb1 的 UUID替换，蓝色部分用 sdb2的UUID来替换, 紫色部分是添加的，表示</p><p>selinux给关掉，同时设定一下init，告诉内核不要再去找这个程序了，不然开机的时候会出现错误的<img src="/2022/05/05/Linux/image-20220601104953610.png"></p><p><strong>7、创建目标主机根文件系统</strong></p><p><img src="/2022/05/05/Linux/image-20220601105450347.png"></p><p><strong>8、拷贝需要的bash(也可以拷贝你需要的指令)和库文件给新的系统使用</strong></p><p><img src="/2022/05/05/Linux/image-20220601105825142.png"></p><p><strong>9、 现在我们就可以创建一个新的虚拟机，然后将默认分配的硬盘移除掉，指向我们刚刚创建的磁盘即可</strong></p><p><strong>10、 很多指令都不能使用，比如 ls , reboot 等，可以将需要的指令拷贝到对应的目录即可</strong></p><p><strong>11、如果要拷贝指令，重新进入到原来的 linux系统拷贝相应的指令即可，比如将 /bin/ls 拷贝到 /mnt/sysroot/bin  将/sbin/reboot 拷贝到 /mnt/sysroot/sbin</strong> </p><p><img src="/2022/05/05/Linux/image-20220601125843691.png"></p><p><strong>12、再重新启动新的min linux系统，就可以使用 ls , reboot 指令了</strong></p><h1 id="十七、linux内核源码目录"><a href="#十七、linux内核源码目录" class="headerlink" title="十七、linux内核源码目录"></a>十七、linux内核源码目录</h1><p><strong>linux内核源码的目录介绍：</strong></p><p><img src="/2022/05/05/Linux/image-20220601153201415.png"></p><p><strong>main.c说明：(在init中只有一个main.c文件)</strong></p><p><img src="/2022/05/05/Linux/image-20220601154040070.png"></p><h1 id="十八、备份与恢复"><a href="#十八、备份与恢复" class="headerlink" title="十八、备份与恢复"></a>十八、备份与恢复</h1><h2 id="18-1、基本介绍"><a href="#18-1、基本介绍" class="headerlink" title="18.1、基本介绍"></a>18.1、基本介绍</h2><p>linux的备份和恢复很简单，有两种方式：</p><p>1、把需要的文件(或者分区)用TAR打包就行，下次需要恢复的时候，再解压开覆盖即可</p><p>2、使用dump和restore命令</p><hr><p><strong>安装dump和restore</strong></p><ul><li>yum -y install dump</li><li>yum -y install restore</li></ul><h2 id="18-2、使用dump完成备份"><a href="#18-2、使用dump完成备份" class="headerlink" title="18.2、使用dump完成备份"></a>18.2、使用dump完成备份</h2><hr><p><strong>基本介绍：</strong></p><p>dump支持分卷和增量备份(所谓增量备份是指备份上次备份后 修改/增加过的文件，也称差异备份)。</p><hr><p><strong>dump语法说明</strong></p><ul><li><strong>dump [ -cu ] [-123456789] [ -f &lt;备份后文件名&gt;] [-T &lt;日期&gt;] [ 目录或文件系统]</strong></li><li><strong>dump []-wW</strong><ul><li><strong>-c（具体就是0~9的数字）：</strong>创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头</li><li><strong>-0123456789：</strong>备份的层级。0为最完整备份，会备份所有文件。若指定0以上的层级，则备份至上一次备份以来修改或新增的文件，到9后，可以再次轮替</li><li><strong>-f &lt;备份后文件名&gt;：</strong>指定备份后文件名</li><li><strong>-j：</strong><code>调用 bzlib 库压缩备份文件</code>，也就是将备份后的文件压缩成 bz2 格式，让文件更小</li><li><strong>-T &lt;日期&gt;：</strong>指定开始备份的时间与日期</li><li><strong>-u：</strong>备份完毕后，在 /etc/dumpdares中记录备份的文件系统，层次，日期与时间等。</li><li><strong>-t：</strong>指定文件名，若该文件已存在备份文件中，则列出名称</li><li><strong>-W：</strong>显示需要备份的文件及其最后一次备份的层级，时间，日期</li><li><strong>-w：</strong>与-W类似，但仅显示需要备份的文件。</li></ul></li><li><strong>cat /ect/dumpdates</strong>查看备份时间文件</li></ul><hr><p><strong>应用案例：</strong></p><p><code>案例1：</code> 将/boot 分区的所有内容被分到 /opt/book.bak0.bz2 文件中，备份层级为“0”</p><p>dump -0uj -f /opt/boot.bak0.bz2 /boot</p><p><code>案例2：</code>在/boot 分区下增加一个新文件，备份层级为“1”（只备份上次使用层次“0”备份后发生改变的数据）</p><p>dump -1uj -f /opt/boot.bak1.bz2 /boot</p><p><strong>提示：</strong>通过dump命令再配合crontab 可以实现无人值守备份</p><hr><p><strong>dump 备份文件或者目录</strong></p><p>我们在备份分区时，是可以支持增量备份，如果备份 <strong>文件或者目录，不再支持增量备份</strong>，只能使用0级别备份</p><p>如果是比较重要的备份文件，建议将文件上传到其他服务器保存，<strong>不要将鸡蛋放在同一个篮子</strong></p><h2 id="18-3、使用-restore-完成恢复"><a href="#18-3、使用-restore-完成恢复" class="headerlink" title="18.3、使用 restore 完成恢复"></a>18.3、使用 restore 完成恢复</h2><hr><p><strong>基本介绍：</strong></p><p>restore 命令用来恢复已备份的文件，可以从dump 生成的备份文件中恢复原文件</p><hr><p><strong>基本语法：</strong></p><ul><li><strong>restore [模式选项] [选项]</strong> <ul><li>以下四个模式不能混用，在一次命令中只能指定一种<ul><li><strong>-C：</strong>使用对比模式，将备份的文件与已存在的文件相互对比</li><li><strong>-i：</strong>使用交互模式，在进行还原操作时，restors指令依序询问用户</li><li><strong>-r：</strong>进行还原模式</li><li><strong>-t：</strong>查看模式，看备份文件中有哪些选项</li></ul></li><li>选项：<ul><li><strong>-f &lt;备份设备&gt; ：</strong>从指定的文件中读取备份数据，进行还原操作</li></ul></li></ul></li></ul><hr><p><strong>应用案例：</strong></p><p><code>案例1：</code>restore 命令比较模式，比较备份文件和原文件的区别</p><p>测试：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">mv <span class="hljs-regexp">/boot/</span>hello.java <span class="hljs-regexp">/boot/</span>hello100.java<br><br>restore -C -f boot.bak1.bz2 <span class="hljs-regexp">//</span>注意和最新的文件比较<br></code></pre></td></tr></table></figure><p> <img src="/2022/05/05/Linux/image-20220602003649984.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">mv <span class="hljs-regexp">/boot/</span>hello100.java <span class="hljs-regexp">/boot/</span>hello.java<br><br>restore -C -f boot.bak1.bz2 <span class="hljs-regexp">//</span>注意和最新的文件比较<br></code></pre></td></tr></table></figure><p><img src="/2022/05/05/Linux/image-20220602003607110.png"></p><p><code>案例2：</code>restore 命令查看模式，看备份文件有哪些数据/文件</p><p>测试：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">restroe -<span class="hljs-built_in">t</span> -f boot.bak0.<span class="hljs-symbol">bz2</span><br></code></pre></td></tr></table></figure><p><code>案例3：</code>restore命令还原模式。<strong>注意细节：</strong>如果你有增量备份，需要把增量文件也进行恢复，有几个增量备份文件，就要回复几个，按顺序来恢复即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/opt/</span>boottmp<br>cd <span class="hljs-regexp">/opt/</span>boottmp<br>restore -r -f <span class="hljs-regexp">/opt/</span>boot.bak0.bz2 <span class="hljs-regexp">//</span>恢复到第<span class="hljs-number">1</span>次完全备份状态<br>restore -r -f <span class="hljs-regexp">/opt/</span>boot.bak1.bz2 <span class="hljs-regexp">//</span>恢复到第<span class="hljs-number">2</span>次增量备份状态<br></code></pre></td></tr></table></figure><p><code>案例4：</code>restore命令恢复备份的文件，或者整个目录的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> etctmp<br><span class="hljs-built_in">cd</span> etctmp/<br>restore -r -f /opt/etc.bak0.bz2<br></code></pre></td></tr></table></figure><h1 id="十九、linux面试题"><a href="#十九、linux面试题" class="headerlink" title="十九、linux面试题"></a>十九、linux面试题</h1><hr><p>分析日志t.log（访问量），将各个ip地址截取，并统计出现次数，并按照从大到小排序(腾讯)</p><ul><li>cut 文件内容查看 显示行中指定部分的内容<ul><li><strong>cut [选项参数]  filename</strong>（不能按照空格分隔）<ul><li><strong>-b：</strong>以字节为单位进行分割</li><li><strong>-c：</strong>以字符 (characters) 的单位取出固定字符区间</li><li><strong>-d：</strong>分隔符，按照指定分隔符分割列。与 -f 一起使用</li><li><strong>-f：</strong>依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思（列号，提取第几列）</li></ul></li></ul></li><li><strong>sort 选项 文件</strong> 将文件的每一行作为一个单位，相互比较，默认从小到大排序）<ul><li><strong>-u：</strong>去重</li><li><strong>-r：</strong> 从大到小排序</li><li><strong>-n：</strong>以数值来排序</li></ul></li><li><strong>uniq -c</strong> 在每一列的旁边统计重复行出现的次数</li></ul><p><img src="/2022/05/05/Linux/image-20220602155020464.png"></p><hr><p>统计连接到服务器的各个ip情况，并按连接数从大到小排序（腾讯）</p><p><img src="/2022/05/05/Linux/image-20220602160950892.png"></p><ul><li><p>grep ESTABLISHED：选取出连接状态的ip </p></li><li><p><strong>awk -F “ “ ‘{print $5}’：</strong>由于cut命令不能分割空格 所以使用awk</p><ul><li><strong>-F “xx”：</strong> 按照xx进行分割</li></ul></li></ul><hr><p>如何找回mysql的ROOT用户的密码？（滴滴）</p><p>1、进入  <code>vim /etc/my.cnf</code>  在最后插入 <code>skip-grant-tables</code>（跳过输入密码的步骤）</p><p>2、重启mysql <code>service mysqld restart</code></p><p>3、修改密码 密码在<strong>mysql表</strong>中的 <strong>user表</strong>中的authentication_string</p><p><code>update user set authentication_string=password(&quot;xxxx&quot;) where user=&#39;root&#39;;</code></p><p><code>flush pricileges;</code></p><p>4、进入  <code>vim /etc/my.cnf</code>  在注释插入的 <code>skip-grant-tables</code></p><p>5、重启mysql<code>service mysqld restart</code></p><hr><p>统计ip访问情况，要求分析nginx访问日志（access.log），找出访问页面数量在前2问的ip（美团）</p><p><code>cat access.log | awk -F &quot; &quot; &#39;&#123;print $1&#125;&#39; | sort | uniq -c | sort -nr | head -2</code></p><hr><p>使用tcpdump监听本机，将来自ip 192.168.200.1，tcp端口为22的数据，保存输出到tcpdump.log，用做将来数据分析（美团）</p><p><code>tcpdump -i ens33 host 192.168.200.1 and port 22 &gt;&gt; /opt/interview/tcpdump.log</code></p><hr><p>常用的Nginx模块，用来做什么（头条）</p><p><img src="/2022/05/05/Linux/image-20220602170220428.png"></p><hr><p>列举linux高级命令，至少6个(百度)</p><p><code>netstat // 网络状态监控</code></p><p><code>top //系统运行状态</code></p><p><code>lsblk //查看硬盘分区 find</code></p><p><code>ps -aux //查看运行进程</code></p><p><code>chkconfig //查看服务启动状态</code></p><p><code>systemctl //管理系统服务器</code></p><hr><p>Linux查看内容、io读写、磁盘存储、端口占用、进程查看命令是什么？（瓜子）</p><p><code>top //Linux查看内存</code></p><p><code>iotop //io读写</code></p><p><code>df -lh //磁盘存储</code></p><p><code>netstat -tunlp //端口占用</code></p><p><code>ps -aux | gerp 关心的进程//进程查看命令</code></p><hr><p>使用Linux命令计算t2.txt 第二列的和并且输出（美团）</p><p><code>cat t2.txt | awk -F &quot; &quot; &#39;&#123;sum+=$2&#125; END &#123;print sum&#125;&#39;</code></p><hr><p>Shell脚本里如何检查一个文件是否存在？（百度）</p><p><code>if [ -f 文件名 ] then echo &quot;存在&quot; else echo &quot;不存在&quot; fi</code></p><hr><p>Shell脚本对文本t3.txt中无序的一列数字排序，并将总和输出（百度）</p><p><code>sort -nr t3.txt | awk &#39;&#123;sum+=$0;print $0&#125; END &#123;print &quot;和=&quot;sum&#125;&#39;</code></p><hr><p>查找出当前文件夹(/home)下所有的文本文件内容中函数字符“cat”的文件名称(金山)</p><p><code>gerp -r &quot;cat&quot; /home |cut -d &quot;:&quot; -f 1</code></p><hr><p>统计/home目录下所有文件个数和所有文件总行数的指令(金山)</p><p><code>find /home/test -name &quot;*.*&quot; | wc -l</code> </p><p><code>find /home/test -name &quot;*.* | xargs wc -l&quot;</code></p><hr><p>每天晚上10点30分，打包站点目录/var/spool/mail 被备份到 /home 目录下（每次备份按时间生成不同的备份包）</p><p><img src="/2022/05/05/Linux/image-20220602172415402.png"></p><p><img src="/2022/05/05/Linux/image-20220602172458205.png"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树的后序遍历序列</title>
    <link href="/2022/05/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <url>/2022/05/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/image-20220504182947011.png" alt="image-20220504182947011"></p><p><strong>题解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(postorder, <span class="hljs-number">0</span>, postorder.length -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 后序遍历：左右头</span><br>    <span class="hljs-comment">// 二叉搜索树：左小于中 右大于中</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从左区间开始</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-comment">// 找到第一个大于头节点的值</span><br>        <span class="hljs-keyword">while</span> (postorder[p] &lt; postorder[right]) &#123;<br>            p++;<br>        &#125;<br>        <span class="hljs-comment">// 当前节点在postorder中的所在位置为头节点所在位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p;<br>        <span class="hljs-comment">// 找到右子树的最后一个值</span><br>        <span class="hljs-keyword">while</span> (postorder[p] &gt; postorder[right]) &#123;<br>            p++;<br>        &#125;<br>        <span class="hljs-comment">//     本树                   左树                                   右树</span><br>        <span class="hljs-type">return</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span>= right &amp;&amp; dfs(postorder,left,m-<span class="hljs-number">1</span>) &amp;&amp; dfs(postorder,m,right-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值的整数次方</title>
    <link href="/2022/05/04/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <url>/2022/05/04/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/04/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/image-20220504165807196.png" alt="数值的整数次方"></p><p><strong>解法一：（暴力遍历）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">1</span>/x;<br>            b = -b;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= b; i++) &#123;<br>                res *= x; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果发现当n太大的时候会出现超时现象</strong></p><p><strong>解法二：（快速幂）</strong></p><p><strong>解题思路：</strong></p><p><img src="/2022/05/04/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/30B0C70FDFBE773FBAFAEE6CE9466E5C.png" alt="解题思路"></p><p><strong>为什么要使用快速幂法？</strong></p><p><strong>快速幂法</strong> 可将时间复杂度降低至O(log2n)以二为低n的对数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">1</span>/x;<br>            b = -b;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 说明n的二进制的最低位为1</span><br>                res *= x;<br>            &#125;<br>            x *= x;<br>            b &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 消去二进制的最低位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2022/05/03/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/03/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/03/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503141319095.png" alt="重建二叉树"></p><p><img src="/2022/05/03/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503141405171.png" alt="索引"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] preorder;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.preorder = preorder;<br>        <span class="hljs-comment">// 遍历中序遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> recur(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[root]); <span class="hljs-comment">// 根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> map.get(preorder[root]); <span class="hljs-comment">// 得到根节点的索引</span><br>        node.left = recur(root+<span class="hljs-number">1</span>,left,i-<span class="hljs-number">1</span>);<br>        node.right = recur(root + (i - left) + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求1+2...+n</title>
    <link href="/2022/05/03/%E6%B1%821-2-n/"/>
    <url>/2022/05/03/%E6%B1%821-2-n/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/03/%E6%B1%821-2-n/image-20220503093415361.png" alt="求1+2...+n"></p><p><strong>解法：(运算符+递归)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> n &gt; <span class="hljs-number">1</span> &amp;&amp; (n += sumNums(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树的最近公共祖先</title>
    <link href="/2022/05/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/05/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20220503100709134.png" alt="二叉搜索树的最近公共祖先"></p><p><strong>解法：</strong></p><p>利用二叉搜索树左子树的所有节点小于头节点，右子树所有节点大于头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; <span class="hljs-comment">// 说明p，q在root的左子树内</span><br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left,p,q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; <span class="hljs-comment">// 说明p，q在root的右子树内</span><br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right,p,q);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// root &gt; p &lt; q或者 root &lt;p &gt; q 也就是说p，q在root的左子树与右子树</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img src="/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220430115218088.png" alt="image-20220430115218088"></p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="使用递归实现："><a href="#使用递归实现：" class="headerlink" title="使用递归实现："></a><strong>使用递归实现：</strong></h2><p><strong>先序遍历(头左右)：</strong>每一次第一次到达节点就打印</p><p><strong>中序遍历(左头右)：</strong>每一次第二次到达节点就打印</p><p><strong>后序遍历(左右头)：</strong>每一次最后一次到达节点就打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bianli</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历二叉树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        f(head.left);<br>        f(head.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 先序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>        preOrderRecur(head.left);<br>        preOrderRecur(head.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inOrderRecur(head.left);<br>        System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>        inOrderRecur(head.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>        posOrderRecur(head.left);<br>        posOrderRecur(head.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用非递归实现（栈）："><a href="#使用非递归实现（栈）：" class="headerlink" title="使用非递归实现（栈）："></a><strong>使用非递归实现（栈）：</strong></h2><p><strong>先序遍历(头左右)：</strong></p><p>前提：先将根节点加入栈中</p><p>1、每次从栈中弹出一个节点cur</p><p>2、打印（处理）cur</p><p>3、先把cur右孩子压到栈里，再把cur左孩子压到栈里去，如果有的左右孩子的话</p><p>4、周而复始</p><p><strong>中序遍历(左头右)：</strong></p><p><img src="/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220430171115049.png" alt="image-20220430171115049"></p><p><strong>每次都是左头右，然后把右当作头，综上所述最后都是左头左头</strong></p><p>1、每一棵子树整棵树左边界进栈</p><p>2、依次弹出每一个节点的过程中，打印</p><p>3、看看这个弹出的节点是否有右树，没有就继续弹出栈内的节点</p><p>3、有右树就对右树进行第一步</p><p><strong>后序遍历(左右头)：</strong></p><p>前提：多加一个收集栈，先将根节点加入栈中</p><p>1、每次从栈中弹出一个节点cur</p><p>2、把当前节点（cur）放到收集栈里去</p><p>3、先把cur左孩子压到栈里，再把cur右孩子压到栈里去，如果有的左右孩子的话</p><p>4、周而复始</p><p>5、最后弹出收集栈<strong>（左右头）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bianli</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = data;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 非递归（栈）先序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;per-order&quot;</span>);<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>            stack.add(head);<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                head = stack.pop();<br>                System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>                <span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(head.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(head.left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">// 非递归（栈）中序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;in-order&quot;</span>);<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(head);<br>                    head = head.left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    head = stack.pop();<br>                    System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>                    head = head.right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">// 非递归（栈）后序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pos-order&quot;</span>);<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>            Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>            s1.push(head);<br>            <span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;<br>                head = s1.pop();<br>                s2.push(head);<br>                <span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>                    s1.push(head.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>                    s1.push(head.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;<br>                System.out.println(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h1><p>宽度优先遍历用<strong>队列</strong>，头部进，尾部出；就是从上到下，从左到右依次遍历。</p><p>宽度优先遍历使用队列，先把头结点放到队列里，弹出就打印，先放左再放右，没有左就不放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMaxWidth</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 二叉树的宽度优先遍历(哈希表)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">w</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(head);<br>        <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            System.out.println(cur.value);<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(cur.right);<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓展：（如何求二叉树的宽度）"><a href="#拓展：（如何求二叉树的宽度）" class="headerlink" title="拓展：（如何求二叉树的宽度）"></a><strong>拓展：（如何求二叉树的宽度）</strong></h2><p>再宽度优先遍历的时候记录下每个节点的层数，最后比较，最大的层数就是最大宽度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMaxWidth</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 求二叉树的最大宽度(哈希表)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">w</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(head);<br>        HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">// 记录树的宽度的哈希表</span><br>        levelMap.put(head, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cueLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前在第几层</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curLevelNodes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前层发现了几个节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE; <span class="hljs-comment">// 所有层中哪一个层数的节点是最多的</span><br>        <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curNodeLevel</span> <span class="hljs-operator">=</span> levelMap.get(cur);<br>            <span class="hljs-keyword">if</span> (curNodeLevel == cueLevel) &#123; <span class="hljs-comment">// 如果当前节点所在的层和我来到的想统计的层一样</span><br>                curLevelNodes++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 来到的节点已经是下一层的节点了</span><br>                max = Math.max(max, curLevelNodes);<br>                cueLevel++;<br>                curLevelNodes = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                levelMap.put(cur.left, curNodeLevel+<span class="hljs-number">1</span>);<br>                queue.add(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                levelMap.put(cur.right, curNodeLevel+<span class="hljs-number">1</span>);<br>                queue.add(cur.right);<br>            &#125;<br>        &#125;<br>        max = Math.max(max, curLevelNodes);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>curend指的是当前层数的最后一个节点</p><p>nextend指的是下一层的最后一个节点，队列让谁进去这个值就变成谁</p><p>curlevel指的是当前层已经发现的节点数</p><p><strong>思路</strong>：curend是头节点，然后左孩子是2所以nextend = 2；右孩子是3所以nextend = 3；curlevel = 1；max =1；1被输出打印，1 != 3 所以当前层遍历结束curend = nextend，nextend = null，curlevel = 0；2在队列中被弹出，2的右孩子为4，所以nextend = 4；2!= curend =3，所以2不是当前层的最后一个节点，所以curlevel++；3在队列中被弹出，左孩子为5，右孩子为6，所以nextend = 6；3 = curend = 3，curlevel++，max在1与curlevel中取最大值2，nextend = curend，nextend = null；循环</p><p><img src="/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220501105151572.png" alt="求二叉树的最大宽度(G:/A-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AE%2597%25E6%25B3%2595%25E4%25B8%258E%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584/%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591/image-20220501105151572.png)"></p><h1 id="搜索二叉树（BST）："><a href="#搜索二叉树（BST）：" class="headerlink" title="搜索二叉树（BST）："></a>搜索二叉树（BST）：</h1><p>参考题：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p><p>对于每一个子树来说，他的左树的节点都比他小，右树的节点都比他大，可以看作没有重复值</p><p><strong>如何判断一个树是搜索二叉树？</strong></p><p><strong>方法一：</strong>使用中序遍历，如果所有节点打印出来都是升序，那么则二叉树是搜索二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBST</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>    &#125;<br><br>    <span class="hljs-comment">// 上一次处理到的节点的值（假设刚开始为系统最小）</span><br>    <span class="hljs-comment">// 建议用long 因为int会面临越界int最小值是-2147483648，如果头节点是-2147483648就会越界</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">preValue</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>    <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkBST</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeftBst</span> <span class="hljs-operator">=</span> checkBST(head.left);<br>        <span class="hljs-keyword">if</span> (!isLeftBst) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (head.value &lt;= preValue) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            preValue = head.value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> checkBST(head.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：（栈）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBST</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>    &#125;<br><br><span class="hljs-comment">// 非递归（栈）中序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">preValue</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>            Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(head);<br>                    head = head.left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    head = stack.pop();<br>                    <span class="hljs-keyword">if</span> (head.value &lt;= preValue) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        preValue = head.value;<br>                    &#125;<br>                    head = head.right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法三：使用套路完成判断一个树是否是搜索二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBST</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>    &#125;<br>    <span class="hljs-comment">// 使用基本套路</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnData</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isBST;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> min;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReturnData</span><span class="hljs-params">(<span class="hljs-type">boolean</span> is, <span class="hljs-type">int</span> mi,<span class="hljs-type">int</span> ma)</span> &#123;<br>            isBST = is;<br>            min = mi;<br>            max = ma;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReturnData <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ReturnData</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br>        <span class="hljs-type">ReturnData</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> x.value;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> x.value;<br>        <span class="hljs-keyword">if</span> (leftData != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 说明左树有东西</span><br>            min = Math.min(min, leftData.min);<br>            max = Math.max(max, leftData.max);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rightData != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 说明右树有东西</span><br>            min = Math.min(min, rightData.min);<br>            max = Math.max(max, rightData.max);<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isBST</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (leftData != <span class="hljs-literal">null</span> &amp;&amp; (!leftData.isBST || leftData.max &gt;= x.value)) &#123;<br>            <span class="hljs-comment">// 左树不等于空的情况下左树已经不是搜索二叉树了或者左树不等于空的情况下左边的最大值大于等于x的值</span><br>            isBST = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rightData != <span class="hljs-literal">null</span> &amp;&amp; (!rightData.isBST || rightData.min &lt;= x.value)) &#123;<br>            <span class="hljs-comment">// 右树不等于空的情况下右树已经不是搜索二叉树了或者右树不等于空的情况下右边的最小值小于等于x的值</span><br>            isBST = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnData</span>(isBST, min ,max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完全二叉树（CBT）："><a href="#完全二叉树（CBT）：" class="headerlink" title="完全二叉树（CBT）："></a>完全二叉树（CBT）：</h1><p>参考题：<a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/"> 二叉树的完全性检验</a></p><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。（最后一层有右子节点必有左子节点）</p><p><strong>如何判断一颗二叉树是完全二叉树？</strong></p><p>二叉树按宽度遍历，</p><p>1、任一节点有右孩子没有左孩子直接返回false；</p><p>2、在第一个条件不违规的情况下，如果遇见了第一个左右子节点不全的情况下，后续所有的节点都必须是叶节点（都必须没有左右子节点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCBT</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>    &#125;<br><br>    <span class="hljs-comment">// 宽度优先遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCBT</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 是否遇到过左右两个孩子不双全的节点</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">leaf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        queue.add(head);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            head = queue.poll();<br>            l = head.left;<br>            r = head.right;<br>            <span class="hljs-keyword">if</span> (<br>                    (leaf &amp;&amp; (l != <span class="hljs-literal">null</span> || r != <span class="hljs-literal">null</span>)) <span class="hljs-comment">// 如果遇见过两个孩子不双全的节点并且当前节点不是叶节点</span><br>                    ||<br>                    (l == <span class="hljs-literal">null</span> &amp;&amp; r != <span class="hljs-literal">null</span>) <span class="hljs-comment">// 有右孩子没有左孩子</span><br>            ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(l);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(r);<br>            &#125;<br>            <span class="hljs-comment">// 如果左孩子为空或者右孩子为空（证明左右孩子不双全）</span><br>            <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span> || r == <span class="hljs-literal">null</span>) &#123;<br>                leaf = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="满二叉树（FBT）："><a href="#满二叉树（FBT）：" class="headerlink" title="满二叉树（FBT）："></a>满二叉树（FBT）：</h1><p>节点个数（n）与最大深度（l）满足 n = (2^l) -1 节点个数等于2的最大深度次方减一</p><p><strong>如何判断一颗二叉树是否是满二叉树？</strong></p><p><strong>使用基本套路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFBT</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isF</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">Info</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> f(head);<br>        <span class="hljs-keyword">return</span> data.nodes == ((<span class="hljs-number">1</span> &lt;&lt; data.height) - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> nodes;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> n)</span> &#123;<br>            height = h;<br>            nodes = n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">f</span><span class="hljs-params">(Node x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">Info</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> f(x.left);<br>        <span class="hljs-type">Info</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> f(x.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.max(leftData.height, rightData.height) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nodes</span> <span class="hljs-operator">=</span> leftData.nodes + rightData.nodes + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(height, nodes);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉树（BBT）："><a href="#平衡二叉树（BBT）：" class="headerlink" title="平衡二叉树（BBT）："></a>平衡二叉树（BBT）：</h1><p>参考题：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">平衡二叉树</a></p><p>对于任何一个子树来说，左树的高度和右树的高度都不超过1。</p><p><strong>如何判断一颗二叉树是否是平衡二叉树？</strong></p><p>如果一棵树是平衡二叉树的话有<strong>三个条件</strong></p><p>假设X是头节点</p><p>1、X的左子树是平衡二叉树</p><p>2、X的右子树是平衡二叉树</p><p>3、对于X来讲，左树的高度减去右树的高度的绝对值小于等于1</p><p>1、2、3与逻辑都成立，X才是平衡二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBBT</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-type">ReturnType</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> process(head);<br>        <span class="hljs-keyword">return</span> process.isBalanced;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnType</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isBalanced; <span class="hljs-comment">// 返回这棵树是不是平衡的</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height; <span class="hljs-comment">// 返回这棵树的高度</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReturnType</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isB, <span class="hljs-type">int</span> hei)</span> &#123;<br>            isBalanced = isB;<br>            height = hei;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReturnType <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// base</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnType</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">ReturnType</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br>        <span class="hljs-type">ReturnType</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.max(leftData.height, rightData.height) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isBalanced</span> <span class="hljs-operator">=</span> leftData.isBalanced &amp;&amp; rightData.isBalanced &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnType</span>(isBalanced, height);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树题目基本套路："><a href="#二叉树题目基本套路：" class="headerlink" title="二叉树题目基本套路："></a>二叉树题目基本套路：</h1><p> 一切树型dp的问题，让自己的两颗子树给自己所需要的信息，然后自己给母树所需要的信息， 当各段的状态取定以后，就可以做出不同的决定，从而确定下一阶段的状态 </p><p><strong>什么时候可以使用这个套路？</strong></p><p>解题的时候 可以通过向左树要信息和向右树要信息来解题的时候可以使用这个基本套路</p><h2 id="最低公共祖先节点"><a href="#最低公共祖先节点" class="headerlink" title="最低公共祖先节点"></a>最低公共祖先节点</h2><p><strong>给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点</strong></p><p><strong>参考题：</strong></p><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LowestCommonAncestor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     可能出现的情况：</span><br><span class="hljs-comment">        1.o1是o2的最低公共祖先或者o2是o1的最低公共祖先</span><br><span class="hljs-comment">        2.o1与o2不互为最低公共祖先，需要往上汇聚才能找到最低公共祖先</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(Node head, Node o1, Node o2)</span> &#123;<br><br>        <span class="hljs-comment">//如果root为空或者root为o1,o2中的一个,说明root就是o1,o2的最近公共祖先</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head == o1 || head == o2) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(head.left, o1, o2);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(head.right, o1, o2);<br>        <span class="hljs-comment">//left 为空说明left没有公共祖先，那么返回right</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-comment">//反之亦然</span><br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 如果左树的头与右树的头都不是空，就返回当前的头</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220502165445024.png" alt="image-20220502165445024"></p><h2 id="前驱节点，后继结点"><a href="#前驱节点，后继结点" class="headerlink" title="前驱节点，后继结点"></a>前驱节点，后继结点</h2><p>前驱节点：中序遍历中，一个节点的前一个节点</p><p>后继结点：中序遍历中，一个节点的下一个节点</p><p>寻找后继结点的情况：</p><ol><li>x有右树的时候，x的后继节点就是x的右树的最左节点</li><li>x无右树的时候，x判断自己是不是父节点的左孩子，如果是x的后继节点就是这个父节点，如果不是就看父节点的父节点；如果找到最后一个父节点的时候，发现自己还不是左孩子，那么这个节点没有后继结点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuccessroNode</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>        <span class="hljs-keyword">public</span> Node parent;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getSuccessroNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> getLeftMost(node.right);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无右子树</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> node.parent;<br>            <span class="hljs-keyword">while</span> (parent != <span class="hljs-literal">null</span> &amp;&amp; parent.left != node) &#123; <span class="hljs-comment">// 当前节点是其父亲节点的右孩子</span><br>                node = parent;<br>                parent = node.parent;<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getLeftMost</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h2><p>就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializeAndReconstructTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 以head为头的树，请序列化成字符串返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">serialByPre</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#_&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.value + <span class="hljs-string">&quot;_&quot;</span>;<br>        res += serialByPre(head.left);<br>        res += serialByPre(head.right);<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br><br>    <span class="hljs-comment">// 反序列化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconByPreString</span><span class="hljs-params">(String perStr)</span> &#123;<br>        String[] values = perStr.split(<span class="hljs-string">&quot;_&quot;</span>);<br>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != values.length; i++) &#123;<br>            queue.add(values[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> reconPreOrder(queue);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconPreOrder</span><span class="hljs-params">(Queue&lt;String&gt; queue)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.valueOf(value));<br>        head.left = reconPreOrder(queue);<br>        head.right = reconPreOrder(queue);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h2><p>将一张纸对折，会出现折痕，第一次是凹下去的，成为凹折痕，再折一次，会在上一次的折痕上下方出现两个折痕，上方为凹下方为凸，依次类推，现在给出折的次数，请按照折痕的方向依次打印。</p><p><img src="/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91/1636515192108.png" alt="1636515192108"></p><p>其实就是中序遍历 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaperFolding</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllFolds</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>        printProcess(<span class="hljs-number">1</span>, N, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 递归过程，来到了某一个节点</span><br>    <span class="hljs-comment">// i是节点的层数，N一共的层数，down == true 凹 down == false 凸</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> N, <span class="hljs-type">boolean</span> down)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; N) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-literal">true</span>);<br>        System.out.println(down ? <span class="hljs-string">&quot;凹&quot;</span> : <span class="hljs-string">&quot;凸&quot;</span>);<br>        printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/05/02/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/02/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>分为单链表和多链表</p><p>单链表有一个指针，指向后继</p><p>多链表有两个指针，一个指向前驱，一个指向后继。</p><p><strong>题目：</strong>判断一个链表是否是回文结构(正着念跟反着念一样)</p><p>​            给定一个单链表的头节点head，请判断该链表是否为回文结构</p><p>​        1 -&gt;2 -&gt;1, 返回true  ；1-&gt;2-&gt;2-&gt;1,返回true;15-&gt;6-&gt;15,返回true，1-&gt;2-&gt;3，返回false</p><p><strong>思路</strong></p><p>笔试(不太考虑空间复杂度）：可以将链表上的数依次放入栈里去，然后出栈，弹出一个，比对一个，如果每一步都一样，就代表回文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPailndrome</span><span class="hljs-params">(Node head)</span>&#123;<br>    Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>)&#123;<br>        stack.push(cur);<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (head.value != stack.pop().value)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相对上一种省一点空间：可以将链表的右半部分放入栈，然后依次比对，直到栈空，如果都一样，代表回文那么，如何知道到了右半部分呢，用一个指针肯定不行，所以就引出了快慢指针，快指针一次走两步，慢指针一次走一步，快指针走完的时候，慢指针正好走到中点的位置。所以就将慢指针后边的东西放到栈里去</p><p>如果链表长度为N，时间复杂度达到O(N),额外空间复杂度达到O(1)。</p><p><strong>面试：</strong>快指针一次走两步，慢指针走一步，当快指针走完而慢指针走了一半的时候，将慢指针指向的那个数指向null，然后将后半部分处理成逆序链表，然后快慢指针同时往中间走，一次走一步，依次对比，知道一方指向空。如果每步都一样，就是回文。</p><p><img src="/2022/05/02/%E9%93%BE%E8%A1%A8/1634652601997.png" alt="1634652601997"></p><p><img src="/2022/05/02/%E9%93%BE%E8%A1%A8/1634656903440.png" alt="1634656903440">       <img src="/2022/05/02/%E9%93%BE%E8%A1%A8/Users\1457228183\AppData\Roaming\Typora\typora-user-images\1634656974746.png" alt="1634656974746"></p><p><img src="/2022/05/02/%E9%93%BE%E8%A1%A8/1634652929413.png" alt="1634652929413"></p><p>​        <strong>笔试：</strong>思路：将链表的数放在数组里面，在数组里面进行快速排序，达到效果</p><p>​        <strong>面试：</strong>思路：准备六个变量，分别是小于头，小于尾，等于头，等于尾，大于头，大于尾，让这六个变量都指向空。一个数字一个数字看，发现第一个小于的数，就把小于头小于尾都设置成这个，大于等于也一样，如果发现第二个，小于头不变，小于头指向前面一个小于尾，小于尾不再是小于尾，指向最新发现的数，最新发现的数变成小于尾，，最后小于尾指向等于头，等于尾指向大于头</p><p><img src="/2022/05/02/%E9%93%BE%E8%A1%A8/1634657601717.png" alt="1634657601717"></p><p>（小心没有等于五的区域或者没有大于五的或者没有小于五的）</p><p><img src="/2022/05/02/%E9%93%BE%E8%A1%A8/1634657851014.png" alt="1634657851014"></p><p><img src="/2022/05/02/%E9%93%BE%E8%A1%A8/1634657903539.png" alt="1634657903539"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2022/05/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>1、整体就是一个简单递归，左边排好序、右边排好序、让其整体有序</p><p>2、让其整体有序的过程里用了排外序方法</p><p>3、利用master公式来求解时间复杂度</p><p>4、归并排序的实质</p><p><strong>时间复杂度O(N*logN)，额外空间复杂度O(N)</strong></p><p>算法历程</p><p>这是一个无序数列：4、5、8、1、7、2、6、3，我们要将它按从小到大排序。按照归并排序的思想，我们要把序列逐层进行拆分                                                                                                                                                                                                                                                             </p><p><img src="https://img-blog.csdnimg.cn/20200619151838325.png" alt="[(快速1.png)]"></p><p>序列逐层拆分如下</p><p><img src="https://img-blog.csdnimg.cn/20200619151903848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzQ0MTk4,size_16,color_FFFFFF,t_70" alt="[(./归并1.png)]"></p><p>然后从下往上逐层合并，首先对第一层序列1（只包含元素4）和序列2（只包含元素5）进行合并</p><p>创建一个大序列，序列长度为两个小序列长度之和，p1、p2指针分别指向两个小序列的第一个元素，p指向大序列的第一个元素<br><img src="https://img-blog.csdnimg.cn/20200619151928587.png" alt="[(./归并2.png)]"></p><p>比较p1、p2指向的元素，4小于5，将4填入p指向的元素，p、p1往右移一位<br><img src="https://img-blog.csdnimg.cn/2020061915195029.png" alt="[(./归并3.png)]"><br>此时，序列1已经没有元素，将序列2的元素依次填入大序列中<br><img src="https://img-blog.csdnimg.cn/20200619152014989.png" alt="[(./归并4.png)]"></p><p>序列8和1，序列7和2，序列6和3，用同样的方式填入新的序列<br><img src="https://img-blog.csdnimg.cn/20200619152035747.png" alt="[(./归并5.png)]"><br>接着，以4、5为序列1，1、8为序列2，继续进行合并</p><p>创建一个序列长度为4的大序列，p1指向序列1的第一个元素4，p2指向序列2的第一个元素1，p指向大序列的第一个元素<br><img src="https://img-blog.csdnimg.cn/20200619152057575.png" alt="[(./归并6.png)]"></p><p>4和1比较，4大于1，1填入p指向的元素，p、p2往右移一位<br><img src="https://img-blog.csdnimg.cn/202006191521208.png" alt="[(./归并7.png)]"><br>4和8比较，4小于8，4填入p指向的元素，p、p1往右移一位<br><img src="https://img-blog.csdnimg.cn/20200619152136296.png" alt="[(./归并8.png)]"></p><p>5和8比较，5小于8，5填入p指向的元素，p、p1往右移一位<br><img src="https://img-blog.csdnimg.cn/202006191521593.png" alt="[(./归并9.png)]"><br>自此，序列1已经没有元素，将序列2的元素依次填入大序列中<br><img src="https://img-blog.csdnimg.cn/20200619152220636.png" alt="[(./归并10.png)]"></p><p>序列2、7和序列3、6以同样的方式合并成新的序列<br><img src="https://img-blog.csdnimg.cn/20200619152242410.png" alt="[(./归并11.png)]"><br>最后，将序列1、4、5、8和序列2、3、6、7以同样的方式继续合并成新的序列<br><img src="https://img-blog.csdnimg.cn/20200619152303145.png" alt="[(./归并12.png)]"></p><p>至此所有的元素都是有序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">if</span>(arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L == R)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L +((R - L) &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">// 求中点</span><br>    process(arr, L, mid);<br>    process(arr, mid+<span class="hljs-number">1</span>, R);<br>    merge(arr, L, mid, R);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> R)</span>&#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R- L + <span class="hljs-number">1</span>]; <span class="hljs-comment">//辅助数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> L;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> M + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123;<br>        help[i++] =arr[p1] &lt;= arr[p2] ? arr[p1++] ; arr[p2++];<br>       <br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= M)&#123;             <span class="hljs-comment">// 以下两个while只会执行一个 也就是p1 p2 必然会有一个越界</span><br>        help[i++] = arr[p1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p2 &lt;= R)&#123;<br>        help[i++] = arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>        arr[L + i] =help[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/image-20211019163323771.png" alt="image-20211019163323771"></p><p><strong>小和问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallSun</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">if</span>(arr==<span class="hljs-literal">null</span> || arr.length &lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> process(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//arr[L..R] 既要排好序，也要求小和</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i==r)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + ((r-<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> process(arr, l, mid)<span class="hljs-comment">/*左侧排序求小和的数量*/</span> <br>           + process(arr, mid + <span class="hljs-number">1</span>, r)<span class="hljs-comment">/*右侧排序求小和的数量*/</span><br>           +merge(arr, l, mid, r)<span class="hljs-comment">/*左侧和右侧merge后小和的数量*/</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r-L+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> L;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> m+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123;<br>        res += arr[p1] &lt; arr[p2] ? (r-p2+<span class="hljs-number">1</span>)<span class="hljs-comment">/*比当前的p1大的数的个数*/</span> * arr[p1] : <span class="hljs-number">0</span>;<br>        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= m)&#123;             <span class="hljs-comment">// 以下两个while只会执行一个 也就是p1 p2 必然会有一个越界</span><br>        help[i++] = arr[p1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p2 &lt;= R)&#123;<br>        help[i++] = arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>        arr[L + i] =help[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异或</title>
    <link href="/2022/05/02/%E5%BC%82%E6%88%96/"/>
    <url>/2022/05/02/%E5%BC%82%E6%88%96/</url>
    
    <content type="html"><![CDATA[<h1 id="异或（-）"><a href="#异或（-）" class="headerlink" title="异或（^）"></a>异或（^）</h1><p><strong>计算方法：相同为0不同为1（也可以理解为做和然后不进位）</strong></p><p>==<strong>性质：==</strong></p><p><strong>1、0^N= N；N^N = 0</strong></p><p><strong>2、满足交换律和结合律</strong></p><p><strong>如何交换两个数的值？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">17</span>; <br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br>a=a^b; <span class="hljs-comment">// a=17^23  b=23</span><br>b=a^b; <span class="hljs-comment">// a=17^23  b=17^23^23 =17</span><br>a=a^b; <span class="hljs-comment">// a=17^23^17=17^17^23=23  b=17</span><br></code></pre></td></tr></table></figure><p><strong>思考：</strong></p><ul><li><p>有一个数组中，有一个数字出现了奇数次，其余所有的数字出现了偶数次，求出现了奇数次的数字是几？</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">定义一个数<span class="hljs-keyword">eor</span>，将<span class="hljs-keyword">eor</span>与所有的数字异或，最后<span class="hljs-keyword">eor</span>就是出现了奇数次的数字<br><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] =&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 利用了异或运算的性质<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ero</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;arr.length; i++)&#123;<br>        ero^= arr[i];<br>    &#125;<br>    System.out.println(ero);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有一个数组中，有两个数字出现了奇数次，其余所有的数字出现了偶数次，求出现了奇数次的数字是几？</p><p>另外：提取出一个不等于0的二进制数的最右侧的1方法;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">eor&amp;(~eor + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">定义一个数eor，将eor与所有的数字异或，最后eor就是两个出现了奇数次的数字<br>因为a≠b，所以，a^b≠<span class="hljs-number">0</span>也就是说eor≠<span class="hljs-number">0</span><br>因此eor的二进制数有一位数字一定不为<span class="hljs-number">0</span><br>假设第八位为<span class="hljs-number">1</span>，（<span class="hljs-type">int</span> <span class="hljs-variable">rightOne</span> <span class="hljs-operator">=</span> eor &amp; (~eor + <span class="hljs-number">1</span>);<span class="hljs-comment">//提取出最右边的1）</span><br>定义一个eor1，eor1与所有第八位为<span class="hljs-number">1</span>的数字（(cur &amp; rughtOne) == <span class="hljs-number">1</span> ）异或，所得到的数字就是a or b<br>eor1^eor 所得到的数字就是a与b中另一个数字<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//进阶   </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">eor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;arr.length; i++)&#123;<br>            eor^= arr[i];<br>        &#125;<br>        <span class="hljs-comment">//ero必然有一个位置上是1</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">rightOne</span> <span class="hljs-operator">=</span> eor&amp;(~eor + <span class="hljs-number">1</span>);<span class="hljs-comment">//提取出最右侧的1</span><br><br>        <span class="hljs-comment">//一下到for循环完成表示取出那一类然后和err&#x27;异或运算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">onlyOne</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//eor&#x27;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur : arr)&#123;<br>            <span class="hljs-keyword">if</span> ((cur&amp;rightOne)==<span class="hljs-number">0</span>)&#123;<br>                onlyOne ^= cur;<span class="hljs-comment">//a或者b</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> eor ^ onlyOne;<br>        System.out.println(onlyOne + <span class="hljs-string">&quot;&quot;</span> + other);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>算法流程按照最差的情况来估计时间复杂度</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2022/05/02/%E9%80%92%E5%BD%92/"/>
    <url>/2022/05/02/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>自己调自己</p><h2 id="题外：求两数的中点"><a href="#题外：求两数的中点" class="headerlink" title="题外：求两数的中点"></a>题外：求两数的中点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//       int mid = (L+R)/2;这种情况用于数组有小概率会溢出</span><br><br><span class="hljs-comment">//       int mid = L+(R-L)/2;这种不会溢出</span><br><br><span class="hljs-comment">//       int mid = L+((R-L)&gt;&gt;1);  第二种方式的另一种写法</span><br></code></pre></td></tr></table></figure><h2 id="题目-求一个数组中一个范围内的最大值"><a href="#题目-求一个数组中一个范围内的最大值" class="headerlink" title="题目:求一个数组中一个范围内的最大值"></a>题目:求一个数组中一个范围内的最大值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span>&#123;<br>    <span class="hljs-keyword">if</span> (L==R)&#123;<br>        <span class="hljs-keyword">return</span> arr[L];<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R-L)&gt;&gt;<span class="hljs-number">1</span>);<span class="hljs-comment">//中点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> a(arr,L,mid);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> a(arr,mid+<span class="hljs-number">1</span>,R);<br>    <span class="hljs-keyword">return</span> Math.max(leftMax,rightMax);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">return</span> a(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="master公式"><a href="#master公式" class="headerlink" title="master公式"></a>master公式</h2><p><code> T [n] = aT[n/b] + f (n)（直接记为T [n] = aT[n/b] + O (N^d)）</code></p><p>需要子问题规模一样</p><p>a表示子问题数</p><p>T[n/b]表示子问题规模与主问题规模的关系，</p><p> O (N^d)表示除了递归调用其他部分的时间复杂度</p><p>用来直接计算符合master公式的问题的时间复杂度</p><p><img src="/2022/05/02/%E9%80%92%E5%BD%92/1634203498370.png" alt="1634203498370"></p><p><code>当d&lt;logb a时，时间复杂度为O(n^(logb a)) 当d=logb a时，时间复杂度为O((n^d)*logn) 当d&gt;logb a时，时间复杂度为O(n^d) </code></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2022/05/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>时间复杂度为O(N²)，额外空间复杂度为O(1)</strong></p><p>1、首先，原始的数组元素是这样的。<br><img src="https://img-blog.csdnimg.cn/20200628114521779.png" alt="img">      <br>     其中，浅绿色代表有序部分，黄色代表无序部分。<br>2、在无序部分中挑出要插入到有序部分中的元素</p><p><img src="https://img-blog.csdnimg.cn/2020062811465959.png" alt="img"></p><p>3、将要插入的元素与左边最近的有序部分的元素进行比较。由于4 &lt; 9，所以9向后移，4向前移。</p><p><img src="https://img-blog.csdnimg.cn/20200628114819195.png" alt="img"></p><p>4、继续将要插入的元素与左边最近的有序部分的元素进行比较。由于4 &lt; 5，所以5向后移，4继续向前移。<br><img src="https://img-blog.csdnimg.cn/20200628114914202.png" alt="img"><br>5、继续将4与3比较。由于4 &gt; 3，所以不再向前比较，插入到当前位置。<br><img src="https://img-blog.csdnimg.cn/2020062811502541.png" alt="img"><br>6、此时有序部分，由[2,3,5,9]变成[2,3,4,5,9]。</p><p><img src="https://img-blog.csdnimg.cn/20200628115113443.png" alt="img"></p><p>7、最后数组变为[2,3,4,5,7,9]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-comment">//排除捣乱的数据</span><br>      <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>||arr.length&lt;<span class="hljs-number">2</span>)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <br>      <span class="hljs-comment">//0-0 有序的</span><br>      <span class="hljs-comment">//0-i 想要有序</span><br>      <br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++)&#123;<br><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i-<span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="hljs-number">1</span>]; j--)&#123;<br>            swap(arr,j,j+<span class="hljs-number">1</span>);<br>          &#125;<br>          <br>      &#125;<br>      <br>    &#125;<br><span class="hljs-comment">//交换i和j的数字（这是一种抖机灵的写法，如果i和j地址不一样的话可以用，如果地址一致，数字就会变为0）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        arr[i] = arr[i]^arr[j];<br>        arr[j] = arr[i]^arr[j];<br>        arr[i] = arr[i]^arr[j];<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2022/05/02/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2022/05/02/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="1、在一个有序数组中，找某个数是否存在"><a href="#1、在一个有序数组中，找某个数是否存在" class="headerlink" title="1、在一个有序数组中，找某个数是否存在"></a><strong>1、在一个有序数组中，找某个数是否存在</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有序，小到大查找某值.</span><br><span class="hljs-type">int</span> fir=<span class="hljs-number">0</span>,last=arr_length-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (fir&lt;=last)&#123;<br>mid=(fir+last)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (arr[mid]==num)<br><span class="hljs-keyword">return</span> mid;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span> (arr[mid]&lt;num)<br>fir=mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>last=mid-<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2、在一个有序数组中，找-gt-某个数最左侧的位置（找-lt-某个数最右侧的位置）"><a href="#2、在一个有序数组中，找-gt-某个数最左侧的位置（找-lt-某个数最右侧的位置）" class="headerlink" title="2、在一个有序数组中，找&gt;=某个数最左侧的位置（找&lt;=某个数最右侧的位置）"></a><strong>2、在一个有序数组中，找&gt;=某个数最左侧的位置（找&lt;=某个数最右侧的位置）</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> fir=<span class="hljs-number">0</span>,last=arr_length-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (fir&lt;=last)&#123;<br>mid=(fir+last)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>  (arr[mid]&gt;=num)<br>last=mid-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> (arr[mid]&lt;num)<br>ir=mid+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、局部最小值问题"><a href="#3、局部最小值问题" class="headerlink" title="3、局部最小值问题"></a><strong>3、局部最小值问题</strong></h2><p>问题：在一个无序数组中，任何两个相邻的数不相等，求一个局部最小的位置，要求时间复杂度好于O(n)。</p><p>​    局部最小：i比相邻的数都小</p><p>思路：</p><p>​    1、判断该数组在0位置上是不是局部最小值（不是则数组从0位置开始存在下降趋势）</p><p>​    2、判断该数组在N-1位置上是不是局部最小值（不是则数组从N-1位置开始存在上升趋势）</p><p>​    3、由1 2 可得，该数组局部最小值一定在0~N-1范围上</p><p>​    4、取中点位置M,若M&lt;M-1且M&lt;M+1，则直接返回M位置的数；若M&gt;M-1，则数组在0<del>M上一定存在最小值，若M&gt;M+1, 则数组在M</del>N-1上一定存在最小值</p><p>思路：先找第一个数，如果他比第二个小，直接返回，如果大，找最后一个数，如果比前一个小，直接返回，如果    大，则说明第二个比第一个大，倒数第二个一定比倒数第一个小，所以整个数组是先有上升趋势，再有向下趋    势，所以他中间必有一个最小的点，所以直接二分，找中间的那个数，然后如果他是局部最小，则直接返回，       否则将他看成第一个或者最后一个进行上述步骤，直到找到那个局部最小；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>  <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-comment">//排除一些情况</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[n-<span class="hljs-number">1</span>]&gt;arr[n-<span class="hljs-number">2</span>])&#123;<br>            <span class="hljs-keyword">return</span> n-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//定义第一个和最后一个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (low&lt;high)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//如果这个中间值就是局部最小值就返回</span><br>            <span class="hljs-keyword">if</span> (arr[mid-<span class="hljs-number">1</span>]&lt;arr[mid] &amp;&amp; arr[mid]&gt;arr[mid+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">return</span> mid;<br>                    <span class="hljs-comment">//如果他这里是顺序递增，就把他设为最小值</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid-<span class="hljs-number">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid+<span class="hljs-number">1</span>])&#123;<br>                low = mid;<br>                <span class="hljs-comment">//如果他这里是前一个大于他，后一个小于他，把它设置为对于前半部分的最大值或者对于后半部分的最小值</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid-<span class="hljs-number">1</span>] &gt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid+<span class="hljs-number">1</span>])&#123;<br>                low = mid;<br>                <span class="hljs-comment">//否则就是最大值</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                high = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123; -<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br>        System.out.println(a(nums));<br>    &#125;<br><br><br>输出结果：<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/05/02/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/02/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>(1)给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)</p><p>​        思路：如果[i]&lt;=num  [i]和小于等于区的下一个交换，小于等于区扩大一个，i++；</p><p>​                    如果[i]&gt;num，i++</p><p>​                    </p><p>(2)给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)</p><p>​        思路：[i]&lt;num,i]和小于区的下一个交换,小于区域右扩，i++；</p><p>​                    [i]=num,i++；</p><p>​                    [i]&gt;num，[i]和大于区域的前一个做交换，大于区域左扩，i不变(因为i是新的了)</p><h3 id="快排1-0"><a href="#快排1-0" class="headerlink" title="快排1.0"></a>快排1.0</h3><p>​        就是最后一个值就是num，让前面的所有的小于0的放在左边。大于num的放在右边，让num和大于区域的最左边做交换，就相当于小于num区域被扩充了并且最后一个数就是num，然后让左侧和右侧继续这个过程</p><h3 id="快排2-0"><a href="#快排2-0" class="headerlink" title="快排2.0"></a>快排2.0</h3><p>​        原理和荷兰国旗（2）类似，让最后一个值为num，然后把数组分成小于等于大于num的之后，将num与大于的第一个做交换，让等于num的放在一起，等于num的区域就不需要动了，再让另外两个区域重复这个过程</p><p><strong>快排1.0和2.0都是O(n^2)</strong></p><h3 id="快排3-0"><a href="#快排3-0" class="headerlink" title="快排3.0"></a>快排3.0</h3><p>在数组中随机选择一个数，将这个数和最后一个数交换作为最后一个数，这个算法的复杂度就变成了随机事件，但是将这些概率变成期望，则这个算法的时间复杂度为O(n*logN)</p><p><strong>时间复杂度最低的快速排序，</strong>在数组中随机找一个数，然后将他与最后一个数字交换，然后以最后一个数字为num进行荷兰国旗问题，同时在小于和大于num的区域随机选取一个数字，然后将他与小于和大于num区域的最后一个数字交换重复执行荷兰国旗问题，最后得到一串从小到大排序的数组，<strong>时间复杂度为O(N*logN)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">if</span>(arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    quickSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//arr[l...r]排好序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;R)&#123;<br>        swap(arr,L+(<span class="hljs-type">int</span>) (Math.random() * (R-L+<span class="hljs-number">1</span>)), R); <span class="hljs-comment">//swap为自带的交换函数；L+(int) (Math.random() * (R-L+1)) 表示在该数组中随机选取一位数字</span><br>        <span class="hljs-type">int</span>[] p = partition(arr,L,R);<br>        quitSort(arr,L,p[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>); <span class="hljs-comment">// &lt;区</span><br>        quitSort(arr,p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,R); <span class="hljs-comment">// &gt;区</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//这是一个处理arr[l...r]的函数</span><br><span class="hljs-comment">//默认以arr[r]做划分，arr[r] -&gt; p    &lt;p   ==p    &gt;p</span><br><span class="hljs-comment">//返回等于区域（左边界，右边界），所以返回一个长度为2的数组res，res[0] res[1]</span><br><span class="hljs-keyword">public</span> staic <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt;区右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R; <span class="hljs-comment">// &gt;区左边界</span><br>    <span class="hljs-keyword">while</span>(L &lt; more)&#123; <span class="hljs-comment">// L表示当前数的位置 arr[R] -&gt; 划分值</span><br>        <span class="hljs-keyword">if</span>(arr[L] &lt; arr[R])&#123; <span class="hljs-comment">//当前数  &lt;  划分值</span><br>            less++;<br>            swap(arr, less, L);<br>            L++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[L] &gt; arr[R])&#123; <span class="hljs-comment">// 当前值 &gt; 划分值</span><br>            more--;<br>            swap(arr, more, L);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            L++;<br>        &#125;<br>    &#125;<br>    swap(arr,more,R);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;less + <span class="hljs-number">1</span>,more&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2022/05/02/%E5%A0%86/"/>
    <url>/2022/05/02/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一种比较特殊的完全二叉树，分为大根堆，小根堆</p><p>1、堆结构就是用数组实现完全的二叉树结构</p><p>2、完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p><p>3、完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p><p>4、对结构的heapInsert与heapify操作</p><p>5、堆结构的增大和减少</p><p>6、优先级队列结构，就是堆结构</p><p><strong>大根堆</strong>即指在逻辑上的二叉树结构中，根结点&gt;子结点，总是最大的，<strong>并且在堆的每一个局部都是如此</strong></p><p><strong>小根堆</strong>的性质与大根堆类似，只不过在二叉树的结构中，根结点&lt;子结点</p><h2 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h2><p><img src="/2022/05/02/%E5%A0%86/1634370387111.png" alt="1634370387111"></p><p>以n为首的整棵树最大值为n</p><h2 id="小根堆相反"><a href="#小根堆相反" class="headerlink" title="小根堆相反"></a>小根堆相反</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><br>        <span class="hljs-comment">//堆结构，如果不给构造方法传参的话，默认小根堆(如果想让他是一个大根堆的话，就传一个比较器)</span><br>        PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        heap.add(<span class="hljs-number">8</span>);<br>        heap.add(<span class="hljs-number">4</span>);<br>        heap.add(<span class="hljs-number">4</span>);<br>        heap.add(<span class="hljs-number">9</span>);<br>        heap.add(<span class="hljs-number">10</span>);<br>        heap.add(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">while</span> (!heap.isEmpty())&#123;<br>            System.out.println(heap.poll());<br>        &#125;<br>    &#125;<br><br>输出结果：<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">4</span>，<span class="hljs-number">8</span>，<span class="hljs-number">9</span>，<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>题目：用户往数组中输入了几个数字，现在用户需要找到最大值，然后去掉，让剩下的数再组成一个大根堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//某个数在index位置，能否往下移动</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> heapSize)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//左孩子的下标</span><br><br>    <span class="hljs-keyword">while</span> (left &lt; heapSize)&#123;   <span class="hljs-comment">//下方还有孩子的时候(左孩子比右孩子小，当没有左孩子的时候，就没有右孩子)</span><br><br>        <span class="hljs-comment">//两个孩子，谁的值大，把下标给largest</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left+<span class="hljs-number">1</span> : left;<br><br>        <span class="hljs-comment">//父和孩子，谁的值大，把下标给largest</span><br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br><br>        <span class="hljs-keyword">if</span> (largest == index)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(arr,largest,index);<br><br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>O(n)*logN </p><p>题：已知一个几乎有序的数组，几乎有序的意思是，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小，请选择一个合适的排序算法针对这个数据进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> k)</span>&#123;<br><br>    <span class="hljs-comment">//默认小根堆</span><br>    PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//                  防止k捣乱</span><br>    <span class="hljs-keyword">for</span> (; index &lt; Math.min(arr.length , k); index++)&#123;<br>        heap.add(arr[index]);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;index &lt; arr.length; i++ , index++)&#123;<br>        heap.add(arr[index]);<br>        arr[i] = heap.poll();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!heap.isEmpty())&#123;<br>        arr[i++] = heap.poll();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/02/%E5%A0%86/1634610114793.png" alt="1634610114793"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的深度</title>
    <link href="/2022/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <url>/2022/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/image-20220429144838269.png" alt="image-20220429144838269"></p><p><strong>解法：(递归)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据流中的中位数</title>
    <link href="/2022/04/29/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/04/29/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/29/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220429124407888.png" alt="数据流中的中位数"></p><p><strong>大根堆</strong>即指在逻辑上的二叉树结构中，根结点&gt;子结点，总是最大的，<strong>并且在堆的每一个局部都是如此</strong></p><p><strong>小根堆</strong>的性质与大根堆类似，只不过在二叉树的结构中，根结点&lt;子结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>   <span class="hljs-comment">//小根堆</span><br>    PriorityQueue&lt;Integer&gt; A;<br>    <span class="hljs-comment">//大根堆</span><br>    PriorityQueue&lt;Integer&gt; B;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (A.size() != B.size()) &#123;<br>            <span class="hljs-comment">// 两个堆</span><br>            A.add(num);<br>            B.add(A.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            B.add(num);<br>            A.add(B.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (A.size() == B.size()) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) (A.peek() + B.peek())/<span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//奇数，直接返回小的堆顶</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)A.peek();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj.addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扑克牌中的顺子</title>
    <link href="/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <url>/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/image-20220428170008577.png" alt="扑克牌中的顺子"></p><p><strong>解法：（排序）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStraight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 定义大小王的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">jocker</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<span class="hljs-comment">// 对nums进行排序（可以判断大小王的数量）</span><br>        <span class="hljs-comment">// 为什么i &lt; 4 因为需要判断这个数与后面的数是否重复，i &lt; 4</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                jocker++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[jocker] &lt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把数组排成最小的数</title>
    <link href="/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <url>/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/image-20220428163449786.png" alt="把数组排成最小的数"></p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树的第k大节点</title>
    <link href="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <url>/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/image-20220428162801246.png" alt="二叉搜索树的第k大节点"></p><p><strong>解法：</strong></p><p>二叉搜索树：右节点大，所以判断第几大的时候就先遍历右节点，然后右节点遍历一次 k–，直到k变成1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> res;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            res = root.val;<br>        &#125;<br>        k--;<br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树与双向链表</title>
    <link href="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20220428151835975.png" alt="二叉搜索树与双向链表"></p><p><strong>解法：（中序遍历）</strong></p><p><strong>二叉搜索树：</strong>若它的左子树不空，则左子树上所有结点的值均小于它的 根结点 的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为 二叉排序树 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node left;</span><br><span class="hljs-comment">    public Node right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Node pre, head;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dfs(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>) pre.right = cur;<br>        <span class="hljs-keyword">else</span> head = cur;<br>        cur.left = pre;<br>        pre = cur;<br>        dfs(cur.right);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树中何为某一值的路径</title>
    <link href="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428143306147.png" alt="二叉树中何为某一值的路径"><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-comment">// list:子树的和</span><br>    <span class="hljs-comment">// res:结果集</span><br>    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        dfs(root, target, sum);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-comment">//等于空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        list.add(root.val);<br>        <span class="hljs-comment">//符合情况,即叶子节点加之前的sum等于target</span><br>        <span class="hljs-keyword">if</span> (sum + root.val == target &amp;&amp; root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<br>        &#125;<br>        dfs(root.left, target, sum + root.val);<br>        dfs(root.right, target, sum + root.val);<br>        <span class="hljs-comment">// sum -= root.val;</span><br>        <span class="hljs-comment">//清除list</span><br>        list.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220428104546299.png" alt="机器人的运动范围"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 用来判断格子是否已经被走过</span><br>        <span class="hljs-type">boolean</span>[][] istrue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n, k, istrue);<br>    &#125;<br><br>    <span class="hljs-comment">// a,b当前位置；</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">boolean</span>[][] istrue)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n<br>                &amp;&amp; (a % <span class="hljs-number">10</span> + a / <span class="hljs-number">10</span> + a / <span class="hljs-number">100</span> + b % <span class="hljs-number">10</span> + b / <span class="hljs-number">10</span> + b / <span class="hljs-number">100</span>) &lt;= k<br>                &amp;&amp; istrue[a][b] == <span class="hljs-literal">false</span>) &#123;<br>            istrue[a][b] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 1是(0,0)位置</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(a + <span class="hljs-number">1</span>, b, m, n, k, istrue)<br>                    + dfs(a - <span class="hljs-number">1</span>, b, m, n, k, istrue)<br>                    + dfs(a, b + <span class="hljs-number">1</span>, m, n, k, istrue)<br>                    + dfs(a, b - <span class="hljs-number">1</span>, m, n, k, istrue);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵中的路径</title>
    <link href="/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428103103367.png" alt="矩阵中的路径"></p><p><strong>解法：（DFS）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-comment">// toCharArray()将字符串转换为字符数组。</span><br>        <span class="hljs-type">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-comment">// 遍历board中的所有元素，将所有元素进行dfs()</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-comment">//如果找到，再返回true</span><br>                <span class="hljs-keyword">if</span> (dfs(board,chars,i,j,<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//数组，单词，长宽，宽度，k：第几个字母</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">char</span>[] chars,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//如果越界或者没找到字母</span><br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span> || m &gt; board.length - <span class="hljs-number">1</span> || n &lt;<span class="hljs-number">0</span> || n &gt; board[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> || board[m][n] != chars[k]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到了字母并且是最后一个</span><br>        <span class="hljs-keyword">if</span> (board[m][n] == chars[k] &amp;&amp; k == chars.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到字母但不是最后一个,就让他看他的上下左右，已经走过的让它变成~以防止再次访问，dfs之后要回退，因为在下一次dfs时候还可能再次访问这个格子</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span>  board[m][n] ;<br>        board[m][n] = <span class="hljs-string">&#x27;~&#x27;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span>  dfs(board,chars,m + <span class="hljs-number">1</span>,n,k + <span class="hljs-number">1</span>) || dfs(board,chars,m,n + <span class="hljs-number">1</span>,k + <span class="hljs-number">1</span>) || dfs(board,chars,m - <span class="hljs-number">1</span>,n,k + <span class="hljs-number">1</span>) || dfs(board,chars,m,n - <span class="hljs-number">1</span>,k + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 四个格子都尝试了之后 恢复到原来的样子</span><br>        board[m][n] = s;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转单词顺序</title>
    <link href="/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/image-20220426214848087.png" alt="翻转单词顺序"></p><p><strong>解法：（快慢指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 去掉首位的空格</span><br>        s = s.trim();<br>        <span class="hljs-comment">// 加入两个快慢指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 当i不是空格的时候 往左遍历</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            <span class="hljs-comment">// j指向下一个单词</span><br>            j = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和为s的两个数字</title>
    <link href="/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <url>/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/image-20220426162523495.png" alt="和为s的两个数字"></p><p><strong>解法：（左右指针）</strong></p><p>定义左右指针，左右指针的值的和sum，如果sum&gt;target，那么右指针往左；如果sum&lt;target，那么左指针往右；如果sum== target，那么输出数组[nums[i],nums[j]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j];<br>            <span class="hljs-keyword">if</span> (sum &lt; target)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[i],nums[j]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <link href="/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <url>/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/image-20220426155826475.png" alt="调整数组顺序使奇数位于偶数前面"></p><p><strong>解法：（左右指针）</strong></p><p>左指针指向偶数的时候，右指针指向奇数的时候就左右指针的值通过一个中间值进行交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exchange(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[left] % <span class="hljs-number">2</span>) == <span class="hljs-number">1</span>) left++;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[right] % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) right--;<br>            tmp = nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个链表的第一个公共节点</title>
    <link href="/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <url>/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/image-20220426153130626.png" alt="两个链表的第一个公共节点"></p><p><strong>解法：（双指针）</strong></p><p>假设链表headA有a个节点，链表headB有b个节点，公共节点距离链表尾部有c个节点；</p><p>那么链表headA从开始到公共节点有a-c个节点，链表headB从开始到公告节点有b-c个节点，</p><p>当链表headA的指针A遍历完链表headA之后遍历链表headB，当走到公共节点的时候一共走了a-c+c+b-c = a+b-c步数</p><p>当链表headB的指针B遍历完链表headB之后遍历链表headA，当走到公共节点的时候一共走了b-c+c+a-c = b+a-c步数</p><p>此时</p><p>1、A与B重合若两链表 有公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node</p><p>2、若两链表 无 公共尾部 (即 c = 0 ) ：指针 A，B 同时指向 null 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-keyword">while</span> (A != B) &#123;<br>            A = A != <span class="hljs-literal">null</span> ? A.next : headB;<br>            B = B != <span class="hljs-literal">null</span> ? B.next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220426145316487.png" alt="合并两个排序的链表"></p><p><strong>解法一：（双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br><br>    ListNode(<span class="hljs-type">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">// 定义一个伪节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> a;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = (l1 != <span class="hljs-literal">null</span> ? l1 : l2);<br>        <span class="hljs-keyword">return</span> a.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（递归）</strong></p><p>一个一个节点的判断，l1的头节点与l2的头节点进行比较，然后节点往下判断下一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br><br>    ListNode(<span class="hljs-type">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表中倒数第k个节点</title>
    <link href="/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220425223235483.png" alt="链表中倒数第k个节点"></p><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-comment">// 先让快的走k个距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 当快的走到了最后的时候，慢的链表就是所要求的链表</span><br>        <span class="hljs-keyword">while</span> (fast!=<span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的节点</title>
    <link href="/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/image-20220425213903008.png" alt="删除链表的节点"></p><p><strong>解法一：（双节点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.val != val) &#123;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//证明找到了要删除的节点,跳过这个要删除的节点</span><br>            pre.next = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（递归）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            <span class="hljs-comment">// 如果发现你的这个节点的值就是所要求的值，那么直接跳过这个节点</span><br>            head = head.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则自调</span><br>            head.next = deleteNode(head.next, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <link href="/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425161854980.png" alt="最长不含重复字符的子字符串"></p><p><strong>解法一：</strong>（哈希表+动态规划）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// res结果 tmp当前长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>            <span class="hljs-comment">//找到j左边最近的与j位置字母相等的字母</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//找到的话就将这个字母置于j位置，没找到的话j位置置为-1</span><br>            dic.put(s.charAt(j), j);<br>            <span class="hljs-keyword">if</span> (tmp &lt; j - i) &#123;<br>                <span class="hljs-comment">//如果tmp &lt; j - i，就证明，没有遇到相同的字母，长度+1</span><br>                tmp = tmp + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//否则就是遇到了相等的字母，则左边界就应该由i来决定</span><br>                tmp = j - i;<br>            &#125;<br>            res = Math.max(res, tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓展：</p><div class="note note-success">            <p>哈希表的getOrDefault(key, default)方法，是在哈希表中搜索是否存在该方法参数列表中的key值，如果存在该key值，则返回哈希表中该key值对应的vakue值；如果不存在，则返回该方法参数列表中的default值</p>          </div>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把数字翻译成字符串</title>
    <link href="/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425153822764.png" alt="把数字翻译成字符串"></p><p><strong>解法：</strong></p><p>看见题就能想到要不两个数字作为一个字符输出，要不一个数字作为一个字符输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 把数字变成string类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-comment">// 如果不+1，如果我给的num长度为3，那么转换成string类型长度也为3</span><br>        <span class="hljs-comment">// 到了for循环的时候从2开始就拿不到2个就出现越界问题</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 当num第1,2位的组成的数字∈[10,25]时，显然应有2种翻译方法，</span><br>        <span class="hljs-comment">// 即dp[2]=dp[1]+dp[0]=2，而显然dp[1] = 1因此推出dp[0] = 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-comment">// 取出两位</span><br>            <span class="hljs-comment">// substring这个方法截取的字符串从i-2开始，到字符串索引的i - 1结束</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s.substring(i - <span class="hljs-number">2</span>, i);<br>            <span class="hljs-comment">// 如果两位数的ASCII码差值在10~25之间 证明可以转换成为一个字符</span><br>            <span class="hljs-keyword">if</span> (tmp.compareTo(<span class="hljs-string">&quot;10&quot;</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp.compareTo(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 一位计算</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>礼物的最大价值</title>
    <link href="/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <url>/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220425104246376.png" alt="礼物的最大价值"></p><p><strong>解法一：</strong></p><p>暴力递归，对于一个格子只有两种情况：不是向下移动就是向右移动，所以定义两个变量，一个 == 向右移动的值 一个 == 向下移动的值 ，然后取max + 这个格子左上角的值</p><p>代码 <em>略</em></p><p><strong>解法二：</strong></p><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test14</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// 定义行和列</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">column</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 多加一行一列 所以dp[1][0..column]相当于grid[0][0...column]</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row + <span class="hljs-number">1</span>][column + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[1][0..column]相当于grid[0][0...column] 所以i与j从1开始 直到 等于行与列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= column; j++) &#123;<br>                dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row][column];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] grid = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        System.out.println(maxValue(grid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql8通过Data文件恢复数据</title>
    <link href="/2022/04/21/mysql8%E9%80%9A%E8%BF%87Data%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/04/21/mysql8%E9%80%9A%E8%BF%87Data%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>原因：数据库突然开不开了，怕麻烦就没有备份数据库，只留下了Data文件，结果新版本mysql不能使用旧版本的data，单纯的替换ibdata1文件也不行。</p><p><strong>操作：</strong></p><p>1、打开任务管理器，关闭MySQL80.exe</p><p>2、需要覆盖的文件：ibdata1，ib_logfile0，ib_logfile1，ib_buffer_pool，auto.cnf，mysql.ibd</p><p>3、重新打开MySQL80.exe</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h1><p>动态规划：如果你发现你有重复调用的过程动态规划再算过一次之后把答案记下来，下一次再遇到重复过程直接调这个行为就叫动态规划（空间换时间）</p><p>暴力递归 –&gt;傻缓存–&gt;动态规划</p><p>最简单的例子：斐波那契数列</p><h1 id="机器人走路问题"><a href="#机器人走路问题" class="headerlink" title="机器人走路问题"></a>机器人走路问题</h1><div class="note note-primary">            <p><strong>题目：</strong></p><p>假设有拍成一行的N个位置记为1到N，N一定大于等于2；</p><p>开始时机器人在其中的M位置上（M一定是1到N中的一个）；</p><p>如果机器人来到1位置那么下一步只能往右来到2位置；</p><p>如果机器人来到N位置那么下一步只能往左来到N-1位置；</p><p>规定机器人一定要走K步，最终能来到P位置（P也是1~N中的一个）的方法有多少种；</p><p>给定四个桉树N，M，K，P，返回方法数</p>          </div><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code1_RobotWalk</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ways1</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> process1(start, K, aim, N);<br>    &#125;<br><br>    <span class="hljs-comment">// 机器人当前来到的位置是cur</span><br>    <span class="hljs-comment">// 机器人还有rest步需要走</span><br>    <span class="hljs-comment">// 最终要去的地方是aim</span><br>    <span class="hljs-comment">// 有哪些位置？1~N</span><br>    <span class="hljs-comment">// 返回值：机器人从cur开始走，走过rest部署之后最后停在aim地方的方法数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process1</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> N)</span> &#123;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果已经不需要走了，那就是走完了所有的rest步数</span><br>            <span class="hljs-type">return</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span>= aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// rest &gt; 0 还有步数需要走</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果机器人在1那么只能走向2的位置 1-&gt;2</span><br>            <span class="hljs-comment">// 如果我机器人在1那么他只能去2，也就是说 机器人从1走rest步数到aim相当于机器人从2位置走rest-1部署走到aim</span><br>            <span class="hljs-keyword">return</span> process1(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>        &#125;<br>        <span class="hljs-comment">// 同理对于机器人在N位置也是只能走向N-1位置</span><br>        <span class="hljs-keyword">if</span> (cur == N) &#123; <span class="hljs-comment">// N-&gt;N-1</span><br>            <span class="hljs-keyword">return</span> process1(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>        &#125;<br>        <span class="hljs-comment">// 机器人在除了1和N的其他位置上</span><br>        <span class="hljs-keyword">return</span> process1(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N) + process1(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ways1(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法2：（对解法1进行优化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code1_RobotWalk</span> &#123;<br><span class="hljs-comment">// 优化：因为ways1会存在计算同一个位置与步数的情况,因为会有重复过程</span><br>    <span class="hljs-comment">// dp作为一个缓存，就是一个如果你没计算过这个位置与步数的信息那么就是-1，然后去计算</span><br>    <span class="hljs-comment">// 如果已经计算过了，那么就是你将你计算的值付给dp[cur][rest]然后下次需要的时候就直接拿上用，避免重复计算</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ways2</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= K; j++) &#123;<br>                dp[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp就是缓存表</span><br>        <span class="hljs-comment">// dp[cur][rest] == -1   -&gt;   process1(cur, rest) 之前没算过！</span><br>        <span class="hljs-comment">// dp[cur][rest] != -1   -&gt;   process1(cur, rest) 之前算过！返回值，dp[cur][rest]</span><br>        <span class="hljs-comment">// K+1 * N+1 的二维数组 保证任何一组参数组合都能放到这个二维数组内部</span><br>        <span class="hljs-keyword">return</span> process2(start, K, aim, N, dp);<br>    &#125;<br><br>    <span class="hljs-comment">// cur范围： 1~N</span><br>    <span class="hljs-comment">// rest范围： 0~K</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process2</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span>[][] dp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[cur][rest] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> dp[cur][rest];<br>        &#125;<br>        <span class="hljs-comment">// 之前没算过</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">return</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>            ans = process2(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == N) &#123;<br>            ans = process2(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = process2(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp) + process2(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125;<br>        <span class="hljs-comment">// 相当于只算了一次在一个位置同一个步数的情况</span><br>        dp[cur][rest] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ways2(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法三：（最终优化）</strong></p><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220421215607265.png" alt="image-20220421215607265"></p><p>由此可以对问题进行最终的优化：第0列除了dp[ aim] [ 0] =1其余都是0，第一行与第N行进行手动赋值，其余的都是等于上一行的前一个与下一行的前一个之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code1_RobotWalk</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 画一个二维数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ways3</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];<br>        dp[aim][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// dp[...][0] = 0; java中自动就是0</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; rest &lt;= K; rest++) &#123;<br>            <span class="hljs-comment">// 第一行手动赋值</span><br>            dp[<span class="hljs-number">1</span>][rest] = dp[<span class="hljs-number">2</span>][rest - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; cur &lt; N; cur++) &#123;<br>                dp[cur][rest] = dp[cur - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>] + dp[cur + <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 最后一行手动赋值</span><br>            dp[N][rest] = dp[N - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[start][K];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ways3(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="扑克牌问题"><a href="#扑克牌问题" class="headerlink" title="扑克牌问题"></a>扑克牌问题</h1><div class="note note-primary">            <p><strong>题目</strong></p><p>给定一个整型数组arr（数组内的数都是正数），代表数值不同的指派排成一条线</p><p>玩家A和玩家B依次拿走每张纸牌</p><p>规定玩家A先拿，玩家B后拿</p><p>但是每个玩家每次只能拿走最左或最右的纸牌</p><p>玩家A和玩家B都聪明绝顶</p><p>请返回最后获胜者的分数</p>          </div><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code2_CardsinLine</span> &#123;<br><br>    <span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">win1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> f(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> g(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(first, second);<br>    &#125;<br><br>    <span class="hljs-comment">// 先手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，先手获得的最好的分数返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span> arr[L];<br>        &#125;<br>        <span class="hljs-comment">// 1：我拿走左侧的牌，然后我在L+1到R上获得的最好的牌</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> arr[L] + g(arr, L + <span class="hljs-number">1</span>, R);<br>        <span class="hljs-comment">// 2：我拿走左侧的牌，然后我在L到R-1上获得的最好的牌</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> arr[R] + g(arr, L, R - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> Math.max(p1, p2);<br>    &#125;<br><br>    <span class="hljs-comment">// 后手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，后手获得的最好的分数返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> f(arr, L + <span class="hljs-number">1</span>, R); <span class="hljs-comment">// 对手拿走了L位置的牌</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> f(arr, L, R - <span class="hljs-number">1</span>); <span class="hljs-comment">// 对手拿走了R位置的牌</span><br><br>        <span class="hljs-keyword">return</span> Math.min(p1, p2);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win1(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法2：（对解法1进行优化）</strong></p><div class="note note-success">            <p>定义两个二维数组，将计算之后的数值加到数值里面，防止重复计算</p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423205953240.png" alt="image-20220423205953240"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code2_CardsinLine</span> &#123;<br><br>    <span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-comment">// 加一个缓存（因为win1存在重复计算某一个数的情况）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">win2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加两个缓存表</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span>[][] fmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br>        <span class="hljs-type">int</span>[][] gmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br>        <span class="hljs-comment">// 如果ij在函数f2函数没有被计算过，那么就是-1 计算过就是对应的值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>                fmap[i][j] = -<span class="hljs-number">1</span>;<br>                gmap[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> f2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, fmap, gmap);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> g2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, fmap, gmap);<br>        <span class="hljs-keyword">return</span> Math.max(first, second);<br>    &#125;<br><br>    <span class="hljs-comment">// 先手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，先手获得的最好的分数返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span>[][] fmap, <span class="hljs-type">int</span>[][] gmap)</span> &#123;<br>        <span class="hljs-keyword">if</span> (fmap[L][R] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> fmap[L][R];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            ans = arr[L];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 1：我拿走左侧的牌，然后我在L+1到R上获得的最好的牌</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> arr[L] + g2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap);<br>            <span class="hljs-comment">// 2：我拿走左侧的牌，然后我在L到R-1上获得的最好的牌</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> arr[R] + g2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap);<br>            ans = Math.max(p1, p2);<br>        &#125;<br>        fmap[L][R] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 后手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，后手获得的最好的分数返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">g2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span>[][] fmap, <span class="hljs-type">int</span>[][] gmap)</span> &#123;<br>        <span class="hljs-keyword">if</span> (gmap[L][R] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> gmap[L][R];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            ans = arr[L];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> f2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap); <span class="hljs-comment">// 对手拿走了L位置的牌</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> f2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap); <span class="hljs-comment">// 对手拿走了R位置的牌</span><br>            ans = Math.min(p1, p2);<br>        &#125;<br>        gmap[L][R] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win2(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法三：（最终优化）</strong></p><div class="note note-success">            <p>由于数值arr一定是<strong>L&gt;R</strong>，因此只有数组的一半是存在定义的</p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423210149765.png" alt="image-20220423210149765"></p><div class="note note-success">            <p>由解法一可以得出来，表f与表g有关系，并且f表对应到g表之后与对应位置的左边与下边有关联，也就是<strong>g(0)(1) = f(0)(0)+f(1)(1)</strong></p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423210949953.png" alt="image-20220423210949953"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code2_CardsinLine</span> &#123;<br>    <br><span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-comment">// 加一个缓存（因为win1存在重复计算某一个数的情况）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">win3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加两个缓存表</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span>[][] fmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br>        <span class="hljs-type">int</span>[][] gmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            fmap[i][i] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">// 描述 按照对角线将两个二维数组互推</span><br>        <span class="hljs-comment">// startCol == 对角线的开始列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">startCol</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; startCol &lt; N; startCol++) &#123;<br>            <span class="hljs-comment">// row 对角线的开始行</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> startCol;<br>            <span class="hljs-comment">// 发现相对于行 列比行先越界</span><br>            <span class="hljs-keyword">while</span> (R &lt; N) &#123;<br>                fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="hljs-number">1</span>][R], arr[R] + gmap[L][R - <span class="hljs-number">1</span>]);<br>                gmap[L][R] = Math.min(fmap[L + <span class="hljs-number">1</span>][R], fmap[L][R - <span class="hljs-number">1</span>]);<br>                <span class="hljs-comment">// 实现对角线往下爬 且不能越界</span><br>                L++;<br>                R++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(fmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>], gmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win3(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><div class="note note-primary">            <p><strong>有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p>          </div><p><strong>解法一：</strong></p><div class="note note-success">            <p>对于一个货物只有p1（选择这个货物），p2（不选择这个货物）两个决策，当你不选择了这个货物那么就将index++往下对下一个货物进行决策；如果选择这个货物那么就对选择了货物之后背包的重量进行判断是否&gt;0,&gt;0就选择当前货物，否则不选</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code3_Knapsack</span> &#123;<br><br>    <span class="hljs-comment">// 所有的货，重量和价值都在w和v数组中</span><br>    <span class="hljs-comment">// 为了方便，其中没有复数</span><br>    <span class="hljs-comment">// bag背包容量，不能超过这个数</span><br>    <span class="hljs-comment">// 返回：不超过背包容量的情况下，能够得到的最大价值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w, <span class="hljs-type">int</span>[] v, <span class="hljs-type">int</span> bag)</span> &#123;<br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-literal">null</span> || v == <span class="hljs-literal">null</span> || w.length != v.length || w.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 尝试函数！</span><br>        <span class="hljs-keyword">return</span> process(w, v, <span class="hljs-number">0</span>, bag);<br>    &#125;<br><br>    <span class="hljs-comment">// 当前考虑到了index号货物，index....所有的货物都可以自由选择</span><br>    <span class="hljs-comment">// 做的选择不能超过背包容量</span><br>    <span class="hljs-comment">// 返回最大价值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w, <span class="hljs-type">int</span>[] v, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> bag)</span> &#123;<br>        <span class="hljs-keyword">if</span> (bag &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 为什么不写bag = 0 ：因为 万一存在货物 重量为0但是存在价值</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == w.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 有货物，index位置的货</span><br>        <span class="hljs-comment">// bag有空间</span><br>        <span class="hljs-comment">// 不要当前的货物</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> process(w, v, index + <span class="hljs-number">1</span>, bag);<br>        <span class="hljs-comment">// 要当前的货物</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用来判断</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> process(w, v, index + <span class="hljs-number">1</span>, bag - w[index]);<br>        <span class="hljs-keyword">if</span> (next != -<span class="hljs-number">1</span>) &#123;<br>            p2 = v[index] + next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(p1, p2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weights = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span>[] values = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">19</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bag</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>        System.out.println(maxValue(weights,values,bag));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">25</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法二：（对解法一进行优化）</strong></p><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220424172800335.png" alt="image-20220424172800335"></p><p>通过代码<strong>if (index == w.length) {return 0;}</strong> 可以得出二位数组的最后一行都为0，通过 <strong>int p1 = process(w, v, index + 1, bag); int next = process(w, v, index + 1, bag - w[index]);</strong> 可以得出我们需要知道一个格子的值只要知道下一行的值我们就可以得到这个格子的值；因此我们可以从最后一行开始入手得到倒数第二行…..直到第一行，同一行不存在依赖关系，所以从左往右写 或者从左往右写都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code3_Knapsack</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w, <span class="hljs-type">int</span>[] v, <span class="hljs-type">int</span> bag)</span> &#123;<br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-literal">null</span> || v == <span class="hljs-literal">null</span> || w.length != v.length || w.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> w.length;<br>        <span class="hljs-comment">// index 0</span><br>        <span class="hljs-comment">// rest 0~bag</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N + <span class="hljs-number">1</span>][bag + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[N][...] = 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; rest &lt;= bag; rest++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> dp[index + <span class="hljs-number">1</span>][rest];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> rest - w[index] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : dp[index + <span class="hljs-number">1</span>][rest - w[index]];<br>                <span class="hljs-keyword">if</span> (next != -<span class="hljs-number">1</span>) &#123;<br>                    p2 = v[index] + next;<br>                &#125;<br>                dp[index][rest] = Math.max(p1, p2);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][bag];<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weights = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span>[] values = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">19</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bag</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>        System.out.println(maxValue(weights,values,bag));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">25</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="/2022/04/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/04/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/image-20220419230424599.png" alt="连续子数组的最大和"></p><p><strong>题解：</strong></p><p>前i个数字的和如果小于零，那么说明第i+1个数如果加上前i个数就会变得更小，那么前i+1个数字和的最大就是nums[i+1]（注意：子数组也可以是数组中一个值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp表示以nums[i]为数组尾部的子数组最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dp</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (dp &gt; <span class="hljs-number">0</span>) &#123;<br>                dp = dp + nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp = nums[i];<br>            &#125;<br>            max = Math.max(max, dp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>股票的最大利润</title>
    <link href="/2022/04/19/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <url>/2022/04/19/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20220419165313973.png" alt="股票的最大利润"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 动态规划</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; min) &#123;<br>                min = prices[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] - min &gt; max) &#123;<br>                max = prices[i] - min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青蛙跳台阶问题</title>
    <link href="/2022/04/19/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/19/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/image-20220419162220107.png" alt="青蛙跳台阶问题"></p><p><strong>题解：</strong></p><p>设跳上 nn级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。<br>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；<br>当为 2 级台阶： 剩 n-2n个台阶，此情况共有 f(n-2) 种跳法。</p><p>所以 综上所述，其实就是一个f(0) = 1;f(1) = 1;f(2) = 2的斐波那契数列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 所求的斐波那契数就是前两个之和</span><br>            b = a + b;<br>            <span class="hljs-comment">// 相当于将 b的值赋给了a</span><br>            a = b - a;<br>            b = b % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数列</title>
    <link href="/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/image-20220419151140087.png" alt="斐波那契数列"></p><p><strong>题解：</strong></p><p>方法一：一个简单的递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是<img src="/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/image-20220419151311240.png" alt="image-20220419151311240"></p><p><strong>原因：</strong>原因是这个递归的时间复杂度是2^n，有大量的重复计算。在递归次数较大时时间呈指数增长</p><p><strong>方法二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 所求的斐波那契数就是前两个之和</span><br>            b = a + b;<br>            <span class="hljs-comment">// 相当于将 b的值赋给了a</span><br>            a = b - a;<br><br>            b = b % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称的二叉树</title>
    <link href="/2022/04/18/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/04/18/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/18/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220418234825507.png" alt="对称的二叉树"></p><p>题解：</p><p>什么时候这个二叉树对称呢，只有这个节点的左节点与右节点相同，且左节点的左节点与右节点的右节点相同，并且左节点的右节点右节点的左节点相同时才可以说二叉树对称，那么就能想到使用递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 1、判断特例</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则开始判断节点的左节点和右节点</span><br>            <span class="hljs-keyword">return</span> recur(root.left, root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> &#123;<br>        <span class="hljs-comment">// 如果左右节点都为空 那么就证明对称</span><br>        <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">null</span> &amp;&amp; R == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果左节点或者右节点或者左节点不等于右节点 那么就证明不对称 返回false</span><br>        <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">null</span> || R == <span class="hljs-literal">null</span> || L.val != R.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 到这一步就证明左节点等于右节点，那么就判断左节点的左节点是否等于最右节点的右节点</span><br>        <span class="hljs-keyword">return</span> recur(L.left,R.right) &amp;&amp; recur(L.right,R.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的镜像</title>
    <link href="/2022/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2022/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/image-20220418175346511.png" alt="二叉树的镜像"></p><p>代码实现：</p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 循环跳出的条件</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 中间值暂存左节点或者右节点的值</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-comment">// 递归</span><br>        root.left = mirrorTree(root.right);<br>        root.right = mirrorTree(tmp);<br>        <span class="hljs-keyword">return</span>  root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的子结构</title>
    <link href="/2022/04/18/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2022/04/18/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/18/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/image-20220418171021861.png" alt="树的子结构"></p><p>题解：</p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 判断头节点是否一样</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br><br>        <span class="hljs-comment">// 1、首先判断A与B两个二叉树不为空(题目说:约定空树不是任意一个树的子结构)</span><br>        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span> || B == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2、然后判断A的根节点与B的根节点是否相同</span><br>        <span class="hljs-comment">//    2.1、A的根节点与B的根节点相同，那么依次比较他们的子节点</span><br>        <span class="hljs-comment">//    2.2、A的根节点与B的根节点不同，那么A的左子树与B的根节点进行比较</span><br>        <span class="hljs-comment">//    2.3、A的根节点与B的根节点不同，那么A的右子树与B的根节点进行比较</span><br>        <span class="hljs-keyword">return</span> isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSub</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-comment">// A 和 B 不匹配的情况有很多，我们需要一开始去找他们完全匹配的情况</span><br>        <span class="hljs-comment">// 即遍历完B，直到为null，说明B的全部节点都和A的子结构匹配上</span><br>        <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// A的节点为空，但B的节点不为空，说明不匹配</span><br>        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// A和B都不为空，但数值不同，说明不匹配</span><br>        <span class="hljs-keyword">if</span> (A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 此时，当前这个点是匹配的，继续递归判断左子树和右子树是否 [分别匹配]</span><br>        <span class="hljs-keyword">return</span> isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从上到下打印二叉树Ⅲ</title>
    <link href="/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/"/>
    <url>/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/image-20220417155559852.png" alt="从上到下打印二叉树Ⅲ"></p><p>题解：<br>可以借鉴(<a href="http://www.eliseo.top/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/">从上到下打印二叉树Ⅱ - Eliseo的小屋</a>)将已经打印出来的二叉树进行偶数行执行倒序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个队列和数组</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 定义一个新的数组用来暂时存储每一行的节点</span><br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 遍历节点数的次数，将这一行的节点储存到数组tmp中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果是偶数，那么就将这个数组倒序</span><br>            <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                Collections.reverse(tmp);<br>            &#125;<br>            <span class="hljs-comment">// 将tmp数组化为res数组的一个元素放入res数组中</span><br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：先进行奇数与偶数层的判断，然后奇数层从队首弹出，偶数层倒着从队尾弹出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个队列和数组</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 定义一个新的数组用来暂时存储每一行的节点</span><br>            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 遍历节点数的次数，将这一行的节点储存到数组tmp中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                    tmp.addLast(node.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (res.size() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>                    tmp.addFirst(node.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将tmp数组化为res数组的一个元素放入res数组中</span><br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从上到下打印二叉树Ⅱ</title>
    <link href="/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/"/>
    <url>/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/image-20220417111458548.png" alt="从上到下打印二叉树Ⅱ"></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个队列和数组</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 定义一个新的数组用来暂时存储每一行的节点</span><br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 遍历节点数的次数，将这一行的节点储存到数组tmp中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将tmp数组化为res数组的一个元素放入res数组中</span><br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从上到下打印二叉树</title>
    <link href="/2022/04/14/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/04/14/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/14/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220414173504494.png" alt="从上到下打印二叉树"></p><p><strong>解题思路：</strong></p><p>利用列表和队列，队列进行操作，列表进行节点的数据的存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> * int val;</span><br><span class="hljs-comment"> * TreeNode left;</span><br><span class="hljs-comment"> * TreeNode right;</span><br><span class="hljs-comment"> * TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//初始化队列和列表，队列进行操作，列表存储节点</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//当队列不为空时</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 弹出一个节点</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-comment">// 添加到list中</span><br>            ans.add(node.val);<br>            <span class="hljs-comment">// 如果弹出的结点的左节点不为空那么添加到队列中</span><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-comment">// 如果弹出的结点的右节点不为空那么添加到队列中</span><br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将列表加到数组中</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>            res[i] = ans.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="/2022/04/14/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <url>/2022/04/14/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/14/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/image-20220414152856199.png" alt="第一个只出现一次的字符"></p><p><strong>解题思路：</strong></p><p>遍历字符串，将其放入哈希表，key为这个字母，value为是否重复，如果有重复的进来，就将value置为false，然后遍历一遍字符串(不可以遍历哈希表，因为哈希表是无序的)，找到第一个等于true的即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        HashMap&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] sc = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : sc) &#123;<br>            <span class="hljs-comment">//如果遇到重复，就会将重复值的value变为false</span><br>            dic.put(c, !dic.containsKey(c));<br>        &#125;<br>        <span class="hljs-comment">//在字典中查找第一个等于true的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : sc) &#123;<br>            <span class="hljs-keyword">if</span> (dic.get(c)) &#123;<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;<br>            <span class="hljs-comment">//否则就是没有不重复的数字</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2022/04/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式概述"><a href="#工厂模式概述" class="headerlink" title="工厂模式概述"></a>工厂模式概述</h1><p>工厂模式的主要解决的问题是，将原来分布在各个地方的对象创建过程单独抽离出来，交给工厂类负责创建。其他地方想要使用对象直接找工厂（即调用工厂的方法）获取对象。</p><h1 id="工厂模式的三种类型"><a href="#工厂模式的三种类型" class="headerlink" title="工厂模式的三种类型"></a>工厂模式的三种类型</h1><p>工厂模式主要有三种类型<br>1、简单工厂<br>2、工厂方法<br>3、抽象工厂</p><h2 id="1、简单工厂"><a href="#1、简单工厂" class="headerlink" title="1、简单工厂"></a>1、简单工厂</h2><p>拿泡茶为例，茶叶有好多种类，比如龙井、碧螺春、毛尖等。<br>首先一个ITea接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITea</span> &#123;<br><br>    <span class="hljs-comment">// 沏茶</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeTea</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义两种类型的茶，西湖龙井和碧螺春：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongjingTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITea</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeTea</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;西湖龙井&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BiluochunTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITea</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeTea</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;碧螺春&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如其它有一处代码要使用“茶”这个对象沏一壶茶，有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  准备沏一杯茶，根据传入的参数决定不同的茶叶类型</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> ITea <span class="hljs-title function_">prepareTea</span><span class="hljs-params">(String type)</span>&#123;<br>    <span class="hljs-type">ITea</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;longjing&quot;</span>))&#123;<br>        tea = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongjingTea</span>();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;biluochun&quot;</span>))&#123;<br>        tea = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BiluochunTea</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tea != <span class="hljs-literal">null</span>)&#123;<br>        tea.makeTea();<br>    &#125;<br>    <span class="hljs-keyword">return</span> tea;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们可以分析下不使用工厂模式的情况：</p><p>如果我们的工程中不至一处用了类似这段代码逻辑，那增加一种茶叶的类型（比如毛尖）就需要修改多处代码，不利于维护。</p><p>因此，可以考虑，将创建茶叶对象的逻辑抽离出来，单独放到一个类中，这个类便是工厂类（专门生产茶叶的工厂）。这样维护起来便方便很多，客户端代码也无需知道对象创建的具体细节，只需要从工厂类中获取对象即可。</p><p><strong>简单工厂类实现如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeaFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ITea <span class="hljs-title function_">createTea</span><span class="hljs-params">(String type)</span>&#123;<br>        <span class="hljs-type">ITea</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;longjing&quot;</span>))&#123;<br>            tea = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongjingTea</span>();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;biluochun&quot;</span>))&#123;<br>            tea = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BiluochunTea</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tea != <span class="hljs-literal">null</span>)&#123;<br>            tea.makeTea();<br>        &#125;<br>        <span class="hljs-keyword">return</span> tea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码要使用茶对象，需要从工厂中获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">TeaFactory</span> <span class="hljs-variable">teaFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeaFactory</span>();<br>    <span class="hljs-type">ITea</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> teaFactory.createTea(<span class="hljs-string">&quot;longjing&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p>在上面的简单工厂中，如果要创建的产品类型较多，且各个产品创建的过程不尽相同，则一个工厂类职责会变得越来越多，不符合单一职责原则。<br>另外简单工厂也不符合开闭原则。要新增一种产品需要修改原来的工厂类。</p><p>因此，工厂方法模式中，将生产各种类型的产品的工厂也做了抽象分离。比如，上面例子中的，生产龙井的有专门的龙井工厂，生产碧螺春的有专门的碧螺春工厂。</p><p>看代码，接着上面的实例进行改造。首先创建统一的工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产茶叶的统一接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeaFactory</span> &#123;<br><br>    <span class="hljs-comment">// 生产茶叶</span><br>    <span class="hljs-keyword">public</span> ITea <span class="hljs-title function_">createTea</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后创建两个生产不同类型产品的工厂实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongjingTeaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeaFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ITea <span class="hljs-title function_">createTea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongjingTea</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BiluochunTeaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeaFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ITea <span class="hljs-title function_">createTea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BiluochunTea</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryMethodTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ITeaFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongjingTeaFactory</span>();<br>        factory.createTea();<br><br>        factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BiluochunTeaFactory</span>();<br>        factory.createTea();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要新增一种茶叶，比如毛尖，只需要新建一个生产毛尖的工厂类实现ITeaFactory即可。可以看到符合开闭原则、单一职责原则。</p><p><strong>工厂方法适用于以下场景：</strong><br>1、创建对象需要大量重复的代码。<br>2、客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。<br>3、一个类通过其子类来指定创建哪个对象。</p><p><strong>工厂方法也有缺点：</strong><br>1、类的个数容易过多，增加复杂度。<br>2、增加了系统的抽象性和理解难度。</p><h2 id="3、抽象工厂"><a href="#3、抽象工厂" class="headerlink" title="3、抽象工厂"></a><strong>3、抽象工厂</strong></h2><p>场景:当我们需要多个产品族，每一个产品族里有一系列产品，这一系列产品一般是不变的，如果经常需要变动，可以使用工厂模式而非抽象工厂</p><p>举例说明下，有两个工厂，美的、格力。这两个工厂都生产两种产品：冰箱和洗衣机。下面使用抽象工厂模式来描述每个工厂的两种产品的创建过程。</p><p>1、首先创建两个产品的接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 冰箱</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFridge</span> &#123;<br>    <span class="hljs-comment">// 冷藏</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">coldStorage</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 洗衣机</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IWasher</span> &#123;<br>    <span class="hljs-comment">// 洗衣服</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">wash</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、创建每个工厂的两种产品（总共四种产品）：</p><p>美的的冰箱和洗衣机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MeideFridge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFridge</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coldStorage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;美的冰箱&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MeideWasher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IWasher</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wash</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;美的洗衣机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>格力的冰箱和洗衣机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeliFridge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFridge</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coldStorage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;格力冰箱&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeliWasher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IWasher</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wash</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;格力洗衣机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、创建抽象工厂接口</p><p>家用电器工厂，生产一组产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂接口，家用电器工厂，生产冰箱和洗衣机</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IHouseholdElectricFactory</span> &#123;<br><br>    IFridge <span class="hljs-title function_">createFridge</span><span class="hljs-params">()</span>;<br><br>    IWasher <span class="hljs-title function_">createWasher</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、创建具体产品等级的工厂</p><p>这里是创建美的和格力的工厂实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MeideHouseholdFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IHouseholdElectricFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IFridge <span class="hljs-title function_">createFridge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeideFridge</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IWasher <span class="hljs-title function_">createWasher</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeideWasher</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeliHouseholdFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IHouseholdElectricFactory</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IFridge <span class="hljs-title function_">createFridge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeliFridge</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IWasher <span class="hljs-title function_">createWasher</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeliWasher</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、客户端代码使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbsFactoryTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">IHouseholdElectricFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeideHouseholdFactory</span>();<br>        factory.createFridge().coldStorage();<br>        factory.createWasher().wash();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="/2022/04/14/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2022/04/14/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/14/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220414112109740.png" alt="旋转数组的最小数字"></p><p><strong>解题思路：</strong></p><p>虽然不是有序数组，但是可以看作是两个有序数组，因此可以用二分法把数组看作两个有序数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;<br>                <span class="hljs-comment">// 如果中间值小于最右边的值，那么证明是右边是递增加，则最小值肯定不在右边</span><br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;<br>                <span class="hljs-comment">// 如果中间值大于最右边的值，那么证明右边是递增，则最小值在右边</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] == numbers[right]) &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p></blockquote><p>​    0不可以用numbers[mid]和 numbers[left]进行比较，因为不能确定left是否属于第一个递增的数组，比如12345，没有偏转或者说偏转值为0.这个时候left是属于第二个递增的数组的。所以不能比较。而right一定是属于第二个数组的。所以我们用numbers[mid]和 numbers[left]进行比较。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0~n-1中缺失的数字</title>
    <link href="/2022/04/11/0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/04/11/0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/11/0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/image-20220411202654182.png" alt="0~n-1中缺失的数字"></p><p><strong>代码实现一：</strong></p><p>二分法，然后按理来说如果不缺值nums[mid] == mid ，但是当缺了一个数字以后，就不会出现nusm[mid] == mid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> len-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left + <span class="hljs-number">1</span> )/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid)&#123;<br>                <span class="hljs-comment">//如果中间值等于mid，说明缺失的数字在后半部分</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果中间值不等于mid，说明缺失的数字在前半部分</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在排序数组中查找数字1</title>
    <link href="/2022/04/10/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/"/>
    <url>/2022/04/10/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/10/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/image-20220410165511221.png" alt="在排序数组中查找数字1"></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 方法一：查找nums数组中和target相等的元素，然后计数器+1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (target == nums[i])&#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现二：</strong></p><p>由于题目说了是排序数组，所以可以使用<strong>二分法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">firstPosition</span> <span class="hljs-operator">=</span> findFirtPosition(nums, target);<br>        <span class="hljs-keyword">if</span> (firstPosition == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastPosition</span> <span class="hljs-operator">=</span> findLastPosition(nums, target);<br>        <span class="hljs-keyword">return</span> lastPosition - firstPosition + <span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 查找target第一次出现的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFirtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                <span class="hljs-comment">// [mid + 1 ... right]</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                <span class="hljs-comment">// [left ... mid]</span><br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[left] == target)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找target最后一次出现的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLastPosition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">//将mid赋值给left的时候要向上取整，不然left可能永远小于right，也就永远跳不出循环</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                <span class="hljs-comment">// [mid ... right]</span><br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                <span class="hljs-comment">// [left ... mid - 1]</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="/2022/04/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/04/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220405170237877.png" alt="数组中重复的数字"></p><p><strong>思路1：</strong>一看题目 脑子中直接想到了先排序 然后将相邻的数进行比较是否重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历数组</span><br>        <span class="hljs-keyword">while</span>(i &lt; nums.length) &#123;<br>            <span class="hljs-comment">//如果索引与值相等</span><br>            <span class="hljs-keyword">if</span>(nums[i] == i) &#123;<br>            <span class="hljs-comment">//进行下一个</span><br>            i++;<br>            <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//索引与值不相等，看这个值原本应该在的位置对应的值与这个值是否相等</span><br>            <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i]) &#123;<br>                <span class="hljs-comment">//如果相等，就直接返回</span><br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>            <span class="hljs-comment">//如果这个值作为索引对应的值与这个值不相等，就交换这两个数，使得这个值跟索引一致</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[tmp];<br>            nums[tmp] = tmp;<br>        &#125;<br>        <span class="hljs-comment">//没有找到</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左旋转字符串</title>
    <link href="/2022/04/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/04/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220405160431771.png" alt="左旋转字符串"></p><p><strong>代码实现一：直接拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现二：</strong></p><p><strong>思路：</strong>先将第n+1个到末尾的的字符添加到一个空的字符串，然后将第1个到第n个字符串拼接到字符串后实现左旋转字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &lt; s.length(); i++)<br>            res += s.charAt(i); <span class="hljs-comment">// charAt(i)表示取出字符串中第i个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            res += s.charAt(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换空格</title>
    <link href="/2022/04/04/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2022/04/04/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/04/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/image-20220404211052791.png" alt="替换空格"></p><p><strong>代码实现1：（调用代码库）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.replace(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;%20&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 将字符串扩大三倍变为一个字符数组，保证每一个空格都可以被替换</span><br>        <span class="hljs-type">char</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[s.length()*<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)&#123; <span class="hljs-comment">// 意思是说取出的第i个字符为空格</span><br>                <span class="hljs-comment">// 那么让这个字符的接下来三个字符分别为 % 2 0 </span><br>                array[size++] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                array[size++] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                array[size++] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果不是那么就复制</span><br>                array[size++] = s.charAt(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 取出数组array中第0到第size个字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array,<span class="hljs-number">0</span>,size);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复杂链表的复制</title>
    <link href="/2022/04/04/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2022/04/04/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/04/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/image-20220404210016882.png" alt="复杂链表的复制"></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.day01;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.day01</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: test02</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 11:04</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test02</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        Node next;<br>        Node random;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">this</span>.random = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>            <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 从头结点开始,复制并且拼接链表</span><br>            <span class="hljs-comment">// 原链表1-2-3</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val); <span class="hljs-comment">// 将链表的头节点的值变为一样</span><br>                tmp.next = cur.next; <span class="hljs-comment">// 将链表的头节点的下一个节点的值变成新链表的下一个节点 1-2 = 1-2</span><br>                cur.next = tmp; <span class="hljs-comment">// 原来是1-2现在变成1-1</span><br>                cur = tmp.next; <span class="hljs-comment">// 原来是1-2 现在变成1-1-2-2</span><br>                <span class="hljs-comment">// 运行完之后变成1-1-2-2-3-3</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 构建新的random的指向</span><br>            cur = head;<br>            <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(cur.random != <span class="hljs-literal">null</span>)&#123;<br>                    cur.next.random = cur.random.next;<br>                &#125;<br>                cur = cur.next.next;<br>            &#125;<br>            <span class="hljs-comment">// 3. 拆分两链表</span><br>            cur = head.next;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head, res = head.next;<br>            <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>) &#123;<br>                pre.next = pre.next.next;<br>                cur.next = cur.next.next;<br>                pre = pre.next;<br>                cur = cur.next;<br>            &#125;<br>            pre.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 单独处理原链表尾节点</span><br>            <span class="hljs-keyword">return</span> res;      <span class="hljs-comment">// 返回新链表头节点</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/2022/04/04/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/04/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1、盖房项目需求"><a href="#1、盖房项目需求" class="headerlink" title="1、盖房项目需求"></a>1、盖房项目需求</h1><ol><li><p>需要建房子：这一过程为打桩、砌墙、封顶</p></li><li><p>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</p></li><li><p>请编写程序，完成需求.</p></li></ol><h1 id="2、传统方式"><a href="#2、传统方式" class="headerlink" title="2、传统方式"></a>2、传统方式</h1><h2 id="2-1、传统方式解决盖房项目"><a href="#2-1、传统方式解决盖房项目" class="headerlink" title="2.1、传统方式解决盖房项目"></a>2.1、传统方式解决盖房项目</h2><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.builder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: AbstrackHouse</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 15:20</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:传统方式解决建房问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstrackHouse</span> &#123;<br><br>    <span class="hljs-comment">// 打地基</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildBasic</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 砌墙</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildWalls</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 封顶</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roofed</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">()</span>&#123;<br>        buildBasic();<br>        buildWalls();<br>        roofed();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.wang.builder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: CommonHouse</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 15:22</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:建造普通的房子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstrackHouse</span>  &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildBasic</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;普通房子打地基&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildWalls</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;普通房子砌墙&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roofed</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;普通房子封顶&quot;</span>);<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-keyword">package</span> com.wang.builder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: Client</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 15:23</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:使用者建房子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CommonHouse</span> <span class="hljs-variable">commonHouse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonHouse</span>();<br>        commonHouse.build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">普通房子打地基<br>普通房子砌墙<br>普通房子封顶<br></code></pre></td></tr></table></figure><h2 id="2-2、传统方式的优缺点"><a href="#2-2、传统方式的优缺点" class="headerlink" title="2.2、传统方式的优缺点"></a>2.2、传统方式的优缺点</h2><ol><li><p>优点是比较好理解，简单易操作。</p></li><li><p>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。</p></li><li><p>解决方案：将产品和产品建造过程解耦 =&gt; 建造者模式.</p></li></ol><h1 id="3、建造者模式"><a href="#3、建造者模式" class="headerlink" title="3、建造者模式"></a>3、建造者模式</h1><h2 id="3-1、什么是建造者模式？"><a href="#3-1、什么是建造者模式？" class="headerlink" title="3.1、什么是建造者模式？"></a>3.1、什么是建造者模式？</h2><p><strong>1.建造者模式</strong>（<strong><strong>Builder Pattern</strong></strong>）** 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><p>2.<strong>建造者模式</strong> 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h2 id="3-2、建造者模式的四个角色"><a href="#3-2、建造者模式的四个角色" class="headerlink" title="3.2、建造者模式的四个角色"></a>3.2、建造者模式的四个角色</h2><p><strong>1.Product（产品角色）：</strong> 一个具体的产品对象。</p><p><strong>2.Builder（抽象建造者）：</strong>创建一个Product对象的各个部件指定的 接口/<strong>抽象类</strong>。</p><p><strong>3.ConcreteBuilder（具体建造者）：</strong> 实现接口，构建和装配各个部件。</p><p><strong>4.Director（指挥者）：</strong> 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</p><h2 id="3-3、代码实现"><a href="#3-3、代码实现" class="headerlink" title="3.3、代码实现"></a>3.3、代码实现</h2><h3 id="3-3-1、house"><a href="#3-3-1、house" class="headerlink" title="3.3.1、house"></a>3.3.1、house</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.builder.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder.improve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: House</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 16:02</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:产品 -&gt; product</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span> &#123;<br>    <span class="hljs-comment">// 打地基</span><br>    <span class="hljs-keyword">private</span> String baise;<br>    <span class="hljs-comment">// 砌墙</span><br>    <span class="hljs-keyword">private</span> String wall;<br>    <span class="hljs-comment">// 封顶</span><br>    <span class="hljs-keyword">private</span> String roofed;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBaise</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> baise;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBaise</span><span class="hljs-params">(String baise)</span> &#123;<br>        <span class="hljs-built_in">this</span>.baise = baise;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWall</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> wall;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWall</span><span class="hljs-params">(String wall)</span> &#123;<br>        <span class="hljs-built_in">this</span>.wall = wall;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoofed</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> roofed;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoofed</span><span class="hljs-params">(String roofed)</span> &#123;<br>        <span class="hljs-built_in">this</span>.roofed = roofed;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-2、HouseBuilder"><a href="#3-3-2、HouseBuilder" class="headerlink" title="3.3.2、HouseBuilder"></a>3.3.2、HouseBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.builder.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder.improve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: HouseBuilder</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 16:04</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:抽象的建造者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseBuilder</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">House</span> <span class="hljs-variable">house</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">House</span>();<br><br>    <span class="hljs-comment">// 将建造的流程写好，抽象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildBasic</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildWall</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roofed</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 建造房子好之后将产品（房子）返回</span><br>    <span class="hljs-keyword">public</span> House <span class="hljs-title function_">buildHouse</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> house;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-3、CommonHouse"><a href="#3-3-3、CommonHouse" class="headerlink" title="3.3.3、CommonHouse"></a>3.3.3、CommonHouse</h3><p>普通房子建造者(具体的建造者1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.builder.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder.improve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: CommonHouse</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 16:10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:具体建造者1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HouseBuilder</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildBasic</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;普通房子打地基5m&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildWall</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;普通房子砌墙10m&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roofed</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;普通房子屋顶&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-4、HightBuilding"><a href="#3-3-4、HightBuilding" class="headerlink" title="3.3.4、HightBuilding"></a>3.3.4、HightBuilding</h3><p>高楼房子建造者(具体的建造者2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.builder.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder.improve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: HightBuilding</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 16:21</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:具体建造者2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HightBuilding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HouseBuilder</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildBasic</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;高级房子打地基100m&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildWall</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;高级房子砌墙20m&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roofed</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;高级房子透明屋顶&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-5、HouseDirector"><a href="#3-3-5、HouseDirector" class="headerlink" title="3.3.5、HouseDirector"></a>3.3.5、HouseDirector</h3><p>指挥者 其聚合了抽象建造者,使用时传入具体的建造者(抽象建造者的实现类),即可对应建造相应的类型,即返回相应的产品. 另外具体的建造流程由指挥者负责.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.builder.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder.improve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: HouseDirector</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 16:23</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:指挥者,动态地去指定制作流程，返回产品</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseDirector</span> &#123;<br>    <span class="hljs-type">HouseBuilder</span> <span class="hljs-variable">houseBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 构造器传入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HouseDirector</span><span class="hljs-params">(HouseBuilder houseBuilder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.houseBuilder = houseBuilder;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过setter方法传入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHouseBuilder</span><span class="hljs-params">(HouseBuilder houseBuilder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.houseBuilder = houseBuilder;<br>    &#125;<br><br>    <span class="hljs-comment">// 如何处理建造房子的流程，交给指挥者</span><br>    <span class="hljs-keyword">public</span>  House <span class="hljs-title function_">constructorHouse</span><span class="hljs-params">()</span>&#123;<br>        houseBuilder.buildBasic();<br>        houseBuilder.buildWall();<br>        houseBuilder.roofed();<br>        <span class="hljs-keyword">return</span> houseBuilder.buildHouse();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-6、client-调用"><a href="#3-3-6、client-调用" class="headerlink" title="3.3.6、client 调用"></a>3.3.6、client 调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.builder.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.builder.improve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: Client</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/4 16:29</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 盖普通房子</span><br>        <span class="hljs-type">CommonHouse</span> <span class="hljs-variable">commonHouse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonHouse</span>();<br>        <span class="hljs-comment">// 准备创建房子的指挥者</span><br>        <span class="hljs-type">HouseDirector</span> <span class="hljs-variable">houseDirector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HouseDirector</span>(commonHouse);<br><br>        <span class="hljs-comment">// 完成盖房子，返回产品（房子）</span><br>        <span class="hljs-type">House</span> <span class="hljs-variable">house</span> <span class="hljs-operator">=</span> houseDirector.constructorHouse();<br><br>        System.out.println(<span class="hljs-string">&quot;**************************************&quot;</span>);<br><br>        <span class="hljs-comment">// 盖高楼</span><br>        <span class="hljs-type">HightBuilding</span> <span class="hljs-variable">hightBuilding</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HightBuilding</span>();<br>        <span class="hljs-comment">// 重置建造者</span><br>        houseDirector.setHouseBuilder(hightBuilding);<br>        <span class="hljs-comment">// 完成盖房子，返回产品（房子）</span><br>        houseDirector.constructorHouse();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-7、控制台输出"><a href="#3-3-7、控制台输出" class="headerlink" title="3.3.7、控制台输出"></a>3.3.7、控制台输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">普通房子打地基5m<br>普通房子砌墙10m<br>普通房子屋顶<br>**************************************<br>高级房子打地基100m<br>高级房子砌墙20m<br>高级房子透明屋顶<br></code></pre></td></tr></table></figure><h1 id="4、建造者模式与工厂模式的区别"><a href="#4、建造者模式与工厂模式的区别" class="headerlink" title="4、建造者模式与工厂模式的区别"></a>4、建造者模式与工厂模式的区别</h1><p>​    我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</p><p>​    与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p><p>​    建造者模式与工厂模式类似，他们都是建造者模式，适用的场景也很相似。一般来说，如果产品的建造<strong>很复杂</strong>，那么请用工厂模式；如果产品的建造<strong>更复杂</strong>，那么请用建造者模式。</p><h1 id="5、建造者模式的注意事项和细节"><a href="#5、建造者模式的注意事项和细节" class="headerlink" title="5、建造者模式的注意事项和细节"></a>5、建造者模式的注意事项和细节</h1><p>1、 客户端(使用程序)<strong>不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</strong></p><p>2、每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong></p><p><strong>3、</strong> <strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</p><p><strong>4、增加新的具体建造者无须修改原有类库的代码，</strong>指挥者类针对抽象建造者类编程，系统扩展方便，符合 <strong>“开闭原则”</strong> <strong>建造者模式的注意事项和细节</strong></p><p>5、 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</p><p>6、如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</p><p><strong>7、抽象工厂模式VS建造者模式</strong></p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="/2022/04/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/04/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/image-20220404103329598.png" alt="二维数组中的查找"></p><p><strong>题解：</strong></p><p>1、暴力破解：直接每一行每一列进行遍历然后查找有没有与给定的值相等的数，浪费了数组的<strong>局部有限性</strong></p><p>2、从左下角进行遍历，如果左下角的数字matrix[ n] [ m ]&gt;所提供的target，那么target一定在matrix[ n] [ m ]上方，</p><p>然后与matrix[ n-1] [ m ]比较，如果matrix[ n-1] [ m ]&lt;所提供的target，那么就往右方也就是matrix[ n-1] [ m+1 ]走</p><p>3、如果左下角的数字matrix[ n] [ m ]&lt;所提供的target，那么target一定在matrix[ n] [ m ]右方，</p><p>然后与matrix[ n] [ m+1 ]比较，如果matrix[ n] [ m+1 ]&gt;所提供的target，那么就往上方也就是matrix[ n-1] [ m+1 ]走</p><p><strong>解题代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length-<span class="hljs-number">1</span>; <span class="hljs-comment">// 数组的长度</span><br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 判断数组有没有值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>; <span class="hljs-comment">// 数组的宽度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// target在数组中的纵坐标</span><br>        <span class="hljs-keyword">while</span> (j &lt;= m &amp;&amp; n&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span> (matrix[n][j]&gt;target)&#123; <span class="hljs-comment">// 如果左下角的数字大于target那么往上走</span><br>                n--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[n][j]&lt;target)&#123;<span class="hljs-comment">// 如果左下角的数字大于target那么往右走</span><br>                j++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>O(m+n)(m和n就是数组的长度和宽度)</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2022/04/03/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/03/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1、克隆羊问题"><a href="#1、克隆羊问题" class="headerlink" title="1、克隆羊问题"></a>1、克隆羊问题</h1><p>场景：现在又一只羊tom，年龄为：1，颜色为：白色，请编写程序创建和tom羊属性完全相同的10只羊</p><h1 id="2、传统方式"><a href="#2、传统方式" class="headerlink" title="2、传统方式"></a>2、传统方式</h1><h2 id="2-1、传统方式解决克隆羊"><a href="#2-1、传统方式解决克隆羊" class="headerlink" title="2.1、传统方式解决克隆羊"></a>2.1、传统方式解决克隆羊</h2><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.prototype;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.prototype</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: sheep</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/3 15:37</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:羊的实体类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String color;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sheep&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, color=&#x27;&quot;</span> + color + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.wang.prototype;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.prototype</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: Client</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/3 15:41</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:克隆羊的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 用传统的方法</span><br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;白色&quot;</span>);<br><br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());<br>        <span class="hljs-comment">// ......</span><br><br>        System.out.println(sheep);<br>        System.out.println(sheep2);<br>        System.out.println(sheep3);<br>        System.out.println(sheep4);<br>        System.out.println(sheep5);<br>        <span class="hljs-comment">// ......</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>&#125;<br>sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>&#125;<br>sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>&#125;<br>sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>&#125;<br>sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2、传统的方式的优缺点"><a href="#2-2、传统的方式的优缺点" class="headerlink" title="2.2、传统的方式的优缺点"></a>2.2、<strong>传统的方式的优缺点</strong></h2><ol><li><p>优点是比较好理解，简单易操作。</p></li><li><p>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</p></li><li><p>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</p></li><li><p>改进的思路分析</p></li></ol><p><strong>思路：</strong>Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 =&gt; <strong>原型模式</strong></p><h1 id="3、原型模式"><a href="#3、原型模式" class="headerlink" title="3、原型模式"></a>3、原型模式</h1><h2 id="3-1、什么是原型模式？"><a href="#3-1、什么是原型模式？" class="headerlink" title="3.1、什么是原型模式？"></a>3.1、什么是原型模式？</h2><ol><li>原型模式(Prototype模式)是指：用<strong>原型实例指定创建对象的种类</strong>，<strong>并且通过拷贝这些原型</strong>，<strong>创建新的对象</strong></li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节</li><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 <strong>对象.clone()</strong></li><li>形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li></ol><h2 id="3-2、浅拷贝的介绍"><a href="#3-2、浅拷贝的介绍" class="headerlink" title="3.2、浅拷贝的介绍"></a>3.2、浅拷贝的介绍</h2><ol><li><p>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</p></li><li><p>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p></li><li><p><strong>前面我们克隆羊就是浅拷贝</strong></p></li><li><p>浅拷贝是使用默认的 clone()方法来实现</p><p>sheep = (Sheep) <strong>super.clone();</strong> </p></li></ol><p><strong>浅拷贝：</strong>就是A对象指向B对象，然后拷贝的时候将A克隆成A2对象，A2对象所指的对象就是B对象（基本数据类型与String类型使用浅拷贝）</p><h2 id="3-3、浅拷贝解决克隆羊"><a href="#3-3、浅拷贝解决克隆羊" class="headerlink" title="3.3、浅拷贝解决克隆羊"></a>3.3、浅拷贝解决克隆羊</h2><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.prototype.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.prototype</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: sheep</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/3 16:09</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:羊的原型模式的体类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span>  <span class="hljs-string">&quot;蒙古羊&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sheep</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sheep&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, color=&#x27;&quot;</span> + color + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 克隆该实例，使用默认的clone方法来完成</span><br>    <span class="hljs-comment">// 默认的是直接return super.clone()</span><br>    <span class="hljs-comment">// 在这里强转是为了被对象接收，然后直接捕获并处理异常，</span><br>    <span class="hljs-comment">// 调试的时候可以一步一步走，如果不是为了在bean中处理异常的话完全可以不改自动生成的内容直接return</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sheep = (Sheep) <span class="hljs-built_in">super</span>.clone();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> sheep;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.wang.prototype.improve;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.prototype.improve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: client</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/3 16:21</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;原型模式完成对象的创建&quot;</span>);<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;白色&quot;</span>);<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep2</span> <span class="hljs-operator">=</span> (Sheep) sheep.clone();<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep3</span> <span class="hljs-operator">=</span> (Sheep) sheep.clone();<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep4</span> <span class="hljs-operator">=</span> (Sheep) sheep.clone();<br>        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep5</span> <span class="hljs-operator">=</span> (Sheep) sheep.clone();<br><br>        System.out.println(<span class="hljs-string">&quot;sheep2 =&quot;</span> + sheep2);<br>        System.out.println(<span class="hljs-string">&quot;sheep3 =&quot;</span> + sheep3);<br>        System.out.println(<span class="hljs-string">&quot;sheep4 =&quot;</span> + sheep4);<br>        System.out.println(<span class="hljs-string">&quot;sheep5 =&quot;</span> + sheep5);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">原型模式完成对象的创建<br>sheep2 =Sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>, address=<span class="hljs-string">&#x27;蒙古羊&#x27;</span>&#125;<br>sheep3 =Sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>, address=<span class="hljs-string">&#x27;蒙古羊&#x27;</span>&#125;<br>sheep4 =Sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>, address=<span class="hljs-string">&#x27;蒙古羊&#x27;</span>&#125;<br>sheep5 =Sheep&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">1</span>, color=<span class="hljs-string">&#x27;白色&#x27;</span>, address=<span class="hljs-string">&#x27;蒙古羊&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4、深拷贝的介绍"><a href="#3-4、深拷贝的介绍" class="headerlink" title="3.4、深拷贝的介绍"></a>3.4、深拷贝的介绍</h2><ol><li><p>复制对象的所有基本数据类型的成员变量值</p></li><li><p>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，<strong>对象进行深拷贝要对整个对象进行拷贝</strong></p></li><li><p>深拷贝实现方式1：重写clone方法来实现深拷贝</p></li><li><p>深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)</p></li></ol><p><strong>深拷贝：</strong>就是A对象指向B对象，然后拷贝的时候将A克隆成A2对象，A2对象所指的对象是B2对象</p><h2 id="3-5、深拷贝解决克隆羊"><a href="#3-5、深拷贝解决克隆羊" class="headerlink" title="3.5、深拷贝解决克隆羊"></a>3.5、深拷贝解决克隆羊</h2><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.prototype.deepclone;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.prototype.deepclone</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: DeepCloneableTarget</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/3 17:48</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:s深拷贝</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCloneableTarget</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>, Cloneable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String cloneName;<br>    <span class="hljs-keyword">private</span> String cloneClass;<br><br>    <span class="hljs-comment">// 构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeepCloneableTarget</span><span class="hljs-params">(String cloneName, String cloneClass)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cloneName = cloneName;<br>        <span class="hljs-built_in">this</span>.cloneClass = cloneClass;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为该类的属性，都是String，因此我们这里使用默认的clone完成即可</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.wang.prototype.deepclone;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.prototype.deepclone</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: DeepProtoType</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/3 17:53</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepProtoType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>, Cloneable &#123;<br>    <span class="hljs-keyword">public</span> String name;<span class="hljs-comment">// String属性</span><br>    <span class="hljs-keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="hljs-comment">// 引用类型</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeepProtoType</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 深拷贝 - 方式1 使用clone 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">deep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 这里完成对基本数据类型（属性）和String的克隆</span><br>        deep = <span class="hljs-built_in">super</span>.clone();<br>        <span class="hljs-comment">// 对引用类型的属性进行单独的处理</span><br>        <span class="hljs-type">DeepProtoType</span> <span class="hljs-variable">deepProtoType</span> <span class="hljs-operator">=</span> (DeepProtoType) deep;<br>        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();<br><br>        <span class="hljs-keyword">return</span> deepProtoType;<br>    &#125;<br><br>    <span class="hljs-comment">// 深拷贝 - 方式2 通过对象的序列化实现（***）</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 字节数组输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 对象输出流</span><br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 字节数组输入流</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 对象输入流</span><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">// 序列化</span><br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>            oos.writeObject(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 当前这个对象以对象流的方式输出</span><br><br>            <span class="hljs-comment">//反序列化</span><br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>            <span class="hljs-type">DeepProtoType</span> <span class="hljs-variable">copyObj</span> <span class="hljs-operator">=</span> (DeepProtoType) ois.readObject();<br><br>            <span class="hljs-keyword">return</span> copyObj;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭流</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                bos.close();<br>                oos.close();<br>                bis.close();<br>                ois.close();<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e2)&#123;<br>                System.out.println(e2.getMessage());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.wang.prototype.deepclone;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.prototype.deepclone</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: Client</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/4/3 19:39</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DeepProtoType</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeepProtoType</span>();<br>        p.name = <span class="hljs-string">&quot;宋江&quot;</span>;<br>        p.deepCloneableTarget = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeepCloneableTarget</span>(<span class="hljs-string">&quot;大牛&quot;</span>, <span class="hljs-string">&quot;小牛&quot;</span>);<br><br>        <span class="hljs-comment">// 方式1完成深拷贝</span><br>        <span class="hljs-type">DeepProtoType</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (DeepProtoType) p.clone();<br><br>        System.out.println(<span class="hljs-string">&quot;p.name=&quot;</span> + p.name + <span class="hljs-string">&quot;p.deepCloneableTarget = &quot;</span> + p.deepCloneableTarget.hashCode());<span class="hljs-comment">// p.name=宋江p.deepCloneableTarget = 460141958</span><br>        System.out.println(<span class="hljs-string">&quot;p2.name=&quot;</span> + p.name + <span class="hljs-string">&quot;p2.deepCloneableTarget = &quot;</span> + p2.deepCloneableTarget.hashCode());<span class="hljs-comment">//p2.name=宋江p2.deepCloneableTarget = 1163157884</span><br><br>        <span class="hljs-comment">// 方式2完成深拷贝</span><br>        <span class="hljs-type">DeepProtoType</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> (DeepProtoType) p.deepClone();<br><br>        System.out.println(<span class="hljs-string">&quot;p.name=&quot;</span> + p.name + <span class="hljs-string">&quot;p.deepCloneableTarget = &quot;</span> + p.deepCloneableTarget.hashCode());<span class="hljs-comment">// p.name=宋江p.deepCloneableTarget = 460141958</span><br>        System.out.println(<span class="hljs-string">&quot;p3.name=&quot;</span> + p.name + <span class="hljs-string">&quot;p3.deepCloneableTarget = &quot;</span> + p3.deepCloneableTarget.hashCode()); <span class="hljs-comment">//p3.name=宋江p3.deepCloneableTarget = 2094548358</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6、原型模式的注意事项和细节"><a href="#3-6、原型模式的注意事项和细节" class="headerlink" title="3.6、原型模式的注意事项和细节"></a>3.6、原型模式的注意事项和细节</h2><ol><li><p>创建新的对象比较复杂时，可以利用原型模式简化<strong>对象的创建过程，同时也能够提高</strong>效率</p></li><li><p>不用重新初始化对象，而是<strong>动态地获得对象运行时</strong>的状态</p></li><li><p>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</p></li><li><p>在实现深克隆的时候可能需要比较复杂的代码</p></li><li><p> <strong>缺点</strong>：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/03/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="1、什么是单例模式？"><a href="#1、什么是单例模式？" class="headerlink" title="1、什么是单例模式？"></a>1、什么是单例模式？</h2><p>所谓类的单例设计模式，就是<strong>采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法(静态方法)。</p><h2 id="2、单例模式的八种方式"><a href="#2、单例模式的八种方式" class="headerlink" title="2、单例模式的八种方式"></a>2、单例模式的八种方式</h2><p>单例模式有八种方式：</p><p><strong>1、饿汉式（静态常量）</strong></p><p><strong>2、饿汉式（静态代码块）</strong></p><p>3、 懒汉式（线程不安全）</p><p>4、 懒汉式（线程安全，同步方法）</p><p>5、 懒汉式（线程安全，同步代码块）</p><p><strong>3、4、5为单null检查</strong></p><p><strong>6、双重检查（双null检查）</strong></p><p><strong>7、静态内部类</strong></p><p><strong>8、枚举</strong></p><h2 id="3、饿汉式（静态常量）"><a href="#3、饿汉式（静态常量）" class="headerlink" title="3、饿汉式（静态常量）"></a>3、<strong>饿汉式（静态常量）</strong></h2><p>饿汉式（静态常量）应用实例</p><p><strong>步骤如下</strong>：</p><ol><li><p>构造器私有化 (防止 通过new得到对象实例 )</p></li><li><p>类的内部创建对象</p></li><li><p>向外暴露一个静态的公共方法。getInstance</p></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.singleton</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: type1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/3/19 11:40</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 单例模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">type1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 测试</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        System.out.println(instance==instance2); <span class="hljs-comment">// true 证明两个instance实例是同一个对象实例</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 饿汉式（静态常量）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><br>    <span class="hljs-comment">// 1、构造器私有化 外部能new</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 2、本类内部创建对象实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 3、提供一个共有的静态方法，返回对象实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>证明两个对象实例是同一个对象实例</p><p><strong>优缺点说明</strong>：</p><ol><li><p><strong>优点：</strong>这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p></li><li><p><strong>缺点：</strong>在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</p></li><li><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果</p></li><li><p>结论：这种单例模式<strong>可用</strong>，<strong>可能</strong>造成内存浪费</p></li></ol><h2 id="4、饿汉式（静态代码块）"><a href="#4、饿汉式（静态代码块）" class="headerlink" title="4、饿汉式（静态代码块）"></a>4、饿汉式（静态代码块）</h2><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.singleton.type2;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.singleton</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: type2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/3/19 17:45</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 单例模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">type2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 测试</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        System.out.println(instance==instance2); <span class="hljs-comment">// true 证明两个instance实例是同一个对象实例</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 饿汉式（静态代码块）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><br>    <span class="hljs-comment">// 1、构造器私有化 外部能new</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 2、本类内部创建对象实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">// 在静态代码块中，创建单例对象</span><br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-comment">// 3、提供一个共有的静态方法，返回对象实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>证明两个对象实例是同一个对象实例</p><p><strong>优缺点说明</strong>：</p><ol><li><p>这种方式和<strong>饿汉式的静态常量</strong>其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p></li><li><p>结论：这种单例模式可用，但是可能造成内存浪费</p></li></ol><h2 id="5、懒汉式（线程不安全）"><a href="#5、懒汉式（线程不安全）" class="headerlink" title="5、懒汉式（线程不安全）"></a>5、懒汉式（线程不安全）</h2><p> 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.singleton.type3;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.singleton.tyoe3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: SinglentonTest03</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/3/19 18:05</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 单例模式单null检查</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglentonTest03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 测试</span><br>        System.out.println(<span class="hljs-string">&quot;懒汉式1，线程不安全&quot;</span>);<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        System.out.println(instance==instance2); <span class="hljs-comment">// true 证明两个instance实例是同一个对象实例</span><br>        System.out.println(<span class="hljs-string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singlenton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singlenton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singlenton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 提供一个静态的公有方法，当使用到该方法时，才会去创建instance</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singlenton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 说明还没有创建instance</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlenton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">懒汉式<span class="hljs-number">1</span>，线程不安全<br><span class="hljs-literal">true</span><br>instance.hashCode=<span class="hljs-number">460141958</span><br>instance2.hashCode=<span class="hljs-number">460141958</span><br></code></pre></td></tr></table></figure><p><strong>优缺点说明</strong>：</p><ol><li><p>起到了Lazy Loading的效果，但是只能在单线程下使用。</p></li><li><p>如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便<strong>会产生多个实例。</strong>所以在多线程环境下不可使用这种方式</p></li><li><p>结论：<strong>在实际开发中，不要使用这种方式.</strong></p></li></ol><h2 id="6、懒汉式（线程安全，同步方法）"><a href="#6、懒汉式（线程安全，同步方法）" class="headerlink" title="6、懒汉式（线程安全，同步方法）"></a>6、懒汉式（线程安全，同步方法）</h2><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.singleton.type4;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.singleton.type4</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: SinglentonTest04</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/3/20 17:35</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:懒汉式（线程安全，同步方法）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglentonTest04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 测试</span><br>        System.out.println(<span class="hljs-string">&quot;懒汉式2，线程安全&quot;</span>);<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        System.out.println(instance==instance2); <span class="hljs-comment">// true 证明两个instance实例是同一个对象实例</span><br>        System.out.println(<span class="hljs-string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 懒汉式（线程安全，同步方法）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singlenton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singlenton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singlenton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span><br>    <span class="hljs-comment">// 懒汉式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singlenton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 说明还没有创建instance</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlenton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">懒汉式<span class="hljs-number">2</span>，线程安全<br><span class="hljs-literal">true</span><br>instance.hashCode=<span class="hljs-number">460141958</span><br>instance2.hashCode=<span class="hljs-number">460141958</span><br></code></pre></td></tr></table></figure><p><strong>优缺点说明</strong>：</p><ol><li><p>解决了线程不安全问题</p></li><li><p>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行<strong>同步效率太低</strong></p></li><li><p>结论：<strong>在实际开发中，不推荐使用这种方式</strong></p></li></ol><h2 id="7、懒汉式-线程安全，同步代码块"><a href="#7、懒汉式-线程安全，同步代码块" class="headerlink" title="7、懒汉式(线程安全，同步代码块)"></a>7、懒汉式(线程安全，同步代码块)</h2><p>​    <img src="/2022/03/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20220326182601250.png" alt="image-20220326182601250"></p><p><strong>优缺点说明</strong>：</p><ol><li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，</li></ol><p>改为同步产生实例化的的代码块</p><ol start="2"><li><p><strong>但是这种同步并不能起到线程同步的作用</strong>。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</p></li><li><p>结论：在<strong>实际开发中，不能使用这种方</strong>式</p></li></ol><h2 id="8、双重检查"><a href="#8、双重检查" class="headerlink" title="8、双重检查 *"></a>8、双重检查 *</h2><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.singleton.type6;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.singleton.type6</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: SinglentonTest06</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/3/26 18:50</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:双重检查</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglentonTest06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 测试</span><br>        System.out.println(<span class="hljs-string">&quot;双重检查&quot;</span>);<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        System.out.println(instance==instance2); <span class="hljs-comment">// true 证明两个instance实例是同一个对象实例</span><br>        System.out.println(<span class="hljs-string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双重检查</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singlenton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singlenton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singlenton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 提供一个静态的公有方法，加入双重检查的代码，解决线程安全问题，同时解决懒加载的问题</span><br>    <span class="hljs-comment">// 两个线程同时进入到34行 假设a先进去那么b就进不去</span><br>    <span class="hljs-comment">// b进入的时候a已经完成了对Singlenton的实例化 也就是说b进入不了36行 所以退出代码块</span><br>    <span class="hljs-comment">// 第三个第四个线程进入的时候当到了34行发现 instance ！= null 于是直接退出</span><br>    <span class="hljs-comment">// 实现单例化 保证了效率 推荐使用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singlenton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 说明还没有创建instance</span><br>            <span class="hljs-keyword">synchronized</span> (Singlenton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlenton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">双重检查<br><span class="hljs-literal">true</span><br>instance.hashCode=<span class="hljs-number">460141958</span><br>instance2.hashCode=<span class="hljs-number">460141958</span><br></code></pre></td></tr></table></figure><p><strong>优缺点说明</strong>：</p><ol><li><p>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。</p></li><li><p>这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.</p></li><li><p><strong>线程安全；延迟加载；效率较高</strong></p></li><li><p>结论：在实际开发中，<strong>推荐使用这种单例设计模式</strong></p></li></ol><h2 id="9、静态内部类"><a href="#9、静态内部类" class="headerlink" title="9、静态内部类 *"></a>9、静态内部类 *</h2><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.singleton.type7;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.singleton.type7</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: SinglentonTest07</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/3/27 17:11</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:静态内部类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglentonTest07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 测试</span><br>        System.out.println(<span class="hljs-string">&quot;使用静态内部类完成单例模式&quot;</span>);<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        <span class="hljs-type">Singlenton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singlenton.getInstance();<br>        System.out.println(instance==instance2); <span class="hljs-comment">// true 证明两个instance实例是同一个对象实例</span><br>        System.out.println(<span class="hljs-string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 静态内部类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singlenton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singlenton instance;<br><br>    <span class="hljs-comment">// 构造器私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singlenton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 写一个静态内部类，该类中有一个静态属性 Singlenton</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SinglentonInstance</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singlenton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singlenton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、SinglentonInstance在Singlenton类装载的时候不会立刻执行保证不会进行这个SinglentonInstance静态内部类的装载</span><br><span class="hljs-comment">    从而保证懒加载可用</span><br><span class="hljs-comment">    2、当我们调用getInstance的时候会去去SinglentonInstance静态内部类的INSTANCE属性导致静态内部类装载保证装载的时候的线程安全</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 提供一个静态的公有方法,直接返回SinglentonInstance.INSTANCE</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singlenton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SinglentonInstance.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">使用静态内部类完成单例模式<br><span class="hljs-literal">true</span><br>instance.hashCode=<span class="hljs-number">460141958</span><br>instance2.hashCode=<span class="hljs-number">460141958</span><br></code></pre></td></tr></table></figure><p><strong>优缺点说明</strong>：</p><ol><li><p>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p></li><li><p>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p></li><li><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p></li><li><p>优点：避免了<strong>线程不安全</strong>，利用<strong>静态内部类特点实现延迟加载，效率高</strong></p></li><li><p>结论：<strong>推荐使用.</strong></p></li></ol><h2 id="10、枚举"><a href="#10、枚举" class="headerlink" title="10、枚举 *"></a>10、枚举 *</h2><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.singleton.type8;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.singleton.type8</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: SingletonTest08</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/3/27 17:38</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:枚举</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonTest08</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance2</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br>        System.out.println(instance==instance2); <span class="hljs-comment">// true 证明两个instance实例是同一个对象实例</span><br>        System.out.println(<span class="hljs-string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());<br><br>        instance.sayOk();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用枚举可以实现单例。</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    INSTANCE; <span class="hljs-comment">// 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayOk</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">// 方法</span><br>        System.out.println(<span class="hljs-string">&quot;OK~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-literal">true</span><br>instance.hashCode=<span class="hljs-number">460141958</span><br>instance2.hashCode=<span class="hljs-number">460141958</span><br>OK~<br></code></pre></td></tr></table></figure><p><strong>优缺点说明</strong>：</p><ol><li><p>这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p></li><li><p>这种方式是<strong>Effective Java作者Josh Bloch 提倡的方式</strong></p></li><li><p>结论：<strong>推荐使用</strong></p></li></ol><h2 id="单例模式注意事项和细节说明"><a href="#单例模式注意事项和细节说明" class="headerlink" title="单例模式注意事项和细节说明"></a>单例模式注意事项和细节说明</h2><p><strong>推荐使用：</strong></p><p><strong>饿汉式，双重检查，静态内部类，枚举</strong></p><p><strong>单例模式注意事项和细节说明</strong></p><ol><li><p>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</p></li><li><p>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</p></li><li><p>单例模式<strong>使用的场景</strong>：需要<strong>频繁的进行创建和销毁的对象</strong>、创建对象时耗时过多或耗费资源过多(即：<strong>重量级对象</strong>)，但又经常用到的对象、<strong>工具类对象</strong>、频繁访问数据库或文件的对象(比如<strong>数据源、session工厂</strong>等)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类的六种关系</title>
    <link href="/2022/03/10/%E7%B1%BB%E7%9A%84%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/"/>
    <url>/2022/03/10/%E7%B1%BB%E7%9A%84%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、依赖关系（Dependence）"><a href="#一、依赖关系（Dependence）" class="headerlink" title="一、依赖关系（Dependence）"></a>一、依赖关系（Dependence）</h1><p>只要是在<strong>类中用到了对方</strong>，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p><p><strong>小结:</strong></p><p>1、类中用到了对方</p><p>2、如果是类的成员属性</p><p>3、如果是方法的返回类</p><p>4、是方法接收的参数类</p><p>5、方法中使用到</p><h1 id="二、泛化关系-generalization）"><a href="#二、泛化关系-generalization）" class="headerlink" title="二、泛化关系(generalization）"></a>二、泛化关系(generalization）</h1><p>泛化关系实际上就是继承关系，他是<strong>依赖关系的特例</strong></p><p><strong>小结:</strong></p><p>1、泛化关系实际上就是继承关系</p><p>2、如果A类继承了B类，我们就说A和B存在泛化关系</p><h1 id="三、实现关系（Implementation）"><a href="#三、实现关系（Implementation）" class="headerlink" title="三、实现关系（Implementation）"></a>三、实现关系（Implementation）</h1><p>实现关系实际上就是A类实现B接口，他是<strong>依赖关系的特例</strong></p><h1 id="四、关联关系（Association）"><a href="#四、关联关系（Association）" class="headerlink" title="四、关联关系（Association）"></a>四、关联关系（Association）</h1><p>关联关系实际上就是<strong>类与类之间的联系，他是依赖关系的特例</strong></p><p>关联具有<strong>导航性</strong>：即双向关系或单向关系</p><p>关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m个）。</p><h1 id="五、聚合关系（Aggregation）"><a href="#五、聚合关系（Aggregation）" class="headerlink" title="五、聚合关系（Aggregation）"></a>五、聚合关系（Aggregation）</h1><p>聚合关系（Aggregation）表示的是<strong>整体和部分</strong>的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。</p><p>如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，</p><h1 id="六、组合关系（Composition）"><a href="#六、组合关系（Composition）" class="headerlink" title="六、组合关系（Composition）"></a>六、组合关系（Composition）</h1><p>组合关系：也是整体与部分的关系，但是整体与部分不可以分开</p><p><strong>案例</strong>：在程序中我们定义实体：Person与IDCard、Head, 那么 Head 和Person 就是 组合，IDCard 和 Person 就是聚合。</p><p>但是如果在程序中Person实体中定义了对IDCard进行<strong>级联删除</strong>，即删除Person时连同IDCard一起删除，那么IDCard 和 Person 就是组合了</p><h1 id="七、聚合组合的区别"><a href="#七、聚合组合的区别" class="headerlink" title="七、聚合组合的区别"></a>七、聚合组合的区别</h1><p><strong>聚合</strong>有参构造的时候将类的对象放进去<br><strong>组合</strong>就是无参构造的时候将对象new进去</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式七大原则</title>
    <link href="/2022/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2022/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><p><strong>单一职责原则：</strong>一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。</p><p><strong>接口隔离原则：</strong>将不同功能定义在不同接口中实现接口隔离。</p><p><strong>依赖倒置原则：</strong>针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。</p><p><strong>里氏替换原则：</strong>任何基类可以出现的地方，子类一定可以出现。</p><p><strong>开放封闭原则：</strong>对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p><strong>迪米特原则：</strong>每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。</p><p><strong>合成复用原则：</strong>尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</p><h2 id="1、单一职责原则-各行其责"><a href="#1、单一职责原则-各行其责" class="headerlink" title="1、单一职责原则(各行其责)"></a>1、单一职责原则(各行其责)</h2><h3 id="1-1、基本介绍"><a href="#1-1、基本介绍" class="headerlink" title="1.1、基本介绍"></a>1.1、基本介绍</h3><p>​        对类来说的，<strong>即一个类应该只负责一项职责</strong>。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p><h3 id="1-2、单一职责原则注意事项和细节"><a href="#1-2、单一职责原则注意事项和细节" class="headerlink" title="1.2、单一职责原则注意事项和细节"></a>1.2、单一职责原则注意事项和细节</h3><p>1、降低类的复杂度，一个类只负责一项职责。</p><p>2、提高类的可读性，可维护性</p><p>3、降低变更引起的风险</p><p>4、通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则;只有类中方法数量足够少，可以在方法级别保持单一职责原则</p><h2 id="2、接口隔离原则"><a href="#2、接口隔离原则" class="headerlink" title="2、接口隔离原则"></a>2、接口隔离原则</h2><h3 id="2-1、基本介绍"><a href="#2-1、基本介绍" class="headerlink" title="2.1、基本介绍"></a>2.1、基本介绍</h3><p>​        1.客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><p>​        2.<img src="/2022/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/image-20220228171705912.png" alt="image-20220228171705912"></p><p>​        3.类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。</p><p>​        4.按隔离原则应当这样处理：</p><p>将<strong>接口Interface1</strong>拆分为<strong>独立的几个接口</strong>，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p><p><strong>所以改进之后的图形为</strong></p><p><img src="/2022/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/image-20220301170816017.png" alt="image-20220301170816017"></p><h2 id="3、依赖倒转-倒置-原则"><a href="#3、依赖倒转-倒置-原则" class="headerlink" title="3、依赖倒转(倒置)原则"></a>3、依赖倒转(倒置)原则</h2><h3 id="3-1、基本介绍"><a href="#3-1、基本介绍" class="headerlink" title="3.1、基本介绍"></a>3.1、基本介绍</h3><p>依赖倒转原则(<strong>Dependence Inversion Principle</strong>)是指：</p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转(倒置)的中心思想是面向接口编程</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><p><strong>其实就是多多使用接口</strong></p><h3 id="3-2、依赖关系传递的三种方式"><a href="#3-2、依赖关系传递的三种方式" class="headerlink" title="3.2、依赖关系传递的三种方式"></a>3.2、依赖关系传递的三种方式</h3><ol><li><p>接口传递</p></li><li><p>构造方法传递</p></li><li><p>setter方式传递</p></li></ol><h3 id="3-3、依赖倒转原则的注意事项和细节"><a href="#3-3、依赖倒转原则的注意事项和细节" class="headerlink" title="3.3、依赖倒转原则的注意事项和细节"></a>3.3、依赖倒转原则的注意事项和细节</h3><ol><li><p>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好. </p></li><li><p>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</p></li><li><p>继承时遵循里氏替换原则</p></li></ol><h2 id="4、里氏替换原则"><a href="#4、里氏替换原则" class="headerlink" title="4、里氏替换原则"></a>4、里氏替换原则</h2><h3 id="4-1、基本介绍"><a href="#4-1、基本介绍" class="headerlink" title="4.1、基本介绍"></a>4.1、基本介绍</h3><ol><li><p>里氏替换原则(<strong>Liskov Substitution Principle</strong>)在1988年，由麻省理工学院的以为姓里的女士提出的。</p></li><li><p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p></li><li><p>在使用继承时，遵循里氏替换原则，在子类中<strong>尽量</strong>不要重写父类的方法。</p></li><li><p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，<strong>在适当的情况下，可以通过聚合，组合，依赖 来解决问题。</strong></p></li></ol><h2 id="5、开闭原则"><a href="#5、开闭原则" class="headerlink" title="5、开闭原则"></a>5、开闭原则</h2><h3 id="5-1、基本介绍"><a href="#5-1、基本介绍" class="headerlink" title="5.1、基本介绍"></a>5.1、基本介绍</h3><ol><li><p>开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</p></li><li><p>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。</p></li><li><p>当软件需要变化时，尽量<strong>通过扩展</strong>软件实体的行为来实现变化，而<strong>不是通过修改</strong>已有的代码来实现变化。</p></li><li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循<strong>开闭原则</strong>。</p></li></ol><h2 id="6、迪米特法则"><a href="#6、迪米特法则" class="headerlink" title="6、迪米特法则"></a>6、迪米特法则</h2><h3 id="6-1、基本介绍"><a href="#6-1、基本介绍" class="headerlink" title="6.1、基本介绍"></a>6.1、基本介绍</h3><ol><li><p>一个对象应该对其他对象保持最少的了解</p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则(<strong>Demeter Principle</strong>)又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p></li><li><p><strong>直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p></li></ol><h3 id="6-2、迪米特法则注意事项和细节"><a href="#6-2、迪米特法则注意事项和细节" class="headerlink" title="6.2、迪米特法则注意事项和细节"></a>6.2、<strong>迪米特法则注意事项和细节</strong></h3><ol><li><p>迪米特法则的核心是<strong>降低类之间的耦合</strong></p></li><li><p>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</p></li></ol><h2 id="7、合成复用原则"><a href="#7、合成复用原则" class="headerlink" title="7、合成复用原则"></a>7、合成复用原则</h2><h3 id="7-1、基本介绍"><a href="#7-1、基本介绍" class="headerlink" title="7.1、基本介绍"></a>7.1、基本介绍</h3><p><img src="/2022/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/image-20220310200341954.png" alt="image-20220310200341954"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/2022/02/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/02/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/02/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220222173325718.png" alt="反转链表"></p><p>解法：</p><p><strong>迭代法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur.next; <span class="hljs-comment">// 暂存后继节点 cur.next</span><br>            cur.next = pre;          <span class="hljs-comment">// 修改 next 引用指向</span><br>            pre = cur;               <span class="hljs-comment">// pre 暂存 cur</span><br>            cur = tmp;               <span class="hljs-comment">// cur 访问下一节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>视频解析：</p><p><a href="https://www.bilibili.com/video/BV1KZ4y157Up/?spm_id_from=333.788">https://www.bilibili.com/video/BV1KZ4y157Up/?spm_id_from=333.788</a></p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="/2022/02/18/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/02/18/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/02/18/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/image-20220218173604940.png" alt="从尾到头打印链表"></p><p><strong>解题思路一：</strong></p><p>看见<code>从尾到头反过来返回每个节点的值</code>可以反应到要使用==栈==进行解题</p><p><strong>题解一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        <span class="hljs-comment">// 构建一个栈，用来存储链表中每个结点的值</span><br>        Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;ListNode&gt;();<br>        <span class="hljs-comment">// 让指针指向链表的头节点然后依次往后遍历</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 把节点的值放到栈内</span><br>            stack.push(temp);<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-comment">// 获取栈的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> stack.size();<br>        <span class="hljs-comment">// 定义一个与栈同样长度的数组</span><br>        <span class="hljs-type">int</span>[] print = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        <span class="hljs-comment">// 遍历栈，将栈内的元素依次加入到数组中 最后返回数组即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            print[i] = stack.pop().val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> print;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/18/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/image-20220218175224990.png" alt="执行结果"></p><p>———————————————————————————手动分割线————————————————————————————</p><p><strong>解题思路二：</strong></p><p>递归法：先走到链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p><p><strong>题解二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        recur(head);<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[tmp.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.length; i++)<br>            res[i] = tmp.get(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        recur(head.next);<br>        <span class="hljs-comment">// </span><br>        tmp.add(head.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包含main函数的栈</title>
    <link href="/2022/02/18/%E5%8C%85%E5%90%ABmain%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <url>/2022/02/18/%E5%8C%85%E5%90%ABmain%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/02/18/%E5%8C%85%E5%90%ABmain%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/image-20220218162324175.png" alt="包含main函数的栈"></p><p><strong>解题思路</strong></p><blockquote><p>普通栈的 <code>push()</code> 和 <code>pop()</code> 函数的复杂度为 O(1)<em>O</em>(1) ；而获取栈最小值 <code>min()</code> 函数需要遍历整个栈，复杂度为 O(N)<em>O</em>(<em>N</em>) 。</p></blockquote><p>所以需要使用辅助栈将获取最小值时间复杂度变成O(1)</p><p>使用辅助栈B，保证栈B的元素是栈A中的最小值（在栈A加入数据之前与栈B的顶部数据进行对比，如果栈A数据小则压入栈B，反之不压入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">// 定义两个栈，一个A数据栈负责将数据存入，一个栈B负责存入最小值</span><br>    Stack&lt;Integer&gt; A, B;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;    <br>        A.add(x);<br>        <span class="hljs-comment">// 如果栈B为空或者栈B的顶部数据大于等于存入的数据，就意味着新加入的数据小于栈B，就将这个数据压入栈B</span><br>        <span class="hljs-keyword">if</span>(B.empty() || B.peek() &gt;= x)<br>            B.add(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//当栈A弹出的时候，如果栈B的顶部数据等于栈A要弹出的数据，就将栈B顶也弹出，保证元素一致，也避免了重复数据造成的影响。</span><br>        <span class="hljs-keyword">if</span>(A.pop().equals(B.peek()))<br>            B.pop();<br>    &#125;<br>    <br>    <span class="hljs-comment">//栈A的栈顶就是顶部数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> A.peek();<br>    &#125;<br>    <br>    <span class="hljs-comment">//栈B的栈顶就是最小数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> B.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/18/%E5%8C%85%E5%90%ABmain%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/image-20220218165841704.png" alt="执行结果"></p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上传博客发现的问题</title>
    <link href="/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>上传博客之后在控制台发现成功，但是访问网址却发现什么也没有，于是前往博客所在的public文件夹下发现里面并没有上传博客的详细信息</p><p><img src="/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220217233726151.png" alt="控制台输出成功"></p><p><img src="/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220217233915883.png" alt="public下什么都没有"></p><p>创建一个新的笔记之后直接上传发现上传成功</p><p><img src="/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/XQH$RAL53Z%5BD%7DXAVK$C5SF5.png" alt="发现123上传成功"></p><p>于是创建了一个没有标签和分类的同样的笔记进行上传发现上传成功</p><p><img src="/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220217234138730.png" alt="没有标签和分类的笔记上传成功"></p><p>自此 发现问题所在：</p><p><img src="/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220217234237986.png" alt="标签和分类的：后没有加空格"></p><p>于是添加空格之后发现上传成功，自此问题完美解决。</p><p><img src="/2022/02/17/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220217234326636.png" alt="上传成功"></p>]]></content>
    
    
    <categories>
      
      <category>error</category>
      
    </categories>
    
    
    <tags>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个栈实现队列</title>
    <link href="/2022/02/17/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/02/17/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/02/17/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/image-20220217232828591.png" alt="两个栈实现队列"></p><p>这个题目可能比较难以理解题意，下面先分析一下题目的意思：</p><blockquote><p>题意</p></blockquote><p>输入： [“CQueue”,”appendTail”,”deleteHead”,”deleteHead”] 这里是要执行的方法，从左到右执行</p><p>[[],[3],[],[]]对应上面的方法，是上面方法的参数。CQueue和deleteHead方法不需要指定数字，只有添加才需要指定数字</p><p>1、创建队列，返回值为null</p><p>2、将3压入栈，返回值为null</p><p>3、将栈底的元素删除，也就是消息队列中先进来的元素，所以是deleteHead，返回该元素的数值，所以为3</p><p>4、继续删除栈底的元素，但是没有元素了，所以返回-1</p><p>​    输出：[null,null,3,-1]</p><blockquote><p>题解</p></blockquote><p>为什么不用Stack的方式而使用LinkedList？</p><p><img src="/2022/02/17/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/image-20220217232841417.png" alt="image-20220217232841417"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br><br>    <span class="hljs-comment">//两个栈，一个执行添加,一个执行删除</span><br>    LinkedList&lt;Integer&gt; stack1;<br>    LinkedList&lt;Integer&gt; stack2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 栈1只负责添加数据</span><br>        stack1.add(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果栈2是空</span><br>        <span class="hljs-keyword">if</span>(stack2.isEmpty()) &#123;<br>            <span class="hljs-comment">// 由于栈2和栈1是空,由于栈内没数据所以返回值为-1</span><br>            <span class="hljs-keyword">if</span>(stack1.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果栈1不是空，那么将栈1的值从顶部弹出放入栈2中,并且返回栈2的顶部的值（也就是将栈1底部的值删除）</span><br>            <span class="hljs-keyword">while</span>(!stack1.isEmpty()) &#123;<br>                stack2.add(stack1.pop());<br>            &#125;<br>            <span class="hljs-keyword">return</span> stack2.pop();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> stack2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上就是队列的先进先出，栈的先进后出，两个栈互相交互就可以实现像是队列的先进先出的功能。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搭建自己的博客</title>
    <link href="/2022/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>1、下载nodejs</p><p>2、下载git</p><p>查看自己的node与git是否安装成功：</p><p><code>node -v</code></p><p><code>npm -v</code></p><p><code>git --version</code></p><p>3、下载hexo  ： <code>npm install hexo-cli -g </code>          查看自己的安装是否成功 <code>hexo -v</code></p><h1 id="搭建仓库"><a href="#搭建仓库" class="headerlink" title="搭建仓库"></a>搭建仓库</h1><p>1、注册github <a href="https://www.bilibili.com/read/cv5107169">https://www.bilibili.com/read/cv5107169</a></p><p>2、项目的名字必须是自己的github名字+github.io</p><p>3、生成ssh：<code>ssh-keygen -t rsa -C</code> “邮箱地址”</p><p>测试 ssh是否绑定成功：ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a></p><h1 id="本地生成博客内容"><a href="#本地生成博客内容" class="headerlink" title="本地生成博客内容"></a>本地生成博客内容</h1><p><strong><code>hexo init</code> # 初始化hexo博客</strong></p><p><img src="/2022/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20211201154906091.png"></p><p><strong><code>hexo s</code> # 启动服务</strong></p><h1 id="发布博客到网上"><a href="#发布博客到网上" class="headerlink" title="发布博客到网上"></a>发布博客到网上</h1><p>在_config.yml最后面加上</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">自己博客的地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p><img src="/2022/01/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20220521110224702.png"></p><p>安装hexo-deployer-git 自动部署发布工具：<code>npm install hexo-deployer-git --save</code></p><p><strong>生成页面</strong> : <code>hexo g</code></p><p><strong>将文件上传到github：</strong><code>hexo d</code></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot连接canal出现timeout</title>
    <link href="/2022/01/14/springboot%E8%BF%9E%E6%8E%A5canal%E5%87%BA%E7%8E%B0timeout/"/>
    <url>/2022/01/14/springboot%E8%BF%9E%E6%8E%A5canal%E5%87%BA%E7%8E%B0timeout/</url>
    
    <content type="html"><![CDATA[<h2 id="发现问题："><a href="#发现问题：" class="headerlink" title="发现问题："></a>发现问题：</h2><p>当你使用springboot连接linux实现canal数据同步的时候，控制台输出了</p><p><img src="/2022/01/14/springboot%E8%BF%9E%E6%8E%A5canal%E5%87%BA%E7%8E%B0timeout/%7B%25Y0IH%60EVY%25VJV%5B3B5$AA2-16421386665471.png" alt="img"></p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>1、首先在xshell上运行<code>systemctl start firewalld.service</code>开启防火墙</p><p>2、然后输入<code>firewall-cmd --list-port</code>查看11111端口号是否开启</p><p>3、如果出现了<br><img src="/2022/01/14/springboot%E8%BF%9E%E6%8E%A5canal%E5%87%BA%E7%8E%B0timeout/TW@%7BN%5B%5BIORPX8@Y9AAAZ3K.png" alt="img"><br>证明开启了11111端口号</p><p>4、如果没有开启输入 <code>firewall-cmd --zone=public --add-port=11111/tcp --permanent</code>  开启端口号</p><p>5、然后输入<code>firewall-cmd --reload</code>重启防火墙更新配置</p><p>6、然后在阿里云上新增安全组开放11111端口</p><h2 id="进行测试："><a href="#进行测试：" class="headerlink" title="进行测试："></a>进行测试：</h2><p>在xshell上进行数据的增删改操作</p><p><img src="/2022/01/14/springboot%E8%BF%9E%E6%8E%A5canal%E5%87%BA%E7%8E%B0timeout/image-20220114134009800.png" alt="image-20220114134009800"></p><p>本地控制台输出有关信息</p><p><img src="/2022/01/14/springboot%E8%BF%9E%E6%8E%A5canal%E5%87%BA%E7%8E%B0timeout/image-20220114134047446.png" alt="image-20220114134047446"></p><p>查看本地mysql数据库发现有数据的增加</p><p><img src="/2022/01/14/springboot%E8%BF%9E%E6%8E%A5canal%E5%87%BA%E7%8E%B0timeout/image-20220114134122429.png" alt="image-20220114134122429"></p><p>canal连接以及测试成功！！！</p>]]></content>
    
    
    <categories>
      
      <category>error</category>
      
    </categories>
    
    
    <tags>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何上传博客</title>
    <link href="/2021/12/23/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/12/23/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>1、先找到你的blog的文件夹</p><p>2、在文件夹中右键 git bash</p><p>3、利用 <code>hexo new post XXX</code> xxx是你的博客中文章的名字</p><p>4、在博客文件夹下的source的_posts中找到你的.md后缀的文章名字</p><p>5、在md文件中写入你的博客</p><p>6、利用命令 <code>hexo g</code>生成你文章的静态文件</p><p>7、利用命令<code>hexo d</code>上传到GitHub中</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
