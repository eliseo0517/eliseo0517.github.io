<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eliseo的小屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-25T02:50:55.069Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mr.Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>礼物的最大价值</title>
    <link href="http://example.com/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <id>http://example.com/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</id>
    <published>2022-04-25T02:42:24.000Z</published>
    <updated>2022-04-25T02:50:55.069Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220425104246376.png" alt="礼物的最大价值"></p><p><strong>解法一：</strong></p><p>暴力递归，对于一个格子只有两种情况：不是向下移动就是向右移动，所以定义两个变量，一个 == 向右移动的值 一个 == 向下移动的值 ，然后取max + 这个格子左上角的值</p><p>代码 <em>略</em></p><p><strong>解法二：</strong></p><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test14</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义行和列</span><br>        <span class="hljs-keyword">int</span> row = grid.length;<br>        <span class="hljs-keyword">int</span> column = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 多加一行一列 所以dp[1][0..column]相当于grid[0][0...column]</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row + <span class="hljs-number">1</span>][column + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[1][0..column]相当于grid[0][0...column] 所以i与j从1开始 直到 等于行与列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= column; j++) &#123;<br>                dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row][column];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] grid = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        System.out.println(maxValue(grid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220425104246376.png&quot; alt=&quot;礼物的最大价值&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>mysql8通过Data文件恢复数据</title>
    <link href="http://example.com/2022/04/21/mysql8%E9%80%9A%E8%BF%87Data%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2022/04/21/mysql8%E9%80%9A%E8%BF%87Data%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</id>
    <published>2022-04-21T15:30:51.000Z</published>
    <updated>2022-04-21T15:34:13.276Z</updated>
    
    <content type="html"><![CDATA[<p>原因：数据库突然开不开了，怕麻烦就没有备份数据库，只留下了Data文件，结果新版本mysql不能使用旧版本的data，单纯的替换ibdata1文件也不行。</p><p><strong>操作：</strong></p><p>1、打开任务管理器，关闭MySQL80.exe</p><p>2、需要覆盖的文件：ibdata1，ib_logfile0，ib_logfile1，ib_buffer_pool，auto.cnf，mysql.ibd</p><p>3、重新打开MySQL80.exe</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原因：数据库突然开不开了，怕麻烦就没有备份数据库，只留下了Data文件，结果新版本mysql不能使用旧版本的data，单纯的替换ibdata1文件也不行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、打开任务管理器，关闭MySQL80.exe&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-04-21T13:30:29.000Z</published>
    <updated>2022-04-24T11:58:20.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h1><p>动态规划：如果你发现你有重复调用的过程动态规划再算过一次之后把答案记下来，下一次再遇到重复过程直接调这个行为就叫动态规划（空间换时间）</p><p>暴力递归 –&gt;傻缓存–&gt;动态规划</p><p>最简单的例子：斐波那契数列</p><h1 id="机器人走路问题"><a href="#机器人走路问题" class="headerlink" title="机器人走路问题"></a>机器人走路问题</h1><div class="note note-primary">            <p><strong>题目：</strong></p><p>假设有拍成一行的N个位置记为1到N，N一定大于等于2；</p><p>开始时机器人在其中的M位置上（M一定是1到N中的一个）；</p><p>如果机器人来到1位置那么下一步只能往右来到2位置；</p><p>如果机器人来到N位置那么下一步只能往左来到N-1位置；</p><p>规定机器人一定要走K步，最终能来到P位置（P也是1~N中的一个）的方法有多少种；</p><p>给定四个桉树N，M，K，P，返回方法数</p>          </div><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_RobotWalk</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> process1(start, K, aim, N);<br>    &#125;<br><br>    <span class="hljs-comment">// 机器人当前来到的位置是cur</span><br>    <span class="hljs-comment">// 机器人还有rest步需要走</span><br>    <span class="hljs-comment">// 最终要去的地方是aim</span><br>    <span class="hljs-comment">// 有哪些位置？1~N</span><br>    <span class="hljs-comment">// 返回值：机器人从cur开始走，走过rest部署之后最后停在aim地方的方法数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果已经不需要走了，那就是走完了所有的rest步数</span><br>            <span class="hljs-keyword">return</span> cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// rest &gt; 0 还有步数需要走</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果机器人在1那么只能走向2的位置 1-&gt;2</span><br>            <span class="hljs-comment">// 如果我机器人在1那么他只能去2，也就是说 机器人从1走rest步数到aim相当于机器人从2位置走rest-1部署走到aim</span><br>            <span class="hljs-keyword">return</span> process1(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>        &#125;<br>        <span class="hljs-comment">// 同理对于机器人在N位置也是只能走向N-1位置</span><br>        <span class="hljs-keyword">if</span> (cur == N) &#123; <span class="hljs-comment">// N-&gt;N-1</span><br>            <span class="hljs-keyword">return</span> process1(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>        &#125;<br>        <span class="hljs-comment">// 机器人在除了1和N的其他位置上</span><br>        <span class="hljs-keyword">return</span> process1(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N) + process1(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(ways1(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法2：（对解法1进行优化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_RobotWalk</span> </span>&#123;<br><span class="hljs-comment">// 优化：因为ways1会存在计算同一个位置与步数的情况,因为会有重复过程</span><br>    <span class="hljs-comment">// dp作为一个缓存，就是一个如果你没计算过这个位置与步数的信息那么就是-1，然后去计算</span><br>    <span class="hljs-comment">// 如果已经计算过了，那么就是你将你计算的值付给dp[cur][rest]然后下次需要的时候就直接拿上用，避免重复计算</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= K; j++) &#123;<br>                dp[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp就是缓存表</span><br>        <span class="hljs-comment">// dp[cur][rest] == -1   -&gt;   process1(cur, rest) 之前没算过！</span><br>        <span class="hljs-comment">// dp[cur][rest] != -1   -&gt;   process1(cur, rest) 之前算过！返回值，dp[cur][rest]</span><br>        <span class="hljs-comment">// K+1 * N+1 的二维数组 保证任何一组参数组合都能放到这个二维数组内部</span><br>        <span class="hljs-keyword">return</span> process2(start, K, aim, N, dp);<br>    &#125;<br><br>    <span class="hljs-comment">// cur范围： 1~N</span><br>    <span class="hljs-comment">// rest范围： 0~K</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[][] dp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dp[cur][rest] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> dp[cur][rest];<br>        &#125;<br>        <span class="hljs-comment">// 之前没算过</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans = cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>            ans = process2(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == N) &#123;<br>            ans = process2(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = process2(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp) + process2(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125;<br>        <span class="hljs-comment">// 相当于只算了一次在一个位置同一个步数的情况</span><br>        dp[cur][rest] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(ways2(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法三：（最终优化）</strong></p><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220421215607265.png" alt="image-20220421215607265"></p><p>由此可以对问题进行最终的优化：第0列除了dp[ aim] [ 0] =1其余都是0，第一行与第N行进行手动赋值，其余的都是等于上一行的前一个与下一行的前一个之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_RobotWalk</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 画一个二维数组</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];<br>        dp[aim][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// dp[...][0] = 0; java中自动就是0</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= K; rest++) &#123;<br>            <span class="hljs-comment">// 第一行手动赋值</span><br>            dp[<span class="hljs-number">1</span>][rest] = dp[<span class="hljs-number">2</span>][rest - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cur = <span class="hljs-number">2</span>; cur &lt; N; cur++) &#123;<br>                dp[cur][rest] = dp[cur - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>] + dp[cur + <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 最后一行手动赋值</span><br>            dp[N][rest] = dp[N - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[start][K];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(ways3(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="扑克牌问题"><a href="#扑克牌问题" class="headerlink" title="扑克牌问题"></a>扑克牌问题</h1><div class="note note-primary">            <p><strong>题目</strong></p><p>给定一个整型数组arr（数组内的数都是正数），代表数值不同的指派排成一条线</p><p>玩家A和玩家B依次拿走每张纸牌</p><p>规定玩家A先拿，玩家B后拿</p><p>但是每个玩家每次只能拿走最左或最右的纸牌</p><p>玩家A和玩家B都聪明绝顶</p><p>请返回最后获胜者的分数</p>          </div><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_CardsinLine</span> </span>&#123;<br><br>    <span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">win1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> first = f(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> second = g(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(first, second);<br>    &#125;<br><br>    <span class="hljs-comment">// 先手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，先手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span> arr[L];<br>        &#125;<br>        <span class="hljs-comment">// 1：我拿走左侧的牌，然后我在L+1到R上获得的最好的牌</span><br>        <span class="hljs-keyword">int</span> p1 = arr[L] + g(arr, L + <span class="hljs-number">1</span>, R);<br>        <span class="hljs-comment">// 2：我拿走左侧的牌，然后我在L到R-1上获得的最好的牌</span><br>        <span class="hljs-keyword">int</span> p2 = arr[R] + g(arr, L, R - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> Math.max(p1, p2);<br>    &#125;<br><br>    <span class="hljs-comment">// 后手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，后手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> p1 = f(arr, L + <span class="hljs-number">1</span>, R); <span class="hljs-comment">// 对手拿走了L位置的牌</span><br>        <span class="hljs-keyword">int</span> p2 = f(arr, L, R - <span class="hljs-number">1</span>); <span class="hljs-comment">// 对手拿走了R位置的牌</span><br><br>        <span class="hljs-keyword">return</span> Math.min(p1, p2);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win1(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法2：（对解法1进行优化）</strong></p><div class="note note-success">            <p>定义两个二维数组，将计算之后的数值加到数值里面，防止重复计算</p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423205953240.png" alt="image-20220423205953240"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_CardsinLine</span> </span>&#123;<br><br>    <span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-comment">// 加一个缓存（因为win1存在重复计算某一个数的情况）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">win2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加两个缓存表</span><br>        <span class="hljs-keyword">int</span> N = arr.length;<br>        <span class="hljs-keyword">int</span>[][] fmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-keyword">int</span>[][] gmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-comment">// 如果ij在函数f2函数没有被计算过，那么就是-1 计算过就是对应的值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>                fmap[i][j] = -<span class="hljs-number">1</span>;<br>                gmap[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">int</span> first = f2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, fmap, gmap);<br>        <span class="hljs-keyword">int</span> second = g2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, fmap, gmap);<br>        <span class="hljs-keyword">return</span> Math.max(first, second);<br>    &#125;<br><br>    <span class="hljs-comment">// 先手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，先手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span>[][] fmap, <span class="hljs-keyword">int</span>[][] gmap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (fmap[L][R] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> fmap[L][R];<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            ans = arr[L];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 1：我拿走左侧的牌，然后我在L+1到R上获得的最好的牌</span><br>            <span class="hljs-keyword">int</span> p1 = arr[L] + g2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap);<br>            <span class="hljs-comment">// 2：我拿走左侧的牌，然后我在L到R-1上获得的最好的牌</span><br>            <span class="hljs-keyword">int</span> p2 = arr[R] + g2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap);<br>            ans = Math.max(p1, p2);<br>        &#125;<br>        fmap[L][R] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 后手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，后手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">g2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span>[][] fmap, <span class="hljs-keyword">int</span>[][] gmap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (gmap[L][R] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> gmap[L][R];<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            ans = arr[L];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> p1 = f2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap); <span class="hljs-comment">// 对手拿走了L位置的牌</span><br>            <span class="hljs-keyword">int</span> p2 = f2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap); <span class="hljs-comment">// 对手拿走了R位置的牌</span><br>            ans = Math.min(p1, p2);<br>        &#125;<br>        gmap[L][R] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win2(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法三：（最终优化）</strong></p><div class="note note-success">            <p>由于数值arr一定是<strong>L&gt;R</strong>，因此只有数组的一半是存在定义的</p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423210149765.png" alt="image-20220423210149765"></p><div class="note note-success">            <p>由解法一可以得出来，表f与表g有关系，并且f表对应到g表之后与对应位置的左边与下边有关联，也就是<strong>g(0)(1) = f(0)(0)+f(1)(1)</strong></p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423210949953.png" alt="image-20220423210949953"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_CardsinLine</span> </span>&#123;<br>    <br><span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-comment">// 加一个缓存（因为win1存在重复计算某一个数的情况）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">win3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加两个缓存表</span><br>        <span class="hljs-keyword">int</span> N = arr.length;<br>        <span class="hljs-keyword">int</span>[][] fmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-keyword">int</span>[][] gmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            fmap[i][i] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">// 描述 按照对角线将两个二维数组互推</span><br>        <span class="hljs-comment">// startCol == 对角线的开始列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> startCol = <span class="hljs-number">1</span>; startCol &lt; N; startCol++) &#123;<br>            <span class="hljs-comment">// row 对角线的开始行</span><br>            <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> R = startCol;<br>            <span class="hljs-comment">// 发现相对于行 列比行先越界</span><br>            <span class="hljs-keyword">while</span> (R &lt; N) &#123;<br>                fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="hljs-number">1</span>][R], arr[R] + gmap[L][R - <span class="hljs-number">1</span>]);<br>                gmap[L][R] = Math.min(fmap[L + <span class="hljs-number">1</span>][R], fmap[L][R - <span class="hljs-number">1</span>]);<br>                <span class="hljs-comment">// 实现对角线往下爬 且不能越界</span><br>                L++;<br>                R++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(fmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>], gmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win3(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><div class="note note-primary">            <p><strong>有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p>          </div><p><strong>解法一：</strong></p><div class="note note-success">            <p>对于一个货物只有p1（选择这个货物），p2（不选择这个货物）两个决策，当你不选择了这个货物那么就将index++往下对下一个货物进行决策；如果选择这个货物那么就对选择了货物之后背包的重量进行判断是否&gt;0,&gt;0就选择当前货物，否则不选</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code3_Knapsack</span> </span>&#123;<br><br>    <span class="hljs-comment">// 所有的货，重量和价值都在w和v数组中</span><br>    <span class="hljs-comment">// 为了方便，其中没有复数</span><br>    <span class="hljs-comment">// bag背包容量，不能超过这个数</span><br>    <span class="hljs-comment">// 返回：不超过背包容量的情况下，能够得到的最大价值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span> || w.length != v.length || w.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 尝试函数！</span><br>        <span class="hljs-keyword">return</span> process(w, v, <span class="hljs-number">0</span>, bag);<br>    &#125;<br><br>    <span class="hljs-comment">// 当前考虑到了index号货物，index....所有的货物都可以自由选择</span><br>    <span class="hljs-comment">// 做的选择不能超过背包容量</span><br>    <span class="hljs-comment">// 返回最大价值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (bag &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 为什么不写bag = 0 ：因为 万一存在货物 重量为0但是存在价值</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == w.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 有货物，index位置的货</span><br>        <span class="hljs-comment">// bag有空间</span><br>        <span class="hljs-comment">// 不要当前的货物</span><br>        <span class="hljs-keyword">int</span> p1 = process(w, v, index + <span class="hljs-number">1</span>, bag);<br>        <span class="hljs-comment">// 要当前的货物</span><br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用来判断</span><br>        <span class="hljs-keyword">int</span> next = process(w, v, index + <span class="hljs-number">1</span>, bag - w[index]);<br>        <span class="hljs-keyword">if</span> (next != -<span class="hljs-number">1</span>) &#123;<br>            p2 = v[index] + next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(p1, p2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] weights = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] values = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">19</span>&#125;;<br>        <span class="hljs-keyword">int</span> bag = <span class="hljs-number">11</span>;<br>        System.out.println(maxValue(weights,values,bag));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">25</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法二：（对解法一进行优化）</strong></p><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220424172800335.png" alt="image-20220424172800335"></p><p>通过代码<strong>if (index == w.length) {return 0;}</strong> 可以得出二位数组的最后一行都为0，通过 <strong>int p1 = process(w, v, index + 1, bag); int next = process(w, v, index + 1, bag - w[index]);</strong> 可以得出我们需要知道一个格子的值只要知道下一行的值我们就可以得到这个格子的值；因此我们可以从最后一行开始入手得到倒数第二行…..直到第一行，同一行不存在依赖关系，所以从左往右写 或者从左往右写都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code3_Knapsack</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span> || w.length != v.length || w.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> N = w.length;<br>        <span class="hljs-comment">// index 0</span><br>        <span class="hljs-comment">// rest 0~bag</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][bag + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[N][...] = 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= bag; rest++) &#123;<br>                <span class="hljs-keyword">int</span> p1 = dp[index + <span class="hljs-number">1</span>][rest];<br>                <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">int</span> next = rest - w[index] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : dp[index + <span class="hljs-number">1</span>][rest - w[index]];<br>                <span class="hljs-keyword">if</span> (next != -<span class="hljs-number">1</span>) &#123;<br>                    p2 = v[index] + next;<br>                &#125;<br>                dp[index][rest] = Math.max(p1, p2);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][bag];<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] weights = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] values = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">19</span>&#125;;<br>        <span class="hljs-keyword">int</span> bag = <span class="hljs-number">11</span>;<br>        System.out.println(maxValue(weights,values,bag));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">25</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是动态规划？&quot;&gt;&lt;a href=&quot;#什么是动态规划？&quot; class=&quot;headerlink&quot; title=&quot;什么是动态规划？&quot;&gt;&lt;/a&gt;什么是动态规划？&lt;/h1&gt;&lt;p&gt;动态规划：如果你发现你有重复调用的过程动态规划再算过一次之后把答案记下来，下一次再遇到重复过</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="http://example.com/2022/04/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://example.com/2022/04/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2022-04-19T15:04:09.000Z</published>
    <updated>2022-04-25T02:44:47.625Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/image-20220419230424599.png" alt="连续子数组的最大和"></p><p><strong>题解：</strong></p><p>前i个数字的和如果小于零，那么说明第i+1个数如果加上前i个数就会变得更小，那么前i+1个数字和的最大就是nums[i+1]（注意：子数组也可以是数组中一个值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">// dp表示以nums[i]为数组尾部的子数组最大值</span><br>        <span class="hljs-keyword">int</span> dp = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (dp &gt; <span class="hljs-number">0</span>) &#123;<br>                dp = dp + nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp = nums[i];<br>            &#125;<br>            max = Math.max(max, dp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/image-20220419230424599.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>股票的最大利润</title>
    <link href="http://example.com/2022/04/19/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <id>http://example.com/2022/04/19/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</id>
    <published>2022-04-19T08:52:39.000Z</published>
    <updated>2022-04-25T02:52:59.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20220419165313973.png" alt="股票的最大利润"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 动态规划</span><br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; min) &#123;<br>                min = prices[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] - min &gt; max) &#123;<br>                max = prices[i] - min;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/19/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20220419165313973.png&quot; alt=&quot;股票的最大利润&quot;&gt;&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>青蛙跳台阶问题</title>
    <link href="http://example.com/2022/04/19/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/04/19/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-19T08:17:37.000Z</published>
    <updated>2022-04-25T02:44:50.845Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/image-20220419162220107.png" alt="青蛙跳台阶问题"></p><p><strong>题解：</strong></p><p>设跳上 nn级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。<br>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；<br>当为 2 级台阶： 剩 n-2n个台阶，此情况共有 f(n-2) 种跳法。</p><p>所以 综上所述，其实就是一个f(0) = 1;f(1) = 1;f(2) = 2的斐波那契数列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 所求的斐波那契数就是前两个之和</span><br>            b = a + b;<br>            <span class="hljs-comment">// 相当于将 b的值赋给了a</span><br>            a = b - a;<br>            b = b % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/19/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/image-20220419162220107.png&quot; alt=&quot;青蛙跳台阶问题&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="http://example.com/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://example.com/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2022-04-19T07:11:23.000Z</published>
    <updated>2022-04-25T02:44:28.712Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/image-20220419151140087.png" alt="斐波那契数列"></p><p><strong>题解：</strong></p><p>方法一：一个简单的递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是<img src="/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/image-20220419151311240.png" alt="image-20220419151311240"></p><p><strong>原因：</strong>原因是这个递归的时间复杂度是2^n，有大量的重复计算。在递归次数较大时时间呈指数增长</p><p><strong>方法二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 所求的斐波那契数就是前两个之和</span><br>            b = a + b;<br>            <span class="hljs-comment">// 相当于将 b的值赋给了a</span><br>            a = b - a;<br><br>            b = b % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/image-20220419151140087.png&quot; alt=&quot;斐波那契数列&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题解</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>对称的二叉树</title>
    <link href="http://example.com/2022/04/18/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/04/18/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-04-18T15:47:37.000Z</published>
    <updated>2022-04-25T02:44:15.571Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/18/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220418234825507.png" alt="对称的二叉树"></p><p>题解：</p><p>什么时候这个二叉树对称呢，只有这个节点的左节点与右节点相同，且左节点的左节点与右节点的右节点相同，并且左节点的右节点右节点的左节点相同时才可以说二叉树对称，那么就能想到使用递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 1、判断特例</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则开始判断节点的左节点和右节点</span><br>            <span class="hljs-keyword">return</span> recur(root.left, root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果左右节点都为空 那么就证明对称</span><br>        <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span> &amp;&amp; R == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果左节点或者右节点或者左节点不等于右节点 那么就证明不对称 返回false</span><br>        <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span> || R == <span class="hljs-keyword">null</span> || L.val != R.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 到这一步就证明左节点等于右节点，那么就判断左节点的左节点是否等于最右节点的右节点</span><br>        <span class="hljs-keyword">return</span> recur(L.left,R.right) &amp;&amp; recur(L.right,R.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/18/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220418234825507.png&quot; alt=&quot;对称的二叉树&quot;&gt;&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的镜像</title>
    <link href="http://example.com/2022/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>http://example.com/2022/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</id>
    <published>2022-04-18T09:42:15.000Z</published>
    <updated>2022-04-25T02:43:25.852Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/image-20220418175346511.png" alt="二叉树的镜像"></p><p>代码实现：</p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 循环跳出的条件</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 中间值暂存左节点或者右节点的值</span><br>        TreeNode tmp = root.left;<br>        <span class="hljs-comment">// 递归</span><br>        root.left = mirrorTree(root.right);<br>        root.right = mirrorTree(tmp);<br>        <span class="hljs-keyword">return</span>  root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/image-20220418175346511.png&quot; alt=&quot;二叉树的镜像&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>树的子结构</title>
    <link href="http://example.com/2022/04/18/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/04/18/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
    <published>2022-04-18T09:18:39.000Z</published>
    <updated>2022-04-25T02:44:38.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/18/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/image-20220418171021861.png" alt="树的子结构"></p><p>题解：</p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 判断头节点是否一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、首先判断A与B两个二叉树不为空(题目说:约定空树不是任意一个树的子结构)</span><br>        <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || B == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2、然后判断A的根节点与B的根节点是否相同</span><br>        <span class="hljs-comment">//    2.1、A的根节点与B的根节点相同，那么依次比较他们的子节点</span><br>        <span class="hljs-comment">//    2.2、A的根节点与B的根节点不同，那么A的左子树与B的根节点进行比较</span><br>        <span class="hljs-comment">//    2.3、A的根节点与B的根节点不同，那么A的右子树与B的根节点进行比较</span><br>        <span class="hljs-keyword">return</span> isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSub</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>        <span class="hljs-comment">// A 和 B 不匹配的情况有很多，我们需要一开始去找他们完全匹配的情况</span><br>        <span class="hljs-comment">// 即遍历完B，直到为null，说明B的全部节点都和A的子结构匹配上</span><br>        <span class="hljs-keyword">if</span> (B == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// A的节点为空，但B的节点不为空，说明不匹配</span><br>        <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// A和B都不为空，但数值不同，说明不匹配</span><br>        <span class="hljs-keyword">if</span> (A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 此时，当前这个点是匹配的，继续递归判断左子树和右子树是否 [分别匹配]</span><br>        <span class="hljs-keyword">return</span> isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/18/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/image-20220418171021861.png&quot; alt=&quot;树的子结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;p&gt;递归&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>从上到下打印二叉树Ⅲ</title>
    <link href="http://example.com/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/"/>
    <id>http://example.com/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/</id>
    <published>2022-04-17T07:55:49.000Z</published>
    <updated>2022-04-25T02:43:43.075Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/image-20220417155559852.png" alt="从上到下打印二叉树Ⅲ"></p><p>题解：<br>可以借鉴(<a href="http://www.eliseo.top/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/">从上到下打印二叉树Ⅱ - Eliseo的小屋</a>)将已经打印出来的二叉树进行偶数行执行倒序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">// 初始化一个队列和数组</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 定义一个新的数组用来暂时存储每一行的节点</span><br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 遍历节点数的次数，将这一行的节点储存到数组tmp中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                TreeNode node = queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果是偶数，那么就将这个数组倒序</span><br>            <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                Collections.reverse(tmp);<br>            &#125;<br>            <span class="hljs-comment">// 将tmp数组化为res数组的一个元素放入res数组中</span><br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：先进行奇数与偶数层的判断，然后奇数层从队首弹出，偶数层倒着从队尾弹出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">// 初始化一个队列和数组</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 定义一个新的数组用来暂时存储每一行的节点</span><br>            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>            <span class="hljs-comment">// 遍历节点数的次数，将这一行的节点储存到数组tmp中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-keyword">if</span> (res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                    tmp.addLast(node.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (res.size() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>                    tmp.addFirst(node.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将tmp数组化为res数组的一个元素放入res数组中</span><br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/image-20220417155559852.</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>从上到下打印二叉树Ⅱ</title>
    <link href="http://example.com/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/"/>
    <id>http://example.com/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/</id>
    <published>2022-04-17T03:10:37.000Z</published>
    <updated>2022-04-25T02:43:39.926Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/image-20220417111458548.png" alt="从上到下打印二叉树Ⅱ"></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">// 初始化一个队列和数组</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>            queue.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 定义一个新的数组用来暂时存储每一行的节点</span><br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 遍历节点数的次数，将这一行的节点储存到数组tmp中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                TreeNode node = queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将tmp数组化为res数组的一个元素放入res数组中</span><br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/17/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/image-20220417111458548.</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>从上到下打印二叉树</title>
    <link href="http://example.com/2022/04/14/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/04/14/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-04-14T09:34:37.000Z</published>
    <updated>2022-04-25T02:43:35.335Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/14/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220414173504494.png" alt="题目"></p><p><strong>解题思路：</strong></p><p>利用列表和队列，队列进行操作，列表进行节点的数据的存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> * int val;</span><br><span class="hljs-comment"> * TreeNode left;</span><br><span class="hljs-comment"> * TreeNode right;</span><br><span class="hljs-comment"> * TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//初始化队列和列表，队列进行操作，列表存储节点</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(root);<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//当队列不为空时</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 弹出一个节点</span><br>            TreeNode node = queue.poll();<br>            <span class="hljs-comment">// 添加到list中</span><br>            ans.add(node.val);<br>            <span class="hljs-comment">// 如果弹出的结点的左节点不为空那么添加到队列中</span><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-comment">// 如果弹出的结点的右节点不为空那么添加到队列中</span><br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将列表加到数组中</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>            res[i] = ans.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/14/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220414173504494.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="http://example.com/2022/04/14/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://example.com/2022/04/14/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</id>
    <published>2022-04-14T07:28:11.000Z</published>
    <updated>2022-04-25T02:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/14/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/image-20220414152856199.png" alt="题目"></p><p><strong>解题思路：</strong></p><p>遍历字符串，将其放入哈希表，key为这个字母，value为是否重复，如果有重复的进来，就将value置为false，然后遍历一遍字符串(不可以遍历哈希表，因为哈希表是无序的)，找到第一个等于true的即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        HashMap&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : sc) &#123;<br>            <span class="hljs-comment">//如果遇到重复，就会将重复值的value变为false</span><br>            dic.put(c, !dic.containsKey(c));<br>        &#125;<br>        <span class="hljs-comment">//在字典中查找第一个等于true的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : sc) &#123;<br>            <span class="hljs-keyword">if</span> (dic.get(c)) &#123;<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;<br>            <span class="hljs-comment">//否则就是没有不重复的数字</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/14/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/image-202204141</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://example.com/2022/04/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/04/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-14T03:43:59.000Z</published>
    <updated>2022-04-17T03:12:46.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式概述"><a href="#工厂模式概述" class="headerlink" title="工厂模式概述"></a>工厂模式概述</h1><p>工厂模式的主要解决的问题是，将原来分布在各个地方的对象创建过程单独抽离出来，交给工厂类负责创建。其他地方想要使用对象直接找工厂（即调用工厂的方法）获取对象。</p><h1 id="工厂模式的三种类型"><a href="#工厂模式的三种类型" class="headerlink" title="工厂模式的三种类型"></a>工厂模式的三种类型</h1><p>工厂模式主要有三种类型<br>1、简单工厂<br>2、工厂方法<br>3、抽象工厂</p><h2 id="1、简单工厂"><a href="#1、简单工厂" class="headerlink" title="1、简单工厂"></a>1、简单工厂</h2><p>拿泡茶为例，茶叶有好多种类，比如龙井、碧螺春、毛尖等。<br>首先一个ITea接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITea</span> </span>&#123;<br><br>    <span class="hljs-comment">// 沏茶</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeTea</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义两种类型的茶，西湖龙井和碧螺春：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongjingTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITea</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeTea</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;西湖龙井&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiluochunTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITea</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeTea</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;碧螺春&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如其它有一处代码要使用“茶”这个对象沏一壶茶，有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  准备沏一杯茶，根据传入的参数决定不同的茶叶类型</span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ITea <span class="hljs-title">prepareTea</span><span class="hljs-params">(String type)</span></span>&#123;<br>    ITea tea = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;longjing&quot;</span>))&#123;<br>        tea = <span class="hljs-keyword">new</span> LongjingTea();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;biluochun&quot;</span>))&#123;<br>        tea = <span class="hljs-keyword">new</span> BiluochunTea();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tea != <span class="hljs-keyword">null</span>)&#123;<br>        tea.makeTea();<br>    &#125;<br>    <span class="hljs-keyword">return</span> tea;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们可以分析下不使用工厂模式的情况：</p><p>如果我们的工程中不至一处用了类似这段代码逻辑，那增加一种茶叶的类型（比如毛尖）就需要修改多处代码，不利于维护。</p><p>因此，可以考虑，将创建茶叶对象的逻辑抽离出来，单独放到一个类中，这个类便是工厂类（专门生产茶叶的工厂）。这样维护起来便方便很多，客户端代码也无需知道对象创建的具体细节，只需要从工厂类中获取对象即可。</p><p><strong>简单工厂类实现如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeaFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ITea <span class="hljs-title">createTea</span><span class="hljs-params">(String type)</span></span>&#123;<br>        ITea tea = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;longjing&quot;</span>))&#123;<br>            tea = <span class="hljs-keyword">new</span> LongjingTea();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;biluochun&quot;</span>))&#123;<br>            tea = <span class="hljs-keyword">new</span> BiluochunTea();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tea != <span class="hljs-keyword">null</span>)&#123;<br>            tea.makeTea();<br>        &#125;<br>        <span class="hljs-keyword">return</span> tea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码要使用茶对象，需要从工厂中获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    TeaFactory teaFactory = <span class="hljs-keyword">new</span> TeaFactory();<br>    ITea tea = teaFactory.createTea(<span class="hljs-string">&quot;longjing&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p>在上面的简单工厂中，如果要创建的产品类型较多，且各个产品创建的过程不尽相同，则一个工厂类职责会变得越来越多，不符合单一职责原则。<br>另外简单工厂也不符合开闭原则。要新增一种产品需要修改原来的工厂类。</p><p>因此，工厂方法模式中，将生产各种类型的产品的工厂也做了抽象分离。比如，上面例子中的，生产龙井的有专门的龙井工厂，生产碧螺春的有专门的碧螺春工厂。</p><p>看代码，接着上面的实例进行改造。首先创建统一的工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产茶叶的统一接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITeaFactory</span> </span>&#123;<br><br>    <span class="hljs-comment">// 生产茶叶</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ITea <span class="hljs-title">createTea</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后创建两个生产不同类型产品的工厂实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongjingTeaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITeaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ITea <span class="hljs-title">createTea</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LongjingTea();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiluochunTeaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITeaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ITea <span class="hljs-title">createTea</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BiluochunTea();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethodTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ITeaFactory factory = <span class="hljs-keyword">new</span> LongjingTeaFactory();<br>        factory.createTea();<br><br>        factory = <span class="hljs-keyword">new</span> BiluochunTeaFactory();<br>        factory.createTea();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要新增一种茶叶，比如毛尖，只需要新建一个生产毛尖的工厂类实现ITeaFactory即可。可以看到符合开闭原则、单一职责原则。</p><p><strong>工厂方法适用于以下场景：</strong><br>1、创建对象需要大量重复的代码。<br>2、客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。<br>3、一个类通过其子类来指定创建哪个对象。</p><p><strong>工厂方法也有缺点：</strong><br>1、类的个数容易过多，增加复杂度。<br>2、增加了系统的抽象性和理解难度。</p><h2 id="3、抽象工厂"><a href="#3、抽象工厂" class="headerlink" title="3、抽象工厂"></a><strong>3、抽象工厂</strong></h2><p>场景:当我们需要多个产品族，每一个产品族里有一系列产品，这一系列产品一般是不变的，如果经常需要变动，可以使用工厂模式而非抽象工厂</p><p>举例说明下，有两个工厂，美的、格力。这两个工厂都生产两种产品：冰箱和洗衣机。下面使用抽象工厂模式来描述每个工厂的两种产品的创建过程。</p><p>1、首先创建两个产品的接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 冰箱</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFridge</span> </span>&#123;<br>    <span class="hljs-comment">// 冷藏</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">coldStorage</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 洗衣机</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IWasher</span> </span>&#123;<br>    <span class="hljs-comment">// 洗衣服</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wash</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、创建每个工厂的两种产品（总共四种产品）：</p><p>美的的冰箱和洗衣机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeideFridge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFridge</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coldStorage</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;美的冰箱&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeideWasher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWasher</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wash</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;美的洗衣机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>格力的冰箱和洗衣机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeliFridge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFridge</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">coldStorage</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;格力冰箱&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeliWasher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWasher</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wash</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;格力洗衣机&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、创建抽象工厂接口</p><p>家用电器工厂，生产一组产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂接口，家用电器工厂，生产冰箱和洗衣机</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IHouseholdElectricFactory</span> </span>&#123;<br><br>    <span class="hljs-function">IFridge <span class="hljs-title">createFridge</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">IWasher <span class="hljs-title">createWasher</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、创建具体产品等级的工厂</p><p>这里是创建美的和格力的工厂实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeideHouseholdFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHouseholdElectricFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IFridge <span class="hljs-title">createFridge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MeideFridge();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IWasher <span class="hljs-title">createWasher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MeideWasher();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeliHouseholdFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IHouseholdElectricFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IFridge <span class="hljs-title">createFridge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GeliFridge();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IWasher <span class="hljs-title">createWasher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GeliWasher();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、客户端代码使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsFactoryTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        IHouseholdElectricFactory factory = <span class="hljs-keyword">new</span> MeideHouseholdFactory();<br>        factory.createFridge().coldStorage();<br>        factory.createWasher().wash();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工厂模式概述&quot;&gt;&lt;a href=&quot;#工厂模式概述&quot; class=&quot;headerlink&quot; title=&quot;工厂模式概述&quot;&gt;&lt;/a&gt;工厂模式概述&lt;/h1&gt;&lt;p&gt;工厂模式的主要解决的问题是，将原来分布在各个地方的对象创建过程单独抽离出来，交给工厂类负责创建。其他地方想要</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="http://example.com/2022/04/14/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/04/14/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2022-04-14T03:15:36.000Z</published>
    <updated>2022-04-25T02:44:32.124Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/14/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220414112109740.png" alt="题目"></p><p><strong>解题思路：</strong></p><p>虽然不是有序数组，但是可以看作是两个有序数组，因此可以用二分法把数组看作两个有序数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;<br>                <span class="hljs-comment">// 如果中间值小于最右边的值，那么证明是右边是递增加，则最小值肯定不在右边</span><br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;<br>                <span class="hljs-comment">// 如果中间值大于最右边的值，那么证明右边是递增，则最小值在右边</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] == numbers[right]) &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p></blockquote><p>​    0不可以用numbers[mid]和 numbers[left]进行比较，因为不能确定left是否属于第一个递增的数组，比如12345，没有偏转或者说偏转值为0.这个时候left是属于第二个递增的数组的。所以不能比较。而right一定是属于第二个数组的。所以我们用numbers[mid]和 numbers[left]进行比较。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/14/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/image-20220414112109740.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>0~n-1中缺失的数字</title>
    <link href="http://example.com/2022/04/11/0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/04/11/0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-04-11T12:18:05.000Z</published>
    <updated>2022-04-25T02:43:18.022Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/11/0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/image-20220411202654182.png" alt="题目"></p><p><strong>代码实现一：</strong></p><p>二分法，然后按理来说如果不缺值nums[mid] == mid ，但是当缺了一个数字以后，就不会出现nusm[mid] == mid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = len-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span> )/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid)&#123;<br>                <span class="hljs-comment">//如果中间值等于mid，说明缺失的数字在后半部分</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果中间值不等于mid，说明缺失的数字在前半部分</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/11/0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/image-20220411202654182.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>在排序数组中查找数字1</title>
    <link href="http://example.com/2022/04/10/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/"/>
    <id>http://example.com/2022/04/10/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/</id>
    <published>2022-04-10T08:51:57.000Z</published>
    <updated>2022-04-25T02:44:08.151Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/10/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/image-20220410165511221.png" alt="题目"></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 方法一：查找nums数组中和target相等的元素，然后计数器+1</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (target == nums[i])&#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现二：</strong></p><p>由于题目说了是排序数组，所以可以使用<strong>二分法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> firstPosition = findFirtPosition(nums, target);<br>        <span class="hljs-keyword">if</span> (firstPosition == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> lastPosition = findLastPosition(nums, target);<br>        <span class="hljs-keyword">return</span> lastPosition - firstPosition + <span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 查找target第一次出现的位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirtPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                <span class="hljs-comment">// [mid + 1 ... right]</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                <span class="hljs-comment">// [left ... mid]</span><br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[left] == target)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找target最后一次出现的位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLastPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">//将mid赋值给left的时候要向上取整，不然left可能永远小于right，也就永远跳不出循环</span><br>            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                <span class="hljs-comment">// [mid ... right]</span><br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                <span class="hljs-comment">// [left ... mid - 1]</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/10/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971/image-20220410165511221</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="http://example.com/2022/04/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/04/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-04-05T09:02:06.000Z</published>
    <updated>2022-04-25T02:44:23.430Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220405170237877.png" alt="题目"></p><p><strong>思路1：</strong>一看题目 脑子中直接想到了先排序 然后将相邻的数进行比较是否重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历数组</span><br>        <span class="hljs-keyword">while</span>(i &lt; nums.length) &#123;<br>            <span class="hljs-comment">//如果索引与值相等</span><br>            <span class="hljs-keyword">if</span>(nums[i] == i) &#123;<br>            <span class="hljs-comment">//进行下一个</span><br>            i++;<br>            <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//索引与值不相等，看这个值原本应该在的位置对应的值与这个值是否相等</span><br>            <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i]) &#123;<br>                <span class="hljs-comment">//如果相等，就直接返回</span><br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>            <span class="hljs-comment">//如果这个值作为索引对应的值与这个值不相等，就交换这两个数，使得这个值跟索引一致</span><br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            nums[i] = nums[tmp];<br>            nums[tmp] = tmp;<br>        &#125;<br>        <span class="hljs-comment">//没有找到</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/image-20220405170237877.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>左旋转字符串</title>
    <link href="http://example.com/2022/04/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/04/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-04-05T08:00:15.000Z</published>
    <updated>2022-04-25T02:44:18.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220405160431771.png" alt="题目"></p><p><strong>代码实现一：直接拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现二：</strong></p><p><strong>思路：</strong>先将第n+1个到末尾的的字符添加到一个空的字符串，然后将第1个到第n个字符串拼接到字符串后实现左旋转字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        String res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &lt; s.length(); i++)<br>            res += s.charAt(i); <span class="hljs-comment">// charAt(i)表示取出字符串中第i个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            res += s.charAt(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220405160431771.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现一：</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
