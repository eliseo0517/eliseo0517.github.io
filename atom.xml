<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eliseo的小屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-28T13:39:24.646Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mr.Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速排序</title>
    <link href="http://example.com/2022/04/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/04/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2022-04-28T13:35:38.000Z</published>
    <updated>2022-04-28T13:39:24.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>最差情况下时间复杂度为O(N^2)</strong></p><p><strong>时间复杂度最低的快速排序，</strong>在数组中随机找一个数，然后将他与最后一个数字交换，然后以最后一个数字为num进行荷兰国旗问题，同时在小于和大于num的区域随机选取一个数字，然后将他与小于和大于num区域的最后一个数字交换重复执行荷兰国旗问题，最后得到一串从小到大排序的数组，<strong>时间复杂度为O(N*logN)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    quickSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//arr[l...r]排好序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;R)&#123;<br>        swap(arr,L+(<span class="hljs-keyword">int</span>) (Math.random() * (R-L+<span class="hljs-number">1</span>)), R); <span class="hljs-comment">//swap为自带的交换函数；L+(int) (Math.random() * (R-L+1)) 表示在该数组中随机选取一位数字</span><br>        <span class="hljs-keyword">int</span>[] p = partition(arr,L,R);<br>        quitSort(arr,L,p[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>); <span class="hljs-comment">// &lt;区</span><br>        quitSort(arr,p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,R); <span class="hljs-comment">// &gt;区</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//这是一个处理arr[l...r]的函数</span><br><span class="hljs-comment">//默认以arr[r]做划分，arr[r] -&gt; p    &lt;p   ==p    &gt;p</span><br><span class="hljs-comment">//返回等于区域（左边界，右边界），所以返回一个长度为2的数组res，res[0] res[1]</span><br><span class="hljs-keyword">public</span> staic <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)&#123;<br>    <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt;区右边界</span><br>    <span class="hljs-keyword">int</span> more = R; <span class="hljs-comment">// &gt;区左边界</span><br>    <span class="hljs-keyword">while</span>(L &lt; more)&#123; <span class="hljs-comment">// L表示当前数的位置 arr[R] -&gt; 划分值</span><br>        <span class="hljs-keyword">if</span>(arr[L] &lt; arr[R])&#123; <span class="hljs-comment">//当前数  &lt;  划分值</span><br>            swap(arr, ++less, L++);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[L] &gt; arr[R])&#123; <span class="hljs-comment">// 当前值 &gt; 划分值</span><br>            swap(arr, --more, L);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            L++;<br>        &#125;<br>    &#125;<br>    swap(arr,more,R);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;less + <span class="hljs-number">1</span>,more&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最差情况下时间复杂度为O(N^2)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度最低的快速排序</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>扑克牌中的顺子</title>
    <link href="http://example.com/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <id>http://example.com/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</id>
    <published>2022-04-28T08:59:59.000Z</published>
    <updated>2022-04-28T09:08:47.493Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/image-20220428170008577.png" alt="扑克牌中的顺子"></p><p><strong>解法：（排序）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义大小王的数量</span><br>        <span class="hljs-keyword">int</span> jocker = <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<span class="hljs-comment">// 对nums进行排序（可以判断大小王的数量）</span><br>        <span class="hljs-comment">// 为什么i &lt; 4 因为需要判断这个数与后面的数是否重复，i &lt; 4</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                jocker++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[jocker] &lt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/image-20220428170008577.png&quot; alt=&quot;扑克牌中的顺子&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>把数组排成最小的数</title>
    <link href="http://example.com/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://example.com/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</id>
    <published>2022-04-28T08:34:20.000Z</published>
    <updated>2022-04-28T08:35:00.170Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/image-20220428163449786.png" alt="把数组排成最小的数"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/image-20220428163449786.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第k大节点</title>
    <link href="http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-28T08:26:32.000Z</published>
    <updated>2022-04-28T08:31:29.371Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/image-20220428162801246.png" alt="二叉搜索树的第k大节点"></p><p><strong>解法：</strong></p><p>二叉搜索树：右节点大，所以判断第几大的时候就先遍历右节点，然后右节点遍历一次 k–，直到k变成1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-keyword">int</span> res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            res = root.val;<br>        &#125;<br>        k--;<br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/image-20220428162801246</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与双向链表</title>
    <link href="http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-28T07:16:40.000Z</published>
    <updated>2022-04-28T08:20:13.318Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20220428151835975.png" alt="二叉搜索树与双向链表"></p><p><strong>解法：（中序遍历）</strong></p><p><strong>二叉搜索树：</strong>若它的左子树不空，则左子树上所有结点的值均小于它的 根结点 的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为 二叉排序树 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node left;</span><br><span class="hljs-comment">    public Node right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Node pre, head;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        dfs(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span>) pre.right = cur;<br>        <span class="hljs-keyword">else</span> head = cur;<br>        cur.left = pre;<br>        pre = cur;<br>        dfs(cur.right);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20220428151835975.</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中何为某一值的路径</title>
    <link href="http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-04-28T06:32:12.000Z</published>
    <updated>2022-04-28T06:33:29.901Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428143306147.png" alt="二叉树中何为某一值的路径"><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>   <span class="hljs-comment">// list:子树的和</span><br>    <span class="hljs-comment">// res:结果集</span><br>    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        dfs(root, target, sum);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-comment">//等于空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        list.add(root.val);<br>        <span class="hljs-comment">//符合情况,即叶子节点加之前的sum等于target</span><br>        <span class="hljs-keyword">if</span> (sum + root.val == target &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(list));<br>        &#125;<br>        dfs(root.left, target, sum + root.val);<br>        dfs(root.right, target, sum + root.val);<br>        <span class="hljs-comment">// sum -= root.val;</span><br>        <span class="hljs-comment">//清除list</span><br>        list.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/image-</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="http://example.com/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>http://example.com/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2022-04-28T02:45:14.000Z</published>
    <updated>2022-04-28T02:46:14.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220428104546299.png" alt="机器人的运动范围"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 用来判断格子是否已经被走过</span><br>        <span class="hljs-keyword">boolean</span>[][] istrue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n, k, istrue);<br>    &#125;<br><br>    <span class="hljs-comment">// a,b当前位置；</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">boolean</span>[][] istrue)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n<br>                &amp;&amp; (a % <span class="hljs-number">10</span> + a / <span class="hljs-number">10</span> + a / <span class="hljs-number">100</span> + b % <span class="hljs-number">10</span> + b / <span class="hljs-number">10</span> + b / <span class="hljs-number">100</span>) &lt;= k<br>                &amp;&amp; istrue[a][b] == <span class="hljs-keyword">false</span>) &#123;<br>            istrue[a][b] = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// 1是(0,0)位置</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(a + <span class="hljs-number">1</span>, b, m, n, k, istrue)<br>                    + dfs(a - <span class="hljs-number">1</span>, b, m, n, k, istrue)<br>                    + dfs(a, b + <span class="hljs-number">1</span>, m, n, k, istrue)<br>                    + dfs(a, b - <span class="hljs-number">1</span>, m, n, k, istrue);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220428104546299.png&quot; alt=&quot;机器人的运动范围</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>矩阵中的路径</title>
    <link href="http://example.com/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-04-28T02:30:02.000Z</published>
    <updated>2022-04-28T02:31:39.758Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428103103367.png" alt="矩阵中的路径"></p><p><strong>解法：（DFS）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        <span class="hljs-comment">// toCharArray()将字符串转换为字符数组。</span><br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-comment">// 遍历board中的所有元素，将所有元素进行dfs()</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-comment">//如果找到，再返回true</span><br>                <span class="hljs-keyword">if</span> (dfs(board,chars,i,j,<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//数组，单词，长宽，宽度，k：第几个字母</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">char</span>[] chars,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//如果越界或者没找到字母</span><br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span> || m &gt; board.length - <span class="hljs-number">1</span> || n &lt;<span class="hljs-number">0</span> || n &gt; board[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> || board[m][n] != chars[k]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到了字母并且是最后一个</span><br>        <span class="hljs-keyword">if</span> (board[m][n] == chars[k] &amp;&amp; k == chars.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到字母但不是最后一个,就让他看他的上下左右，已经走过的让它变成~以防止再次访问，dfs之后要回退，因为在下一次dfs时候还可能再次访问这个格子</span><br>        <span class="hljs-keyword">char</span> s =  board[m][n] ;<br>        board[m][n] = <span class="hljs-string">&#x27;~&#x27;</span>;<br>        <span class="hljs-keyword">boolean</span> res =  dfs(board,chars,m + <span class="hljs-number">1</span>,n,k + <span class="hljs-number">1</span>) || dfs(board,chars,m,n + <span class="hljs-number">1</span>,k + <span class="hljs-number">1</span>) || dfs(board,chars,m - <span class="hljs-number">1</span>,n,k + <span class="hljs-number">1</span>) || dfs(board,chars,m,n - <span class="hljs-number">1</span>,k + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 四个格子都尝试了之后 恢复到原来的样子</span><br>        board[m][n] = s;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428103103367.png&quot; alt=&quot;矩阵中的路径&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>翻转单词顺序</title>
    <link href="http://example.com/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-04-26T13:47:35.000Z</published>
    <updated>2022-04-26T13:49:36.235Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/image-20220426214848087.png" alt="翻转单词顺序"></p><p><strong>解法：（快慢指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 去掉首位的空格</span><br>        s = s.trim();<br>        <span class="hljs-comment">// 加入两个快慢指针</span><br>        <span class="hljs-keyword">int</span> i = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = s.length() - <span class="hljs-number">1</span>;<br>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 当i不是空格的时候 往左遍历</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            <span class="hljs-comment">// j指向下一个单词</span><br>            j = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/image-20220426214848087.png&quot; alt=&quot;翻转单词顺序&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>和为s的两个数字</title>
    <link href="http://example.com/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</id>
    <published>2022-04-26T08:24:20.000Z</published>
    <updated>2022-04-26T08:29:56.762Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/image-20220426162523495.png" alt="和为s的两个数字"></p><p><strong>解法：（左右指针）</strong></p><p>定义左右指针，左右指针的值的和sum，如果sum&gt;target，那么右指针往左；如果sum&lt;target，那么左指针往右；如果sum== target，那么输出数组[nums[i],nums[j]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> sum = nums[i] + nums[j];<br>            <span class="hljs-keyword">if</span> (sum &lt; target)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;nums[i],nums[j]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/image-20220426162523495.png&quot; alt=&quot;和为s的两个数字&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <link href="http://example.com/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://example.com/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</id>
    <published>2022-04-26T07:57:28.000Z</published>
    <updated>2022-04-26T08:01:33.840Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/image-20220426155826475.png" alt="调整数组顺序使奇数位于偶数前面"></p><p><strong>解法：（左右指针）</strong></p><p>左指针指向偶数的时候，右指针指向奇数的时候就左右指针的值通过一个中间值进行交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tmp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[left] % <span class="hljs-number">2</span>) == <span class="hljs-number">1</span>) left++;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[right] % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) right--;<br>            tmp = nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>两个链表的第一个公共节点</title>
    <link href="http://example.com/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-26T07:30:36.000Z</published>
    <updated>2022-04-26T07:38:25.373Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/image-20220426153130626.png" alt="两个链表的第一个公共节点"></p><p><strong>解法：（双指针）</strong></p><p>假设链表headA有a个节点，链表headB有b个节点，公共节点距离链表尾部有c个节点；</p><p>那么链表headA从开始到公共节点有a-c个节点，链表headB从开始到公告节点有b-c个节点，</p><p>当链表headA的指针A遍历完链表headA之后遍历链表headB，当走到公共节点的时候一共走了a-c+c+b-c = a+b-c步数</p><p>当链表headB的指针B遍历完链表headB之后遍历链表headA，当走到公共节点的时候一共走了b-c+c+a-c = b+a-c步数</p><p>此时</p><p>1、A与B重合若两链表 有公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node</p><p>2、若两链表 无 公共尾部 (即 c = 0 ) ：指针 A，B 同时指向 null 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        ListNode A = headA;<br>        ListNode B = headB;<br>        <span class="hljs-keyword">while</span> (A != B) &#123;<br>            A = A != <span class="hljs-keyword">null</span> ? A.next : headB;<br>            B = B != <span class="hljs-keyword">null</span> ? B.next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/image-</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="http://example.com/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-26T06:52:38.000Z</published>
    <updated>2022-04-26T06:55:22.984Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220426145316487.png" alt="合并两个排序的链表"></p><p><strong>解法一：（双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br><br>    ListNode(<span class="hljs-keyword">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义一个伪节点</span><br>        ListNode a = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode cur = a;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = (l1 != <span class="hljs-keyword">null</span> ? l1 : l2);<br>        <span class="hljs-keyword">return</span> a.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（递归）</strong></p><p>一个一个节点的判断，l1的头节点与l2的头节点进行比较，然后节点往下判断下一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br><br>    ListNode(<span class="hljs-keyword">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220426145316487.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数第k个节点</title>
    <link href="http://example.com/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-25T14:32:21.000Z</published>
    <updated>2022-04-25T14:33:27.067Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220425223235483.png" alt="链表中倒数第k个节点"></p><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br><br>        <span class="hljs-comment">// 先让快的走k个距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 当快的走到了最后的时候，慢的链表就是所要求的链表</span><br>        <span class="hljs-keyword">while</span> (fast!=<span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220425223235483.png&quot; alt</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的节点</title>
    <link href="http://example.com/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-25T13:37:58.000Z</published>
    <updated>2022-04-25T13:45:44.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/image-20220425213903008.png" alt="删除链表的节点"></p><p><strong>解法一：（双节点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<br>        ListNode pre = head;<br>        ListNode cur = head.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span> &amp;&amp; cur.val != val) &#123;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//证明找到了要删除的节点,跳过这个要删除的节点</span><br>            pre.next = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（递归）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            <span class="hljs-comment">// 如果发现你的这个节点的值就是所要求的值，那么直接跳过这个节点</span><br>            head = head.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则自调</span><br>            head.next = deleteNode(head.next, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/image-20220425213903008.png&quot; alt=&quot;删除链表的节点&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <link href="http://example.com/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-04-25T08:18:12.000Z</published>
    <updated>2022-04-25T08:21:39.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425161854980.png" alt="最长不含重复字符的子字符串"></p><p><strong>解法一：</strong>（哈希表+动态规划）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// res结果 tmp当前长度</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>            <span class="hljs-comment">//找到j左边最近的与j位置字母相等的字母</span><br>            <span class="hljs-keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//找到的话就将这个字母置于j位置，没找到的话j位置置为-1</span><br>            dic.put(s.charAt(j), j);<br>            <span class="hljs-keyword">if</span> (tmp &lt; j - i) &#123;<br>                <span class="hljs-comment">//如果tmp &lt; j - i，就证明，没有遇到相同的字母，长度+1</span><br>                tmp = tmp + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//否则就是遇到了相等的字母，则左边界就应该由i来决定</span><br>                tmp = j - i;<br>            &#125;<br>            res = Math.max(res, tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓展：</p><div class="note note-success">            <p>哈希表的getOrDefault(key, default)方法，是在哈希表中搜索是否存在该方法参数列表中的key值，如果存在该key值，则返回哈希表中该key值对应的vakue值；如果不存在，则返回该方法参数列表中的default值</p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>把数字翻译成字符串</title>
    <link href="http://example.com/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-04-25T07:37:45.000Z</published>
    <updated>2022-04-25T07:39:49.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425153822764.png" alt="把数字翻译成字符串"></p><p><strong>解法：</strong></p><p>看见题就能想到要不两个数字作为一个字符输出，要不一个数字作为一个字符输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">// 把数字变成string类型</span><br>        String s = String.valueOf(num);<br>        <span class="hljs-comment">// 如果不+1，如果我给的num长度为3，那么转换成string类型长度也为3</span><br>        <span class="hljs-comment">// 到了for循环的时候从2开始就拿不到2个就出现越界问题</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 当num第1,2位的组成的数字∈[10,25]时，显然应有2种翻译方法，</span><br>        <span class="hljs-comment">// 即dp[2]=dp[1]+dp[0]=2，而显然dp[1] = 1因此推出dp[0] = 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-comment">// 取出两位</span><br>            <span class="hljs-comment">// substring这个方法截取的字符串从i-2开始，到字符串索引的i - 1结束</span><br>            String tmp = s.substring(i - <span class="hljs-number">2</span>, i);<br>            <span class="hljs-comment">// 如果两位数的ASCII码差值在10~25之间 证明可以转换成为一个字符</span><br>            <span class="hljs-keyword">if</span> (tmp.compareTo(<span class="hljs-string">&quot;10&quot;</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp.compareTo(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 一位计算</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425153822764.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>礼物的最大价值</title>
    <link href="http://example.com/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <id>http://example.com/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</id>
    <published>2022-04-25T02:42:24.000Z</published>
    <updated>2022-04-25T02:50:55.069Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220425104246376.png" alt="礼物的最大价值"></p><p><strong>解法一：</strong></p><p>暴力递归，对于一个格子只有两种情况：不是向下移动就是向右移动，所以定义两个变量，一个 == 向右移动的值 一个 == 向下移动的值 ，然后取max + 这个格子左上角的值</p><p>代码 <em>略</em></p><p><strong>解法二：</strong></p><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test14</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义行和列</span><br>        <span class="hljs-keyword">int</span> row = grid.length;<br>        <span class="hljs-keyword">int</span> column = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 多加一行一列 所以dp[1][0..column]相当于grid[0][0...column]</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row + <span class="hljs-number">1</span>][column + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[1][0..column]相当于grid[0][0...column] 所以i与j从1开始 直到 等于行与列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= column; j++) &#123;<br>                dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row][column];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] grid = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        System.out.println(maxValue(grid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220425104246376.png&quot; alt=&quot;礼物的最大价值&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>mysql8通过Data文件恢复数据</title>
    <link href="http://example.com/2022/04/21/mysql8%E9%80%9A%E8%BF%87Data%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2022/04/21/mysql8%E9%80%9A%E8%BF%87Data%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</id>
    <published>2022-04-21T15:30:51.000Z</published>
    <updated>2022-04-21T15:34:13.276Z</updated>
    
    <content type="html"><![CDATA[<p>原因：数据库突然开不开了，怕麻烦就没有备份数据库，只留下了Data文件，结果新版本mysql不能使用旧版本的data，单纯的替换ibdata1文件也不行。</p><p><strong>操作：</strong></p><p>1、打开任务管理器，关闭MySQL80.exe</p><p>2、需要覆盖的文件：ibdata1，ib_logfile0，ib_logfile1，ib_buffer_pool，auto.cnf，mysql.ibd</p><p>3、重新打开MySQL80.exe</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原因：数据库突然开不开了，怕麻烦就没有备份数据库，只留下了Data文件，结果新版本mysql不能使用旧版本的data，单纯的替换ibdata1文件也不行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、打开任务管理器，关闭MySQL80.exe&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-04-21T13:30:29.000Z</published>
    <updated>2022-04-24T11:58:20.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h1><p>动态规划：如果你发现你有重复调用的过程动态规划再算过一次之后把答案记下来，下一次再遇到重复过程直接调这个行为就叫动态规划（空间换时间）</p><p>暴力递归 –&gt;傻缓存–&gt;动态规划</p><p>最简单的例子：斐波那契数列</p><h1 id="机器人走路问题"><a href="#机器人走路问题" class="headerlink" title="机器人走路问题"></a>机器人走路问题</h1><div class="note note-primary">            <p><strong>题目：</strong></p><p>假设有拍成一行的N个位置记为1到N，N一定大于等于2；</p><p>开始时机器人在其中的M位置上（M一定是1到N中的一个）；</p><p>如果机器人来到1位置那么下一步只能往右来到2位置；</p><p>如果机器人来到N位置那么下一步只能往左来到N-1位置；</p><p>规定机器人一定要走K步，最终能来到P位置（P也是1~N中的一个）的方法有多少种；</p><p>给定四个桉树N，M，K，P，返回方法数</p>          </div><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_RobotWalk</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> process1(start, K, aim, N);<br>    &#125;<br><br>    <span class="hljs-comment">// 机器人当前来到的位置是cur</span><br>    <span class="hljs-comment">// 机器人还有rest步需要走</span><br>    <span class="hljs-comment">// 最终要去的地方是aim</span><br>    <span class="hljs-comment">// 有哪些位置？1~N</span><br>    <span class="hljs-comment">// 返回值：机器人从cur开始走，走过rest部署之后最后停在aim地方的方法数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果已经不需要走了，那就是走完了所有的rest步数</span><br>            <span class="hljs-keyword">return</span> cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// rest &gt; 0 还有步数需要走</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果机器人在1那么只能走向2的位置 1-&gt;2</span><br>            <span class="hljs-comment">// 如果我机器人在1那么他只能去2，也就是说 机器人从1走rest步数到aim相当于机器人从2位置走rest-1部署走到aim</span><br>            <span class="hljs-keyword">return</span> process1(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>        &#125;<br>        <span class="hljs-comment">// 同理对于机器人在N位置也是只能走向N-1位置</span><br>        <span class="hljs-keyword">if</span> (cur == N) &#123; <span class="hljs-comment">// N-&gt;N-1</span><br>            <span class="hljs-keyword">return</span> process1(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>        &#125;<br>        <span class="hljs-comment">// 机器人在除了1和N的其他位置上</span><br>        <span class="hljs-keyword">return</span> process1(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N) + process1(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(ways1(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法2：（对解法1进行优化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_RobotWalk</span> </span>&#123;<br><span class="hljs-comment">// 优化：因为ways1会存在计算同一个位置与步数的情况,因为会有重复过程</span><br>    <span class="hljs-comment">// dp作为一个缓存，就是一个如果你没计算过这个位置与步数的信息那么就是-1，然后去计算</span><br>    <span class="hljs-comment">// 如果已经计算过了，那么就是你将你计算的值付给dp[cur][rest]然后下次需要的时候就直接拿上用，避免重复计算</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= K; j++) &#123;<br>                dp[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp就是缓存表</span><br>        <span class="hljs-comment">// dp[cur][rest] == -1   -&gt;   process1(cur, rest) 之前没算过！</span><br>        <span class="hljs-comment">// dp[cur][rest] != -1   -&gt;   process1(cur, rest) 之前算过！返回值，dp[cur][rest]</span><br>        <span class="hljs-comment">// K+1 * N+1 的二维数组 保证任何一组参数组合都能放到这个二维数组内部</span><br>        <span class="hljs-keyword">return</span> process2(start, K, aim, N, dp);<br>    &#125;<br><br>    <span class="hljs-comment">// cur范围： 1~N</span><br>    <span class="hljs-comment">// rest范围： 0~K</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> rest, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[][] dp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dp[cur][rest] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> dp[cur][rest];<br>        &#125;<br>        <span class="hljs-comment">// 之前没算过</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans = cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>            ans = process2(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == N) &#123;<br>            ans = process2(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = process2(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp) + process2(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>        &#125;<br>        <span class="hljs-comment">// 相当于只算了一次在一个位置同一个步数的情况</span><br>        dp[cur][rest] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(ways2(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法三：（最终优化）</strong></p><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220421215607265.png" alt="image-20220421215607265"></p><p>由此可以对问题进行最终的优化：第0列除了dp[ aim] [ 0] =1其余都是0，第一行与第N行进行手动赋值，其余的都是等于上一行的前一个与下一行的前一个之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code1_RobotWalk</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 画一个二维数组</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ways3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][K + <span class="hljs-number">1</span>];<br>        dp[aim][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// dp[...][0] = 0; java中自动就是0</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= K; rest++) &#123;<br>            <span class="hljs-comment">// 第一行手动赋值</span><br>            dp[<span class="hljs-number">1</span>][rest] = dp[<span class="hljs-number">2</span>][rest - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cur = <span class="hljs-number">2</span>; cur &lt; N; cur++) &#123;<br>                dp[cur][rest] = dp[cur - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>] + dp[cur + <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 最后一行手动赋值</span><br>            dp[N][rest] = dp[N - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[start][K];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(ways3(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="扑克牌问题"><a href="#扑克牌问题" class="headerlink" title="扑克牌问题"></a>扑克牌问题</h1><div class="note note-primary">            <p><strong>题目</strong></p><p>给定一个整型数组arr（数组内的数都是正数），代表数值不同的指派排成一条线</p><p>玩家A和玩家B依次拿走每张纸牌</p><p>规定玩家A先拿，玩家B后拿</p><p>但是每个玩家每次只能拿走最左或最右的纸牌</p><p>玩家A和玩家B都聪明绝顶</p><p>请返回最后获胜者的分数</p>          </div><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_CardsinLine</span> </span>&#123;<br><br>    <span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">win1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> first = f(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> second = g(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(first, second);<br>    &#125;<br><br>    <span class="hljs-comment">// 先手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，先手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span> arr[L];<br>        &#125;<br>        <span class="hljs-comment">// 1：我拿走左侧的牌，然后我在L+1到R上获得的最好的牌</span><br>        <span class="hljs-keyword">int</span> p1 = arr[L] + g(arr, L + <span class="hljs-number">1</span>, R);<br>        <span class="hljs-comment">// 2：我拿走左侧的牌，然后我在L到R-1上获得的最好的牌</span><br>        <span class="hljs-keyword">int</span> p2 = arr[R] + g(arr, L, R - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> Math.max(p1, p2);<br>    &#125;<br><br>    <span class="hljs-comment">// 后手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，后手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> p1 = f(arr, L + <span class="hljs-number">1</span>, R); <span class="hljs-comment">// 对手拿走了L位置的牌</span><br>        <span class="hljs-keyword">int</span> p2 = f(arr, L, R - <span class="hljs-number">1</span>); <span class="hljs-comment">// 对手拿走了R位置的牌</span><br><br>        <span class="hljs-keyword">return</span> Math.min(p1, p2);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win1(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法2：（对解法1进行优化）</strong></p><div class="note note-success">            <p>定义两个二维数组，将计算之后的数值加到数值里面，防止重复计算</p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423205953240.png" alt="image-20220423205953240"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_CardsinLine</span> </span>&#123;<br><br>    <span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-comment">// 加一个缓存（因为win1存在重复计算某一个数的情况）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">win2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加两个缓存表</span><br>        <span class="hljs-keyword">int</span> N = arr.length;<br>        <span class="hljs-keyword">int</span>[][] fmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-keyword">int</span>[][] gmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-comment">// 如果ij在函数f2函数没有被计算过，那么就是-1 计算过就是对应的值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>                fmap[i][j] = -<span class="hljs-number">1</span>;<br>                gmap[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">int</span> first = f2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, fmap, gmap);<br>        <span class="hljs-keyword">int</span> second = g2(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, fmap, gmap);<br>        <span class="hljs-keyword">return</span> Math.max(first, second);<br>    &#125;<br><br>    <span class="hljs-comment">// 先手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，先手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span>[][] fmap, <span class="hljs-keyword">int</span>[][] gmap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (fmap[L][R] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> fmap[L][R];<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            ans = arr[L];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 1：我拿走左侧的牌，然后我在L+1到R上获得的最好的牌</span><br>            <span class="hljs-keyword">int</span> p1 = arr[L] + g2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap);<br>            <span class="hljs-comment">// 2：我拿走左侧的牌，然后我在L到R-1上获得的最好的牌</span><br>            <span class="hljs-keyword">int</span> p2 = arr[R] + g2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap);<br>            ans = Math.max(p1, p2);<br>        &#125;<br>        fmap[L][R] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 后手者的方法</span><br>    <span class="hljs-comment">// 在arr[L..R]数组中，后手获得的最好的分数返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">g2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span>[][] fmap, <span class="hljs-keyword">int</span>[][] gmap)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (gmap[L][R] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> gmap[L][R];<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            ans = arr[L];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> p1 = f2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap); <span class="hljs-comment">// 对手拿走了L位置的牌</span><br>            <span class="hljs-keyword">int</span> p2 = f2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap); <span class="hljs-comment">// 对手拿走了R位置的牌</span><br>            ans = Math.min(p1, p2);<br>        &#125;<br>        gmap[L][R] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win2(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法三：（最终优化）</strong></p><div class="note note-success">            <p>由于数值arr一定是<strong>L&gt;R</strong>，因此只有数组的一半是存在定义的</p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423210149765.png" alt="image-20220423210149765"></p><div class="note note-success">            <p>由解法一可以得出来，表f与表g有关系，并且f表对应到g表之后与对应位置的左边与下边有关联，也就是<strong>g(0)(1) = f(0)(0)+f(1)(1)</strong></p>          </div><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220423210949953.png" alt="image-20220423210949953"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code2_CardsinLine</span> </span>&#123;<br>    <br><span class="hljs-comment">// 根据规则，返回获胜者的分数</span><br>    <span class="hljs-comment">// 加一个缓存（因为win1存在重复计算某一个数的情况）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">win3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加两个缓存表</span><br>        <span class="hljs-keyword">int</span> N = arr.length;<br>        <span class="hljs-keyword">int</span>[][] fmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-keyword">int</span>[][] gmap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            fmap[i][i] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">// 描述 按照对角线将两个二维数组互推</span><br>        <span class="hljs-comment">// startCol == 对角线的开始列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> startCol = <span class="hljs-number">1</span>; startCol &lt; N; startCol++) &#123;<br>            <span class="hljs-comment">// row 对角线的开始行</span><br>            <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> R = startCol;<br>            <span class="hljs-comment">// 发现相对于行 列比行先越界</span><br>            <span class="hljs-keyword">while</span> (R &lt; N) &#123;<br>                fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="hljs-number">1</span>][R], arr[R] + gmap[L][R - <span class="hljs-number">1</span>]);<br>                gmap[L][R] = Math.min(fmap[L + <span class="hljs-number">1</span>][R], fmap[L][R - <span class="hljs-number">1</span>]);<br>                <span class="hljs-comment">// 实现对角线往下爬 且不能越界</span><br>                L++;<br>                R++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(fmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>], gmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(win3(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">32</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><div class="note note-primary">            <p><strong>有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p>          </div><p><strong>解法一：</strong></p><div class="note note-success">            <p>对于一个货物只有p1（选择这个货物），p2（不选择这个货物）两个决策，当你不选择了这个货物那么就将index++往下对下一个货物进行决策；如果选择这个货物那么就对选择了货物之后背包的重量进行判断是否&gt;0,&gt;0就选择当前货物，否则不选</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code3_Knapsack</span> </span>&#123;<br><br>    <span class="hljs-comment">// 所有的货，重量和价值都在w和v数组中</span><br>    <span class="hljs-comment">// 为了方便，其中没有复数</span><br>    <span class="hljs-comment">// bag背包容量，不能超过这个数</span><br>    <span class="hljs-comment">// 返回：不超过背包容量的情况下，能够得到的最大价值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span> || w.length != v.length || w.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 尝试函数！</span><br>        <span class="hljs-keyword">return</span> process(w, v, <span class="hljs-number">0</span>, bag);<br>    &#125;<br><br>    <span class="hljs-comment">// 当前考虑到了index号货物，index....所有的货物都可以自由选择</span><br>    <span class="hljs-comment">// 做的选择不能超过背包容量</span><br>    <span class="hljs-comment">// 返回最大价值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (bag &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 为什么不写bag = 0 ：因为 万一存在货物 重量为0但是存在价值</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == w.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 有货物，index位置的货</span><br>        <span class="hljs-comment">// bag有空间</span><br>        <span class="hljs-comment">// 不要当前的货物</span><br>        <span class="hljs-keyword">int</span> p1 = process(w, v, index + <span class="hljs-number">1</span>, bag);<br>        <span class="hljs-comment">// 要当前的货物</span><br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用来判断</span><br>        <span class="hljs-keyword">int</span> next = process(w, v, index + <span class="hljs-number">1</span>, bag - w[index]);<br>        <span class="hljs-keyword">if</span> (next != -<span class="hljs-number">1</span>) &#123;<br>            p2 = v[index] + next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(p1, p2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] weights = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] values = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">19</span>&#125;;<br>        <span class="hljs-keyword">int</span> bag = <span class="hljs-number">11</span>;<br>        System.out.println(maxValue(weights,values,bag));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">25</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解法二：（对解法一进行优化）</strong></p><p><img src="/2022/04/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220424172800335.png" alt="image-20220424172800335"></p><p>通过代码<strong>if (index == w.length) {return 0;}</strong> 可以得出二位数组的最后一行都为0，通过 <strong>int p1 = process(w, v, index + 1, bag); int next = process(w, v, index + 1, bag - w[index]);</strong> 可以得出我们需要知道一个格子的值只要知道下一行的值我们就可以得到这个格子的值；因此我们可以从最后一行开始入手得到倒数第二行…..直到第一行，同一行不存在依赖关系，所以从左往右写 或者从左往右写都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code3_Knapsack</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span> bag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span> || w.length != v.length || w.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> N = w.length;<br>        <span class="hljs-comment">// index 0</span><br>        <span class="hljs-comment">// rest 0~bag</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][bag + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[N][...] = 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= bag; rest++) &#123;<br>                <span class="hljs-keyword">int</span> p1 = dp[index + <span class="hljs-number">1</span>][rest];<br>                <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">int</span> next = rest - w[index] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : dp[index + <span class="hljs-number">1</span>][rest - w[index]];<br>                <span class="hljs-keyword">if</span> (next != -<span class="hljs-number">1</span>) &#123;<br>                    p2 = v[index] + next;<br>                &#125;<br>                dp[index][rest] = Math.max(p1, p2);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][bag];<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] weights = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] values = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">19</span>&#125;;<br>        <span class="hljs-keyword">int</span> bag = <span class="hljs-number">11</span>;<br>        System.out.println(maxValue(weights,values,bag));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">25</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是动态规划？&quot;&gt;&lt;a href=&quot;#什么是动态规划？&quot; class=&quot;headerlink&quot; title=&quot;什么是动态规划？&quot;&gt;&lt;/a&gt;什么是动态规划？&lt;/h1&gt;&lt;p&gt;动态规划：如果你发现你有重复调用的过程动态规划再算过一次之后把答案记下来，下一次再遇到重复过</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
