<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eliseo的小屋</title>
  
  
  <link href="https://eliseo.top/atom.xml" rel="self"/>
  
  <link href="https://eliseo.top/"/>
  <updated>2022-08-09T10:37:50.571Z</updated>
  <id>https://eliseo.top/</id>
  
  <author>
    <name>Mr.Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目总结</title>
    <link href="https://eliseo.top/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://eliseo.top/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-06T01:24:29.000Z</published>
    <updated>2022-08-09T10:37:50.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h1><p>实现一个B2C模式的在线教育平台，拥有前台用户系统与后台运营。</p><p>要实现的功能：除了一些基础的功能以外，还要实现微信支付 微信登录 ，对于图片的存储采用了阿里云的oss，对于视频的存储以及播放 使用了阿里云点播，登录模块的发送验证码则是使用了阿里云的阿里云短信给手机发送一个短信验证码。</p><h1 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h1><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806202156218.png" alt="数据库的一些基本信息"></p><h1 id="三、项目基本结构"><a href="#三、项目基本结构" class="headerlink" title="三、项目基本结构"></a>三、项目基本结构</h1><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806205502916.png" alt="项目结构"></p><p><strong>guli-parent：在线教学根目录（父工程），管理四个子模块：</strong></p><ul><li><p><strong>canal-client：canal数据库表同步模块（统计同步数据）</strong></p></li><li><p><strong>common：公共模块父节点</strong></p><ul><li>common-util：工具类模块，所有模块都可以依赖于它</li><li>service-base：service服务的base包，包含service服务的公共配置类，所有service模块依赖于它</li><li>spring-security：认证与授权模块，需要认证授权的service服务依赖于它</li></ul></li><li><p><strong>infrastructure：基础服务模块父节点</strong></p><ul><li>api-gateway：api网关服务</li></ul></li><li><p><strong>service：api接口服务父节点</strong></p><ul><li>service-acl：用户权限管理api接口服务（用户管理、角色管理和权限管理等）</li><li>service-cms：cms api接口服务</li><li>service-edu：教学相关api接口服务</li><li>service-msm：短信api接口服务</li><li>service-order：订单相关api接口服务</li><li>service-oss：阿里云oss api接口服务</li><li>service-statistics：统计报表api接口服务</li><li>service-ucenter：会员api接口服务</li><li>service-vod：视频点播api接口服务</li></ul></li></ul><h2 id="3-1、common模块"><a href="#3-1、common模块" class="headerlink" title="3.1、common模块"></a>3.1、common模块</h2><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806205746603.png" alt="common"></p><hr><h3 id="3-1-1、common-utils"><a href="#3-1-1、common-utils" class="headerlink" title="3.1.1、common_utils"></a>3.1.1、common_utils</h3><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220806205905785.png"></p><p><strong>最重要的是R类，是一个用于规范化全后端交互的数据传输的类。</strong>其中要定义处理状态码（前后端自行约定）</p><p>，处理结果（包含错误信息或者成功提示），数据三个条件。</p><p>整合了jwt的令牌的工具类</p><h3 id="3-1-2、service-base"><a href="#3-1-2、service-base" class="headerlink" title="3.1.2、service_base"></a>3.1.2、service_base</h3><p>添加了redis添加缓存的配置类</p><h2 id="3-2、service"><a href="#3-2、service" class="headerlink" title="3.2、service"></a>3.2、service</h2><p>该模块使用了mybatis-plus框架，每一个mapper接口都继承<strong>BaseMapper</strong>类来实现一些mp已经定义好的方法，以此来减少代码量。</p><p>基础框架都是使用mp自动生成代码实现。</p><h3 id="3-2-1、service-edu"><a href="#3-2-1、service-edu" class="headerlink" title="3.2.1、service_edu"></a>3.2.1、service_edu</h3><p>整体上使用@RestController注解用来返回一个json格式的字符串让前端接受，实现前后端交互。</p><p>实现方法：</p><hr><p><strong>后台：</strong></p><ul><li><p>讲师模块</p><ul><li>逻辑删除讲师信息。<ul><li>如何实现逻辑删除？ ——-&gt; 调用mp的按照id进行删除的方法，然后在配置逻辑删除的插件，并且在是否删除的实体类上加入**@TableLogic**注解来实现逻辑删除</li></ul></li><li>讲师分页功能<ul><li>使用了mp的分页插件，实现不带条件的分页功能的时候，使用mp自带的分页功能，没有条件的时候wrapper就为null，然后实现mp的自带的分页功能的方法</li></ul></li><li>条件查询带分页<ul><li>定义了一个用于返回带条件的查询分页的实体类，因为这次是带查询条件，所以定义了wrapper条件构造器，然后在wrapper中创建查询条件，其余与讲师分页功能的代码一致</li></ul></li><li>添加讲师</li><li>根据讲师id进行查询</li><li>修改讲师信息，都是使用了mp自带的功能。</li></ul></li><li><p>课程分类管理</p><ul><li><p>添加课程分类：使用easyexcel来实现从excel文件读取</p></li><li><p>获取课程分类列表：课程拥有一级二级目录</p><ul><li><p>如何实现拥有一级分类二级分类？ ——&gt; </p><ol><li><p>分别创建一级分类二级分类的实体类(一级分类的实体类中包含二级分类的实体类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个一级分类有多个二级分类</span><br><span class="hljs-keyword">private</span> List&lt;TwoSubject&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li><li><p>controller层中调用service接口中的方法</p></li><li><p>创建service对应的方法以及<strong>在实现类中实现这个方法</strong></p><p>思维：一级分类的pid == 0所以在wrapper条件构造器中定义所有pid == 0的就是一级分类；所以 pid != 0 的就是二级分类</p></li></ol></li></ul></li></ul></li><li><p>课程模块</p><ul><li><p>添加课程基本信息(前端用到富文本编辑器)</p><ul><li><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220807161956427.png" alt="课程信息流程"></li><li>1、创建了一个课程信息的实体类</li><li>2、controller层中调用service接口中的方法</li><li>3、完成service接口以及实现类</li></ul></li><li><p>当走到编辑课程大纲的时候，返回上一步的时候需要可以将信息返回，且可以修改信息(也就是所谓的数据回显)</p><ul><li>实现：通过查询id来实现</li><li><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220807234146208.png" alt="数据回显"></li></ul></li><li><p>更新课程信息（修改课程信息）</p><ul><li>使用mp的updateById方法</li></ul></li><li><p>课程列表大纲 </p><ul><li>获得课程列表大纲（和之前的一级分类二级分类代码基本一致） </li><li>新增章节<ul><li>添加小节</li><li>删除小节</li></ul></li><li>通过id查询章节信息</li><li>更新章节信息</li><li>删除章节信息<ul><li>删除章节信息的时候需要注意 如果该章节有小节的时候就会停止删除章节</li></ul></li></ul></li><li><p>课程的课时信息</p><ul><li><p>增加课时</p></li><li><p>根据小节id查询课时</p></li><li><p>修改小节     前三者都是用的是mp的方法</p></li><li><p>删除小节以及对应的阿里云视频</p><ul><li>1、根据小节id获取视频id，调用方法实现视频删除(调用方法的时候使用了nacos远程调用nacos服务中心的方法来实现对视频的删除)</li><li>2、利用nacos服务中心来调用service-vod中已经写好的删除视频的方法</li><li>3、删除小节的时候使用mp的方法</li></ul></li></ul></li><li><p>课程最终发布</p><ul><li>根据id查询课程发布信息，需要通过多张表进行查询（建议使用数据访问层进行关联查询也就是mapper）<ul><li>首先定义一个只有所需信息的实体类vo</li><li>在mapper层定义好方法，然后再mapper.xml中写入对应的sql语句</li><li>在业务层(service)层中写一个接口，实现类中调用mapper层中的方法。</li></ul></li><li>发布课程是需要改变课程的状态status表<ul><li>本质上是一个修改语句 修改状态表即可</li></ul></li></ul></li><li><p>课程列表的显示（分页查询带条件）</p><ul><li>直接在controller层中进行代码的写，利用wrapper条件构造器</li></ul></li><li><p>删除课程</p><ul><li>删除课程中 需要实现 先删除小节 删除章节 在删除课程描述 最后删除课程</li></ul></li></ul></li></ul><hr><p><strong>前台：</strong></p><ul><li>首页展示前八名热门课程以及前四名热门老师</li></ul><h3 id="3-2-2、service-oss"><a href="#3-2-2、service-oss" class="headerlink" title="3.2.2、service_oss"></a>3.2.2、service_oss</h3><p><strong>后台：</strong></p><ul><li><p>用于后台集成oss(阿里云对象存储)</p><ul><li><p>配置oss的application.properties（根据阿里云oss指导文档）</p></li><li><p>当执行的时候会发现会报错，会报没有找到数据库的错误，但是这个部分是不会与数据库进行连接，所以使用<code>@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) </code>来不自动加载数据库</p><p>​    1.创建常量的配置文件，以便于读取数据</p><p>​    2.根据阿里云的oss使用指导，完成Service层的代码</p><p>​    3.在控制层调用</p></li></ul></li></ul><h3 id="3-2-3、service-vod"><a href="#3-2-3、service-vod" class="headerlink" title="3.2.3、service_vod"></a>3.2.3、service_vod</h3><p><strong>后台：</strong></p><ul><li>阿里云视频点播<ul><li>阿里云上传视频</li><li>删除阿里云云端视频</li></ul></li></ul><h3 id="3-2-4、service-cms"><a href="#3-2-4、service-cms" class="headerlink" title="3.2.4、service_cms"></a>3.2.4、service_cms</h3><p><strong>后台：</strong></p><ul><li>后台轮播图的图片管理以及分页查询<ul><li>轮播图(banner)的增删改查，调用mp的增删改查方法，分页查询使用mp.page();</li></ul></li></ul><hr><p><strong>前台：</strong></p><ul><li><p>前台首页轮播图的查询全部 也就是展示轮播图</p><ul><li><p>调用service层的查询所有轮播图的方法</p><ul><li><p>实质是根据id进行查询并且只展示两个轮播图</p></li><li><p>由于首页banner轮播图是经常访问并且不怎么改变的 所以使用redia缓存来进行存储，可以做到减少数据库压力的作用</p><ul><li><p>在banner的properties中添加了redis的相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">192.168.44.132</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment">#最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure></li><li><p>在banner的service的实现类中添加了加入缓存的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(key = &quot;&#x27;selectIndexList&#x27;&quot;,value = &quot;banner&quot;)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="3-2-5、service-msm"><a href="#3-2-5、service-msm" class="headerlink" title="3.2.5、service_msm"></a>3.2.5、service_msm</h3><ul><li><p>短信微服务</p><ul><li><p>运用了阿里云短信服务</p><ul><li><p>引入pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/edumsm/msm&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsmController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsmService msmService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;<br><br>    <span class="hljs-comment">// 发送短信的方法</span><br>    <span class="hljs-meta">@GetMapping(&quot;send/&#123;phone&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">sendMsm</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String phone)</span>&#123;<br><br>        <span class="hljs-comment">//先从redis中获取，如果获取到直接返回</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(phone);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(code))&#123;<br>            System.out.println(code);<br>            <span class="hljs-keyword">return</span> R.ok();<br>        &#125;<br>        <span class="hljs-comment">//如果取不到，进行阿里云发送</span><br><br>        <span class="hljs-comment">//生成随机验证码，传递给阿里云进行发送</span><br>        code = RandomUtil.getFourBitRandom();<br>        Map&lt;String,Object&gt; param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        param.put(<span class="hljs-string">&quot;code&quot;</span>,code);<br>        <span class="hljs-comment">//调用service发送短信</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSend</span> <span class="hljs-operator">=</span> msmService.send(param,phone);<br>        <span class="hljs-keyword">if</span> (isSend)&#123;<br>            <span class="hljs-comment">//发送成功，将发送成功的验证码放到redis里面</span><br>            redisTemplate.opsForValue().set(phone,code,<span class="hljs-number">5</span>, TimeUnit.MINUTES);<br>            <span class="hljs-comment">//设置有效时间</span><br>            <span class="hljs-keyword">return</span> R.ok();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> R.error().message(<span class="hljs-string">&quot;短信发送失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsmServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MsmService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送短信</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String PhoneNumbers, String templateCode, Map&lt;String,Object&gt; param)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(PhoneNumbers)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">DefaultProfile</span> <span class="hljs-variable">profile</span> <span class="hljs-operator">=</span><br>                DefaultProfile.getProfile(<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;LTAIq6nIPY09VROj&quot;</span>, <span class="hljs-string">&quot;FQ7UcixT9wEqMv9F35nORPqKr8XkTF&quot;</span>);<br>        <span class="hljs-type">IAcsClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultAcsClient</span>(profile);<br><br>        <span class="hljs-type">CommonRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonRequest</span>();<br>        <span class="hljs-comment">//request.setProtocol(ProtocolType.HTTPS);</span><br>        request.setMethod(MethodType.POST);<br>        request.setDomain(<span class="hljs-string">&quot;dysmsapi.aliyuncs.com&quot;</span>);<br>        request.setVersion(<span class="hljs-string">&quot;2017-05-25&quot;</span>);<br>        request.setAction(<span class="hljs-string">&quot;SendSms&quot;</span>);<br><br>        request.putQueryParameter(<span class="hljs-string">&quot;PhoneNumbers&quot;</span>, PhoneNumbers);<br>        request.putQueryParameter(<span class="hljs-string">&quot;SignName&quot;</span>, <span class="hljs-string">&quot;我的谷粒在线教育网站&quot;</span>);<br>        request.putQueryParameter(<span class="hljs-string">&quot;TemplateCode&quot;</span>, templateCode);<br>        request.putQueryParameter(<span class="hljs-string">&quot;TemplateParam&quot;</span>, JSONObject.toJSONString(param));<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">CommonResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.getCommonResponse(request);<br>            System.out.println(response.getData());<br>            <span class="hljs-keyword">return</span> response.getHttpResponse().isSuccess();<br>        &#125; <span class="hljs-keyword">catch</span> (ServerException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClientException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="3-2-6、service-ucenter"><a href="#3-2-6、service-ucenter" class="headerlink" title="3.2.6、service_ucenter"></a>3.2.6、service_ucenter</h3><ul><li>前台登录模块<ul><li>登录功能<ul><li>在controller层中调用service层的登录login方法</li><li>service层的实现类中写login方法的实现<ul><li>其中运用了wrapper条件构造器对手机号以及密码进行非空的判断，判断手机号是否正确，手机号是否存在以及判断密码是否正确，但是判断密码的时候需要使用MD5进行判断，因为数据库不会存密码 而是会存入MD5加密之后的密码</li><li>当用户登录成功之后会利用之前common_utils之中jwt工具类的getJwtToken方法将你的登录信息变成token存储实现单点登录。</li></ul></li></ul></li><li>注册功能<ul><li>controller层中调用service层的注册register方法</li><li>service层中实现register方法<ul><li>注册的时候需要判断账号密码验证码以及昵称是否为空，判断验证码与redis中的验证码是否一样以及手机号是否重复，最后将用户信息写进数据库中。</li></ul></li></ul></li><li>根据token获取用户信息<ul><li>用处：为了前台的前端的右上角展示你自己的头像以及姓名    </li><li>实现：调用jwt的方法来获得request中的用户id，然后根据这个id在数据库中查询数据</li></ul></li></ul></li></ul><h1 id="四、新增技术"><a href="#四、新增技术" class="headerlink" title="四、新增技术"></a>四、新增技术</h1><h2 id="4-1、跨域"><a href="#4-1、跨域" class="headerlink" title="4.1、跨域"></a>4.1、跨域</h2><p>跨域问题的解决方法：加入**@CrossOrigin**注解。</p><h2 id="4-2、Swagger"><a href="#4-2、Swagger" class="headerlink" title="4.2、Swagger"></a>4.2、Swagger</h2><p>一个可以迅速帮我们编写一个可视化的api接口文档，使用时需要添加一些注解以及配文件。</p><p>由于是项目所有模块都要使用的东西，所以一般配置在一个common模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">webApiConfig</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;webApi&quot;</span>)<br>                .apiInfo(webApiInfo())<br>                .select()<br>                .paths(Predicates.not(PathSelectors.regex(<span class="hljs-string">&quot;/admin/.*&quot;</span>)))<br>                .paths(Predicates.not(PathSelectors.regex(<span class="hljs-string">&quot;/error.*&quot;</span>)))<br>                .build();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">webApiInfo</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;网站-课程中心API文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;本文档描述了课程中心微服务接口定义&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;Helen&quot;</span>, <span class="hljs-string">&quot;http://atguigu.com&quot;</span>, <span class="hljs-string">&quot;55317332@qq.com&quot;</span>))<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后再在其他要使用swagger的模块中写入swagger的相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>service-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-3、OSS"><a href="#4-3、OSS" class="headerlink" title="4.3、OSS"></a>4.3、OSS</h2><p>使用阿里云的OSS来存储头像。</p><p><strong>如何使用：</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 阿里云oss依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 日期工具栏依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>joda-time<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>joda-time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#服务端口</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8002</span><br><span class="hljs-comment">#服务名</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">service-oss</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#环境设置：dev、test、prod</span><br><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">dev</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">#阿里云 OSS</span><br><span class="hljs-comment">#不同的服务器，地址不同</span><br><span class="hljs-attr">aliyun.oss.file.endpoint</span>=<span class="hljs-string">your endpoint</span><br><span class="hljs-attr">aliyun.oss.file.keyid</span>=<span class="hljs-string">your accessKeyId</span><br><span class="hljs-attr">aliyun.oss.file.keysecret</span>=<span class="hljs-string">your accessKeySecret</span><br><span class="hljs-comment">#bucket可以在控制台创建，也可以使用java代码创建</span><br><span class="hljs-attr">aliyun.oss.file.bucketname</span>=<span class="hljs-string">guli-file</span><br></code></pre></td></tr></table></figure></li><li><p>写一个配置类用于拿到所需要的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 常量类，读取配置文件application.properties中的配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-comment">//@PropertySource(&quot;classpath:application.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantPropertiesUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String endpoint;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String keyId;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String keySecret;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.filehost&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String fileHost;<br><br><span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String bucketName;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String END_POINT;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String ACCESS_KEY_ID;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String ACCESS_KEY_SECRET;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String BUCKET_NAME;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String FILE_HOST ;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>END_POINT = endpoint;<br>ACCESS_KEY_ID = keyId;<br>ACCESS_KEY_SECRET = keySecret;<br>BUCKET_NAME = bucketName;<br>FILE_HOST = fileHost;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过io流来上传文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileService</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span> &#123;<br><br><span class="hljs-comment">//获取阿里云存储相关常量</span><br><span class="hljs-type">String</span> <span class="hljs-variable">endPoint</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.END_POINT;<br><span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.ACCESS_KEY_ID;<br><span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.ACCESS_KEY_SECRET;<br><span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.BUCKET_NAME;<br><span class="hljs-type">String</span> <span class="hljs-variable">fileHost</span> <span class="hljs-operator">=</span> ConstantPropertiesUtil.FILE_HOST;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">uploadUrl</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//判断oss实例是否存在：如果不存在则创建，如果存在则获取</span><br><span class="hljs-type">OSSClient</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClient</span>(endPoint, accessKeyId, accessKeySecret);<br><span class="hljs-keyword">if</span> (!ossClient.doesBucketExist(bucketName)) &#123;<br><span class="hljs-comment">//创建bucket</span><br>ossClient.createBucket(bucketName);<br><span class="hljs-comment">//设置oss实例的访问权限：公共读</span><br>ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead);<br>&#125;<br><br><span class="hljs-comment">//获取上传文件流</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();<br><br><span class="hljs-comment">//构建日期路径：avatar/2019/02/26/文件名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>().toString(<span class="hljs-string">&quot;yyyy/MM/dd&quot;</span>);<br><br><span class="hljs-comment">//文件名：uuid.扩展名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br><span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><span class="hljs-type">String</span> <span class="hljs-variable">fileType</span> <span class="hljs-operator">=</span> original.substring(original.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> fileName + fileType;<br><span class="hljs-type">String</span> <span class="hljs-variable">fileUrl</span> <span class="hljs-operator">=</span> fileHost + <span class="hljs-string">&quot;/&quot;</span> + filePath + <span class="hljs-string">&quot;/&quot;</span> + newName;<br><br><span class="hljs-comment">//文件上传至阿里云</span><br>ossClient.putObject(bucketName, fileUrl, inputStream);<br><br><span class="hljs-comment">// 关闭OSSClient。</span><br>ossClient.shutdown();<br><br><span class="hljs-comment">//获取url地址</span><br>uploadUrl = <span class="hljs-string">&quot;http://&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endPoint + <span class="hljs-string">&quot;/&quot;</span> + fileUrl;<br><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuliException</span>(ResultCodeEnum.FILE_UPLOAD_ERROR);<br>&#125;<br><br><span class="hljs-keyword">return</span> uploadUrl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-4、EasyExcel导入"><a href="#4-4、EasyExcel导入" class="headerlink" title="4.4、EasyExcel导入"></a>4.4、EasyExcel导入</h2><ul><li><p>读：</p><ul><li><p>1、创建一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadData</span> &#123;<br>    <span class="hljs-comment">//设置列对应的属性</span><br>    <span class="hljs-meta">@ExcelProperty(index = 0)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sid;<br>    <br>    <span class="hljs-comment">//设置列对应的属性</span><br>    <span class="hljs-meta">@ExcelProperty(index = 1)</span><br>    <span class="hljs-keyword">private</span> String sname;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSid</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sid;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSid</span><span class="hljs-params">(<span class="hljs-type">int</span> sid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sid = sid;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSname</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sname;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSname</span><span class="hljs-params">(String sname)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sname = sname;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ReadData&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;sid=&quot;</span> + sid +<br>                <span class="hljs-string">&quot;, sname=&#x27;&quot;</span> + sname + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>2、创建读取操作的监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> com.alibaba.excel.context.AnalysisContext;<br><span class="hljs-keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;<br><span class="hljs-keyword">import</span> com.alibaba.excel.exception.ExcelDataConvertException;<br><span class="hljs-keyword">import</span> com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">//创建读取excel监听器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExcelListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AnalysisEventListener</span>&lt;ReadData&gt; &#123;<br><br>    <span class="hljs-comment">//创建list集合封装最终的数据</span><br>    List&lt;ReadData&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ReadData&gt;();<br><br>    <span class="hljs-comment">//一行一行去读取excle内容</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(ReadData user, AnalysisContext analysisContext)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;***&quot;</span>+user);<br>        list.add(user);<br>    &#125;<br><br>    <span class="hljs-comment">//读取excel表头信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeHeadMap</span><span class="hljs-params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;表头信息：&quot;</span>+headMap);<br>    &#125;<br><br>    <span class="hljs-comment">//读取完成后执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext analysisContext)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3、调用实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 写法1：</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;F:\\01.xlsx&quot;</span>;<br>        <span class="hljs-comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span><br>        EasyExcel.read(fileName, ReadData.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExcelListener</span>()).sheet().doRead();<br><br>        <span class="hljs-comment">// 写法2：</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;F:\\01.xlsx&quot;</span>));<br>        <span class="hljs-type">ExcelReader</span> <span class="hljs-variable">excelReader</span> <span class="hljs-operator">=</span> EasyExcel.read(in, ReadData.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExcelListener</span>()).build();<br>        <span class="hljs-type">ReadSheet</span> <span class="hljs-variable">readSheet</span> <span class="hljs-operator">=</span> EasyExcel.readSheet(<span class="hljs-number">0</span>).build();<br>        excelReader.read(readSheet);<br>        <span class="hljs-comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span><br>        excelReader.finish();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-5、阿里云视频点播"><a href="#4-5、阿里云视频点播" class="headerlink" title="4.5、阿里云视频点播"></a>4.5、阿里云视频点播</h2><h2 id="4-6、nacos服务调用"><a href="#4-6、nacos服务调用" class="headerlink" title="4.6、nacos服务调用"></a>4.6、nacos服务调用</h2><p><strong>注册nacos步骤：</strong></p><p>1、配置nacos 的pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--服务注册--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在application.properties中添加服务配置信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># nacos服务地址</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span><br></code></pre></td></tr></table></figure><p>3、在启动类上加入一个注解 <code>@EnableDiscoveryClient</code></p><p>4、启动nacos</p><p><strong>调用nacos中心的服务：</strong></p><p>1、配置fegin的pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在调用端的启动类加入注解 <code>@EnableFeignClients</code></p><p>3、创建client包，接口和实现类</p><p>@FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。</p><p>@GetMapping注解用于对被调用的微服务进行地址映射。</p><p>@PathVariable注解一定要指定参数名称，否则出错</p><p>@Component注解防止，在其他位置注入CodClient时idea报错</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220808180548031.png"></p><p>从此以后就可以直接调用方法进行使用。</p><p><strong>Hystrix熔断机制：</strong></p><p>1、在properties中添加一个配置信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#开启熔断机制</span><br><span class="hljs-attr">feign.hystrix.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 设置hystrix超时时间，默认1000ms</span><br><span class="hljs-comment"># hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000</span><br></code></pre></td></tr></table></figure><p>在feign的注释上加上一个回调的注释</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220808184025041.png"></p><p>当超过properties配置文件中规定的时间之后就会回调fallback中的函数</p><h2 id="4-7、redis缓存"><a href="#4-7、redis缓存" class="headerlink" title="4.7、redis缓存"></a>4.7、redis缓存</h2><p>首先要清除三个注解：</p><p>1、缓存<code>@Cacheable</code></p><p>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</p><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><p>2、缓存<code>@CachePut</code></p><p>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</p><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><p>3、缓存<code>@CacheEvict</code></p><p>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上</p><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr><tr><td>allEntries</td><td>是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存</td></tr><tr><td>beforeInvocation</td><td>是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存</td></tr></tbody></table><p><strong>操作步骤：</strong></p><p>1、导入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、导入配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">//key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br>        <span class="hljs-comment">//value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>              .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在对应的模块下面的配置文件添加redis的相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">192.168.44.132</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment">#最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><p>4、在实现类上添加注解：  <code>@Cacheable(value = &quot;xxx&quot;, key = &quot;&#39;xxx&#39;&quot;)</code></p><h2 id="4-8、用户登录"><a href="#4-8、用户登录" class="headerlink" title="4.8、用户登录"></a>4.8、用户登录</h2><p>使用oss单点登录，SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809110530617.png"></p><p>用户的单点登录有三个途径：</p><p>​    1、session广播机制</p><p>​    2、使用cookie + redis实现</p><p>​    3、使用token实现(推荐使用)</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809112726252.png" alt="单点登录的三个途径"></p><h3 id="4-8-1、使用JWT进行跨域身份验证"><a href="#4-8-1、使用JWT进行跨域身份验证" class="headerlink" title="4.8.1、使用JWT进行跨域身份验证"></a>4.8.1、使用JWT进行跨域身份验证</h3><p>token就是按照一定规则生成字符串，字符串可以包含用户信息</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809113508132.png"></p><p>1.在项目某个模块进行登录，登录之后，按照规则生成字符串，把登陆之后用户包含到生成字符串里面，把字符串返回</p><p>(1)可以把字符串通过cookie返回</p><p>(2)把字符串通过地址栏返回</p><p>2.再去访问项目其他模块，每次访问在地址栏带着生成的字符串，在访问模块里面获取地址字符串，根据字符串获取用户信息。如果可以获取到，就是登录</p><h2 id="4-9、阿里云短信服务"><a href="#4-9、阿里云短信服务" class="headerlink" title="4.9、阿里云短信服务"></a>4.9、阿里云短信服务</h2><p>参考 3.2.5、service-msm</p><h2 id="4-10、OAuth2实现第三方登陆"><a href="#4-10、OAuth2实现第三方登陆" class="headerlink" title="4.10、OAuth2实现第三方登陆"></a>4.10、OAuth2实现第三方登陆</h2><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809175038617.png"></p><p>1、添加相关的配置类</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 微信开放平台 appid</span><br><span class="hljs-attr">wx.open.app_id</span>=<span class="hljs-string">你的appid</span><br><span class="hljs-comment"># 微信开放平台 appsecret</span><br><span class="hljs-attr">wx.open.app_secret</span>=<span class="hljs-string">你的appsecret</span><br><span class="hljs-comment"># 微信开放平台 重定向url</span><br><span class="hljs-attr">wx.open.redirect_url</span>=<span class="hljs-string">http://你的服务器名称/api/ucenter/wx/callback</span><br></code></pre></td></tr></table></figure><p>2、创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantWxUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;wx.open.app_id&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String appId;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;wx.open.app_secret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String appSecret;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;wx.open.redirect_url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String redirectUrl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String WX_OPEN_APP_ID;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String WX_OPEN_APP_SECRET;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String WX_OPEN_REDIRECT_URL;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        WX_OPEN_APP_ID = appId;<br>        WX_OPEN_APP_SECRET = appSecret;<br>        WX_OPEN_REDIRECT_URL = redirectUrl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、在controller层中写一个生成二维码的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、生成微信扫描二维码</span><br><span class="hljs-meta">@GetMapping(&quot;login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWxCode</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// 微信开放平台授权baseUrl  %s相当于?代表占位符</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">baseUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://open.weixin.qq.com/connect/qrconnect&quot;</span> +<br>        <span class="hljs-string">&quot;?appid=%s&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;redirect_uri=%s&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;response_type=code&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;scope=snsapi_login&quot;</span> +<br>        <span class="hljs-string">&quot;&amp;state=%s&quot;</span> +<br>        <span class="hljs-string">&quot;#wechat_redirect&quot;</span>;<br><br>    <span class="hljs-comment">//对redirect_url进行URLEncoder编码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">redirectUrl</span> <span class="hljs-operator">=</span> ConstantWxUtils.WX_OPEN_REDIRECT_URL;<br>    <span class="hljs-keyword">try</span> &#123;<br>        redirectUrl = URLEncoder.encode(redirectUrl, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>    &#125;<br>    <span class="hljs-comment">//设置%s里面值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> String.format(<br>        baseUrl,<br>        ConstantWxUtils.WX_OPEN_APP_ID,<br>        redirectUrl,<br>        <span class="hljs-string">&quot;atguigu&quot;</span><br>    );<br><br>    <span class="hljs-comment">//重定向到请求微信地址里面</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:&quot;</span>+url;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会产生一个二维码，然后当你扫描二维码之后点击登录，然后微信的服务器就会向项目的服务器发起回调。</p><p>当扫描登录之后会自动跳转到这个地址。</p><p><img src="/2022/08/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/image-20220809182729284.png"></p><p>所以需要将本地服务器端口号改为 8150 本地方法为callback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2、获取扫描人信息，添加数据</span><br><span class="hljs-meta">@GetMapping(&quot;callback&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">callCallback</span><span class="hljs-params">(String code,String state)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1、获取code值，临时票据，类似于验证码</span><br><br>        <span class="hljs-comment">// 2、拿着code请求微信固定的地址，得到两个值access_token和openid</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">baseAccessTokenUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;</span> +<br>            <span class="hljs-string">&quot;?appid=%s&quot;</span> +<br>            <span class="hljs-string">&quot;&amp;secret=%s&quot;</span> +<br>            <span class="hljs-string">&quot;&amp;code=%s&quot;</span> +<br>            <span class="hljs-string">&quot;&amp;grant_type=authorization_code&quot;</span>;<br>        <span class="hljs-comment">// 拼接三个参数：id，密钥 和 code值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessTokenUrl</span> <span class="hljs-operator">=</span> String.format(<br>            baseAccessTokenUrl,<br>            ConstantWxUtils.WX_OPEN_APP_ID,<br>            ConstantWxUtils.WX_OPEN_APP_SECRET,<br>            code);<br>        <span class="hljs-comment">// 请求这个拼接好的地址，得到返回两个值 access_token 和 openid</span><br>        <span class="hljs-comment">// 使用httpclient发送请求，得到返回结果</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessTokenInfo</span>  <span class="hljs-operator">=</span> HttpClientUtils.get(accessTokenUrl);<br><br>        <span class="hljs-comment">// 从accessTokenInfo字符串中获取出来 access_token 和 openid</span><br>        <span class="hljs-comment">// 把accessTokenInfo字符串转换为map集合，根据map里面key获取对应值</span><br>        <span class="hljs-comment">// 使用json转换工具 Gson</span><br>        <span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">mapAccessToken</span>  <span class="hljs-operator">=</span> gson.fromJson(accessTokenInfo, HashMap.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">access_token</span> <span class="hljs-operator">=</span> (String) mapAccessToken.get(<span class="hljs-string">&quot;access_token&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">openid</span> <span class="hljs-operator">=</span> (String) mapAccessToken.get(<span class="hljs-string">&quot;openid&quot;</span>);<br><br>        <span class="hljs-comment">// 把扫描人信息添加到数据库里面</span><br>        <span class="hljs-comment">// 判断数据库里面是否存在相同的微信信息，根据openid做判断</span><br>        <span class="hljs-type">UcenterMember</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> memberService.getOpenIdMember(openid);<br>        <span class="hljs-keyword">if</span> (member == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// member是空，表没有相同微信数据，进行添加</span><br>            <span class="hljs-comment">// 3、拿着得到的两个值access_token和openid,再去请求微信提供的固定地址从而得到扫码人的信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">baseUserInfoUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/userinfo&quot;</span> +<br>                <span class="hljs-string">&quot;?access_token=%s&quot;</span> +<br>                <span class="hljs-string">&quot;&amp;openid=%s&quot;</span>;<br>            <span class="hljs-comment">//拼接两个参数</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">userInfoUrl</span> <span class="hljs-operator">=</span> String.format(<br>                baseUserInfoUrl,<br>                access_token,<br>                openid<br>            );<br>            <span class="hljs-comment">// 发送请求</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> HttpClientUtils.get(userInfoUrl);<br>            <span class="hljs-comment">// 获取返回的userinfo字符串扫码人信息</span><br>            <span class="hljs-type">HashMap</span> <span class="hljs-variable">userInfoMap</span> <span class="hljs-operator">=</span> gson.fromJson(userInfo, HashMap.class);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">nickname</span> <span class="hljs-operator">=</span> (String)userInfoMap.get(<span class="hljs-string">&quot;nickname&quot;</span>); <span class="hljs-comment">// 昵称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">headimgurl</span> <span class="hljs-operator">=</span> (String)userInfoMap.get(<span class="hljs-string">&quot;headimgurl&quot;</span>); <span class="hljs-comment">// 头像</span><br><br><br>            member = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UcenterMember</span>();<br>            member.setOpenid(openid);<br>            member.setNickname(nickname);<br>            member.setAvatar(headimgurl);<br>            memberService.save(member); <span class="hljs-comment">// 添加</span><br>        &#125;<br>        <span class="hljs-comment">// 使用jwt根据member对象生成toekn字符串,返回首页面之后通过路径传递token字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jwtToken</span> <span class="hljs-operator">=</span> JwtUtils.getJwtToken(member.getId(), member.getNickname());<br><br>        <span class="hljs-comment">// 最后返回首页面，通过路径传递token字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:http://localhost:3000?token=&quot;</span>+jwtToken;<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuliException</span>(<span class="hljs-number">20001</span>,<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑：1、</p><h1 id="五、项目难点"><a href="#五、项目难点" class="headerlink" title="五、项目难点"></a>五、项目难点</h1><p>5.1、数据回显</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、项目简介&quot;&gt;&lt;a href=&quot;#一、项目简介&quot; class=&quot;headerlink&quot; title=&quot;一、项目简介&quot;&gt;&lt;/a&gt;一、项目简介&lt;/h1&gt;&lt;p&gt;实现一个B2C模式的在线教育平台，拥有前台用户系统与后台运营。&lt;/p&gt;
&lt;p&gt;要实现的功能：除了一些基础的功</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数组底层</title>
    <link href="https://eliseo.top/2022/07/27/%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82/"/>
    <id>https://eliseo.top/2022/07/27/%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82/</id>
    <published>2022-07-27T07:55:39.000Z</published>
    <updated>2022-07-28T15:37:02.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hashmap的底层原理"><a href="#hashmap的底层原理" class="headerlink" title="hashmap的底层原理"></a>hashmap的底层原理</h1><p>jdk1.8之后，底层是红黑树+数组+链表。</p><p><strong>扩容：</strong>当 hashmap 中node的数量大于 初始值(16) * 0.75 (12) 之后开始扩容，扩容的时候将初始值 * 2，当链表的长度 &gt;= 8 &amp;&amp; 数组大小 &gt;= 64的时候开始树形化。但是当链表长度&gt;=8而数组大小 &lt;64 的时候就会先进行扩容解决。当数据的长度退化成6时，红黑树转化为链表。</p><p><strong>hashput()的put()方法：</strong> </p><p><img src="/2022/07/27/%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82/image-20220727230001464.png" alt="image-20220727230001464"></p><h1 id="arraylist"><a href="#arraylist" class="headerlink" title="arraylist"></a>arraylist</h1><p><strong>arraylist与linkedlist区别</strong></p><p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p><p><strong>增加和删除用linkedlist  查找用arraylist</strong></p><p>ArrayList的最大容量为Integer.MAX_VALUE。</p><p><strong>扩容：</strong>在没放进元素的时候，数组大小是0；当放进去元素 &lt;10 的时候 数组大小为10；当放进去元素 &gt;10 的时候，先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容；大于最低容量要求进行扩容时 *1.5；大于MAX_ARRAY_SIZE，则取值为Integer.MAX_VALUE。</p><h1 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h1><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>ConcurrentHashMap在JDK1.8中使用的是数组 加 链表 加 红黑树的方式实现，它是通过 CAS 或者 synchronized 来保证线程安全的，并且缩小了锁的粒度，查询性能也更高。</p><h1 id="集合的Fail-Fast机制-乐观锁"><a href="#集合的Fail-Fast机制-乐观锁" class="headerlink" title="集合的Fail-Fast机制(乐观锁)"></a>集合的Fail-Fast机制(乐观锁)</h1><p>出现在不能并发的集合上：ArrayList，HashMap等。</p><p>会抛出并发修改异常(ConcurrentModificationException)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hashmap的底层原理&quot;&gt;&lt;a href=&quot;#hashmap的底层原理&quot; class=&quot;headerlink&quot; title=&quot;hashmap的底层原理&quot;&gt;&lt;/a&gt;hashmap的底层原理&lt;/h1&gt;&lt;p&gt;jdk1.8之后，底层是红黑树+数组+链表。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://eliseo.top/2022/07/19/Git/"/>
    <id>https://eliseo.top/2022/07/19/Git/</id>
    <published>2022-07-19T06:46:57.000Z</published>
    <updated>2022-07-19T13:15:44.337Z</updated>
    
    <content type="html"><![CDATA[<p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3S3N1OFVsSVR3TWxiWDNrTUd0WjlwME5KNEw5T1BJOWlhMU1taWJwdkRkNmNTZGRCZHZybGJkRXR5RU9yaDRDS25XVmlieWZDSGEzbHpYdy82NDA?x-oss-process=image/format,png" alt="img"></p><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；  ==<strong>git add .</strong>==</p><p>３、将暂存区域的文件提交到git仓库。 ==<strong>git commit</strong>==</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3S3N1OFVsSVR3TWxiWDNrTUd0WjlwMDlpYU9obDBkQUNmTHJNd05iRHp1Y0dRMzBzM0huc2lhY3pmY1I2ZEM5T2VoaWN1d2liS3VIalJsemcvNjQw?x-oss-process=image/format,png" alt="img"></p><h1 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h1><h2 id="增加提交记录"><a href="#增加提交记录" class="headerlink" title="增加提交记录"></a>增加提交记录</h2><p><code>git commit</code></p><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p><code>git branch &lt;name&gt;</code></p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p><code>git checkout &lt;name&gt;</code>切换到name这个分支</p><h2 id="创建并且切换分支"><a href="#创建并且切换分支" class="headerlink" title="创建并且切换分支"></a>创建并且切换分支</h2><p><code>git checkout -b &lt;name&gt;</code></p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p><code>git merge &lt;name&gt;</code>将name这个分支合并到当前分支中</p><hr><p><code>git rebase &lt;name&gt;</code>相比于<code>merge</code>，rebase是线性的。，将当前的*指向这个name</p><p><strong>区别：</strong></p><p>rebase会将这个分支弄到需要的分支下方，看起来就像是一条线</p><p>merge会生成一个新的提交分支，这个分支指向要合并的分支</p><p><img src="/2022/07/19/Git/image-20220719174552554.png" alt="rebase"></p><p><img src="/2022/07/19/Git/image-20220719174521847.png" alt="merge"></p><h2 id="在git提交树上移动"><a href="#在git提交树上移动" class="headerlink" title="在git提交树上移动"></a>在git提交树上移动</h2><p><code>git checkout &lt;提交记录的哈希值&gt;</code> 将head指向这个提交记录</p><h2 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h2><p><code>git checkout name^</code> 指向name分支的父记录</p><p><code>git checkout name~n</code> n指数字，就是将head指向name分支的第n个父记录</p><p><code>git branch -f master HEAD~3</code> 将 master 分支强制指向 HEAD 的第 3 级父提交</p><h2 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h2><p><code>git reset HEAD~n</code>通过把分支记录回退n个提交记录来实现撤销改动，但是在reset之后之前的提交还会存在，只是处在未加入暂存区之前。但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p><code>git revert HEAD~n</code> 撤销更改并<strong>分享</strong>给别人，revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><h2 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h2><p><code>git cherry-pick &lt;提交号&gt;</code> 将一些提交复制到当前所在的位置（<code>HEAD</code>）下面</p><p><code>git rebase -i HEAD~n</code> 会产生一个交互式的窗口直接在里面拖动就可以</p><p><code>git tag vn cn</code>可以永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。它们并不会随着新的提交而移动</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="将本地仓库克隆到远程仓库"><a href="#将本地仓库克隆到远程仓库" class="headerlink" title="将本地仓库克隆到远程仓库"></a>将本地仓库克隆到远程仓库</h2><p><code>git clone</code></p><h2 id="从远程仓库获取数据"><a href="#从远程仓库获取数据" class="headerlink" title="从远程仓库获取数据"></a>从远程仓库获取数据</h2><p><code>git fetch </code>单纯的下载文件</p><h2 id="先抓取更新再合并到本地分支"><a href="#先抓取更新再合并到本地分支" class="headerlink" title="先抓取更新再合并到本地分支"></a>先抓取更新再合并到本地分支</h2><p><code>git pull</code>不仅下载文件而且还会下载结构。 <strong>git pull == git fetch + git merge</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://eliseo.top/2022/07/17/Redis/"/>
    <id>https://eliseo.top/2022/07/17/Redis/</id>
    <published>2022-07-17T04:01:39.000Z</published>
    <updated>2022-07-18T14:35:27.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、缓存数据的处理流程是怎样的？"><a href="#一、缓存数据的处理流程是怎样的？" class="headerlink" title="一、缓存数据的处理流程是怎样的？"></a>一、缓存数据的处理流程是怎样的？</h1><p><img src="https://javaguide.cn/assets/cache-process.c27b9c06.png" alt="正常缓存处理流程"></p><p>简单来说就是:</p><ol><li>如果用户请求的数据在缓存中就直接返回。</li><li>缓存中不存在的话就看数据库中是否存在。</li><li>数据库中存在的话就更新缓存中的数据。</li><li>数据库中不存在的话就返回空数据。</li></ol><h1 id="二、为什么要用-Redis-为什么要用缓存？"><a href="#二、为什么要用-Redis-为什么要用缓存？" class="headerlink" title="二、为什么要用 Redis/为什么要用缓存？"></a>二、为什么要用 Redis/为什么要用缓存？</h1><p>简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。</p><p><strong>高性能</strong> ：当用户第一次访问数据的时候会从磁盘中读取，会很慢，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中，那么用户下一次再访问这些数据的时候就可以直接从缓存中获取了</p><p><strong>高并发：</strong>放到缓存中的话，用户的一部分请求就会进入缓存而不是数据库。</p><h1 id="三、Redis常见数据结构"><a href="#三、Redis常见数据结构" class="headerlink" title="三、Redis常见数据结构"></a>三、Redis常见数据结构</h1><hr><p><strong><code>String</code></strong></p><ol><li><strong>常用命令：</strong> <code>set(设置k-v类型的值),get(通过k获得对应的v),strlen(获得key存储的字符串长度),exists(判断key是否存在),decr(设置k的v自减),incr(设置k的v自增),setex(设置过期时间)</code> 等等。</li><li><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li></ol><hr><p>**<code>list</code>**：双向链表</p><ol><li><strong>常用命令:</strong> <code>rpush(向list右边添加元素),lpop(移除list中的左边元素),lpush,rpop,lrange(查看对应下标的list列表 0 -1表示查看所有),llen(查看链表长度)</code> 等。</li><li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li></ol><p><img src="https://javaguide.cn/assets/redis-list.e79ad4dd.png" alt="redis list"></p><hr><p><strong><code>hash</code></strong></p><ol><li><strong>常用命令：</strong> <code>hset(设置一个具体的k-v),hmset(设置多个k-v),hexists(查看是否存在k),hget(得到k对应的v),hgetall(得到所有哈希表名的k-v),hkeys(获取所有的k),hvals(获取所有的v)</code> 等。</li><li><strong>应用场景:</strong> 系统中对象数据的存储。</li></ol><p>格式：hset 哈希表名 哈希表key 哈希表value</p><hr><p><strong><code>set</code></strong></p><ol><li><strong>常用命令：</strong> <code>sadd(添加元素),spop(随机删除),smembers(查看所集合中的所有元素),sismember(查询元素是否是集合中的成员),scard(获取成员数量),sinterstore(获取集合1与集合2的交集并放在集合3中),sunion(获取并集)</code> 等。</li><li><strong>应用场景:</strong> <strong>需要存放的数据不能重复</strong>以及需要获取多个数据源交集和并集等场景</li></ol><hr><p><strong><code>zset</code></strong></p><ol><li><strong>常用命令：</strong> <code>zadd(),zcard(),zscore(),zrange(),zrevrange(),zrem()</code> 等。</li><li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li></ol><h1 id="四、Redis-线程模型"><a href="#四、Redis-线程模型" class="headerlink" title="四、Redis 线程模型"></a>四、Redis 线程模型</h1><p>Redis是单线程的，Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><h1 id="五、Redis内存管理"><a href="#五、Redis内存管理" class="headerlink" title="五、Redis内存管理"></a>五、Redis内存管理</h1><hr><p><strong><code>为什么要设置过期时间？</code></strong></p><p>因为内存是有限的，不设置过期时间就会产生oom。</p><p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><hr><p><strong><code>过期的数据的删除策略了解么？</code></strong></p><p>常用的过期数据的删除策略就两个：</p><ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p><hr><h1 id="六、Redis持久化机制"><a href="#六、Redis持久化机制" class="headerlink" title="六、Redis持久化机制"></a>六、Redis持久化机制</h1><p><strong>一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong></p><hr><p><strong><code>RDB</code></strong></p><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><hr><p><strong><code>AOF</code></strong></p><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>三种AOF方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度<br>appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘<br>appendfsync no        #让操作系统决定何时进行同步<br></code></pre></td></tr></table></figure><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化</p><h1 id="七、Redis事务"><a href="#七、Redis事务" class="headerlink" title="七、Redis事务"></a>七、Redis事务</h1><ol><li>开始事务（<code>MULTI</code>）。</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol><p><code>DISCARD</code>取消事务，</p><p><code>WATCH</code>监听事务。当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，<strong>Redis 事务其实是不满足原子性的（而且不满足持久性）。</strong></p><p><strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><h1 id="八、Redis生产问题"><a href="#八、Redis生产问题" class="headerlink" title="八、Redis生产问题"></a>八、Redis生产问题</h1><h2 id="8-1、缓存穿透"><a href="#8-1、缓存穿透" class="headerlink" title="8.1、缓存穿透"></a>8.1、缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p><p><img src="https://img-blog.csdnimg.cn/6358650a9bf742838441d636430c90b9.png" alt="缓存穿透情况"></p><p><strong>如何解决？</strong>布隆过滤器</p><p>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端</p><p><img src="https://javaguide.cn/assets/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.79596186.png" alt="img"></p><h2 id="8-2、缓存雪崩"><a href="#8-2、缓存雪崩" class="headerlink" title="8.2、缓存雪崩"></a>8.2、缓存雪崩</h2><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong></p><p><strong><code>如何解决？</code></strong></p><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效</li></ol><h1 id="九、3种常用的缓存读写策略"><a href="#九、3种常用的缓存读写策略" class="headerlink" title="九、3种常用的缓存读写策略"></a>九、3种常用的缓存读写策略</h1><h2 id="Cache-Asbde-Pattern（旁路缓存模式）"><a href="#Cache-Asbde-Pattern（旁路缓存模式）" class="headerlink" title="Cache Asbde Pattern（旁路缓存模式）"></a>Cache Asbde Pattern（旁路缓存模式）</h2><p>比较适合读请求比较多的时候。</p><p><strong>写</strong> ：</p><ul><li>先更新 DB。</li><li>然后直接删除 cache 。</li></ul><p><strong>读</strong> :</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache中读取不到的话，就从 DB 中读取数据返回</li><li>再把数据放到 cache 中。</li></ul><p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p><p>解决办法：可以将热点数据可以提前放入cache 中。</p><p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul><h2 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h2><p><strong>写（Write Through）：</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 DB。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li></ul><p><strong>读(Read Through)：</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li></ul><h2 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h2><p>读写穿透的异步模式</p><h1 id="十、Redis分布式锁"><a href="#十、Redis分布式锁" class="headerlink" title="十、Redis分布式锁"></a>十、Redis分布式锁</h1><p>方案一：SETNX 设置锁  <strong>会造成死锁</strong></p><p>方案二：设置锁之后设置锁的过期时间 <strong>但是在设置锁之后 设置过期时间之间如果报错过期时间就会设置不成功</strong></p><p>方案三：设置锁与设置过期时间一起设置 保证原子性 <strong>但是A在过期时间之后没完成任务然后B进入的时候 在B执行期间 A完成任务就会将锁释放</strong></p><p>方案四：设置锁与过期时间以及锁的编号一起设置 当删除锁的时候查询编号 如果一致，则认为是自己设置的锁，可以进行主动删除。  <strong>但是获取锁以及删除锁不是原子性的。</strong></p><p>方案五：将查询锁和删除锁这两步作为原子指令 也就是使用脚本锁删。</p><p>方案六：看门狗机制。我们不知道锁什么时候过期，所以利用看门狗机制，没过10s看门狗就延长30s的过期时间，当服务器G了以后，10s以后看门狗不延长30s，那么锁就会自动删除。</p><h1 id="十一、缓存和数据库一致问题"><a href="#十一、缓存和数据库一致问题" class="headerlink" title="十一、缓存和数据库一致问题"></a>十一、缓存和数据库一致问题</h1><p><strong>采用延迟双删来解决问题</strong>：先进行缓存清除，再执行update，最后（延迟N秒）再执行缓存清除。</p><p>1、想要提高应用的性能，可以引入「缓存」来解决</p><p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p><p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p><p>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p><p>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p><p>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、缓存数据的处理流程是怎样的？&quot;&gt;&lt;a href=&quot;#一、缓存数据的处理流程是怎样的？&quot; class=&quot;headerlink&quot; title=&quot;一、缓存数据的处理流程是怎样的？&quot;&gt;&lt;/a&gt;一、缓存数据的处理流程是怎样的？&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://eliseo.top/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://eliseo.top/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-07-16T01:54:51.000Z</published>
    <updated>2022-07-29T02:38:40.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1-1、数据库范式"><a href="#1-1、数据库范式" class="headerlink" title="1.1、数据库范式"></a>1.1、数据库范式</h2><p><strong><code>1NF(第一范式)</code><strong>每一列的属性都不可再分，保证每一列的</strong>原子性</strong></p><p>**<code>2NF(第二范式)</code><strong>2NF 在 1NF 的基础之上，</strong>还要满足数据表里的每一条数据记录都是可唯一标识的，并且所有的非主键字段都要完全依赖于主键。(对于一个数据，如果主键是联合主键，那么就要满足如果要确定非主键字段那么就要同时知道所有主键的信息)**。不完全依赖就将这一部分分离出来形成一个新实体。</p><blockquote><p>1NF是告诉我们字段属性需要原子性，2NF告诉我们一张表就是一个独立的个体，一个表只表达一个意思</p></blockquote><p><strong><code>3NF(第三范式)</code></strong> 每个非主属性必须直接依赖于主属性，不能存在非主属性A依赖于B，B依赖于主属性C，然后A依赖于C这种关系。<strong>也就是说非主属性之间必须完全独立。</strong></p><p><strong><code>BCNF(优化以后的第三范式)</code></strong></p><p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。</p><h2 id="1-2、drop、delete-与-truncate-区别？"><a href="#1-2、drop、delete-与-truncate-区别？" class="headerlink" title="1.2、drop、delete 与 truncate 区别？"></a>1.2、drop、delete 与 truncate 区别？</h2><hr><p><strong><code>用法不同</code></strong></p><p>drop：删除表以及表的数据</p><p>truncate：删除表中的所有数据</p><p>delete：删除表中的某一行元素</p><p> <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p><hr><p><strong><code>属于不同的数据库语言</code></strong></p><p><strong>DDL(数据库定义语言)：</strong>drop、truncate</p><p><strong>DML(数据库操作语言)：</strong>delete</p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><hr><p><strong><code>执行速度不同</code></strong></p><p>一般来说：drop &gt; truncate &gt; delete</p><h2 id="1-3、数据库设计通常分为哪几步"><a href="#1-3、数据库设计通常分为哪几步" class="headerlink" title="1.3、数据库设计通常分为哪几步?"></a>1.3、数据库设计通常分为哪几步?</h2><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li></ol><h1 id="二、MySQL"><a href="#二、MySQL" class="headerlink" title="二、MySQL"></a>二、MySQL</h1><h2 id="2-1、存储引擎"><a href="#2-1、存储引擎" class="headerlink" title="2.1、存储引擎"></a>2.1、存储引擎</h2><blockquote><p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要它不⽀持的特性时，才考虑使⽤其它 存储引擎。</p></blockquote><h3 id="2-1-1、MyISAM-和-InnoDB-的区别是什么？"><a href="#2-1-1、MyISAM-和-InnoDB-的区别是什么？" class="headerlink" title="2.1.1、MyISAM 和 InnoDB 的区别是什么？"></a>2.1.1、MyISAM 和 InnoDB 的区别是什么？</h3><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </li><li>InnoDB支持外键，而MyISAM不支持。</li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li></ol><h2 id="2-2、MySQL查询缓存"><a href="#2-2、MySQL查询缓存" class="headerlink" title="2.2、MySQL查询缓存"></a>2.2、MySQL查询缓存</h2><p><strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。</p><p><strong>查询缓存不命中的情况：（1）</strong>任何两个查询在任何字符上的不同都会导致缓存不命中。</p><p><strong>查询缓存不命中的情况：（2）</strong>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</p><p><strong>查询缓存不命中的情况：（3）</strong> <strong>缓存建立之后</strong>，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效</p><h2 id="2-3、MySQL事务"><a href="#2-3、MySQL事务" class="headerlink" title="2.3、MySQL事务"></a>2.3、MySQL事务</h2><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><blockquote><p>数据库事务</p></blockquote><p><strong>要么全部执行成功,要么全部不执行</strong> </p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215205475.png" alt="数据库事务示意图"></p><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215217274.png" alt="ACID"></p><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215227923.png" alt="AID -&gt; C"></p><h3 id="2-3-1、并发事务带来的问题"><a href="#2-3-1、并发事务带来的问题" class="headerlink" title="2.3.1、并发事务带来的问题"></a>2.3.1、并发事务带来的问题</h3><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一<strong>个事务内两次读到的数据是不一样的情况，</strong>因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<br><img src="https://img-blog.csdnimg.cn/20201216230427546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM5ODY4Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="不可重复读"></li></ul><blockquote><p>不可重复读和幻读两者有些相似。但<code>不可重复读重点在于update和delete，而幻读的重点在于insert。</code></p></blockquote><h3 id="2-3-2、事务隔离级别"><a href="#2-3-2、事务隔离级别" class="headerlink" title="2.3.2、事务隔离级别"></a>2.3.2、事务隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p><strong>其中，可串行化是基于锁来实现的，剩下的三个隔离级别都是基于MVCC实现</strong></p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读，就是一个不加锁的select</li><li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock(临键锁) 进行加锁来保证不出现幻读，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li></ul><p>简单理解需要加锁的是当前读，快照读不需要加锁。</p><p><strong>事务是如何实现mvcc的？</strong> </p><p>1、每个事务都有⼀个事务ID,叫做transaction id(严格递增) </p><p>2、事务在启动时,找到已提交的最⼤事务ID记为up_limit_id。 </p><p>3、事务在更新⼀条语句时 ⽐如 id=1 改为了 id=2.会把 id=1 和该⾏之前的 row trx_id 写到 undo log ⾥, 并且在数据⻚上 把 id 的值改为 2,并且把修改这条语句的transaction id 记在该⾏⾏头 </p><p>4、再定⼀个规矩 ⼀个事务要查看⼀条数据时,必须先⽤该事务的 up_limit_id 与该⾏的transaction id 做⽐对 如果 up_limit_id &gt;= transaction id,那么可以看 如果 up_limit_id &lt; transaction id,则只能去 undo log ⾥去取。 去 undo log 查找数据的时候,也需要做⽐对,必须 up_limit_id &gt; transaction id，才返回数据</p><h2 id="2-4、MySQL锁"><a href="#2-4、MySQL锁" class="headerlink" title="2.4、MySQL锁"></a>2.4、MySQL锁</h2><h3 id="2-4-1、锁的分类"><a href="#2-4-1、锁的分类" class="headerlink" title="2.4.1、锁的分类"></a>2.4.1、锁的分类</h3><p>表级锁与行级锁：表级锁是将整个表锁住，在并发的情况下，性能十分差。</p><p>行级锁是对一行或者多行记录进行加锁。</p><blockquote><p><strong>表级锁和行级锁对比</strong> </p></blockquote><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li></ul><blockquote><p><strong>行级锁的使用注意事项：</strong></p></blockquote><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。</p><blockquote><p><strong>共享锁与排他锁</strong></p></blockquote><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录(SELECT)的时候获取共享锁，允许多个事务同时获取（锁兼容）。如果<code>事务A</code>对<code>数据B</code>（1024房）加上读锁后，则其他事务只能对<code>数据B</code>上加读锁，不能加写锁。获得读锁的事务只能读数据，不能修改数据。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果<code>事务A</code>对<code>数据B</code>加上写锁后，则其他事务不能再对<code>数据B</code>加任何类型的锁。<code>获得写锁的事务既能读数据，又能修改数据</code>。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 共享锁<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 排他锁<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>意向锁</strong></p></blockquote><p>意向锁属于表级锁，<strong>目的</strong>主要是为了在一个事务中揭示下一行将要被请求锁的类型。</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><code>意向锁是 InnoDB 自动加的，不需要用户干预。</code></p><p>对于INSERT、UPDATE和DELETE，InnoDB 会自动给涉及的数据加排他锁；对于一般的SELECT语句，InnoDB 不会加任何锁</p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><blockquote><p><strong>InnoDB 有哪几类行锁？</strong></p></blockquote><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。（实质上是锁住索引）</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p>间隙锁与临键锁可以防止幻读</p><h2 id="2-5、MySQL高性能优化"><a href="#2-5、MySQL高性能优化" class="headerlink" title="2.5、MySQL高性能优化"></a>2.5、MySQL高性能优化</h2><p><a href="https://blog.csdn.net/shassd/article/details/109708433?ops_request_misc=%7B%22request_id%22:%22165796295816782391893729%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165796295816782391893729&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-109708433-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83&spm=1018.2226.3001.4187">常用数据库设计规范总结</a></p><h2 id="2-6、索引"><a href="#2-6、索引" class="headerlink" title="2.6、索引"></a>2.6、索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p>索引的作用就相当于书的目录。</p><h3 id="2-6-1、索引的优缺点"><a href="#2-6-1、索引的优缺点" class="headerlink" title="2.6.1、索引的优缺点"></a>2.6.1、索引的优缺点</h3><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间</li></ul><h3 id="2-6-2、索引的底层数据结构"><a href="#2-6-2、索引的底层数据结构" class="headerlink" title="2.6.2、索引的底层数据结构"></a>2.6.2、索引的底层数据结构</h3><hr><p><strong><code>Hash表</code></strong></p><p><strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点</strong></p><hr><p><strong><code>B 树&amp; B+树</code></strong></p><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong></p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><h3 id="2-6-3、索引类型"><a href="#2-6-3、索引类型" class="headerlink" title="2.6.3、索引类型"></a>2.6.3、索引类型</h3><hr><p><strong><code>主键索引</code></strong></p><p>数据表的主键列使用的就是主键索引。是一种特殊的唯一索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><hr><p><strong><code>二级索引</code></strong></p><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><ol><li><strong>唯一索引(Unique Key)</strong> ：<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> </li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于<strong>字符串类型的数据</strong>。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p>二级索引:</p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215309355.png"></p><hr><h3 id="2-6-4、聚集索引与非聚集索引"><a href="#2-6-4、聚集索引与非聚集索引" class="headerlink" title="2.6.4、聚集索引与非聚集索引"></a>2.6.4、聚集索引与非聚集索引</h3><p><strong><code>聚集索引</code><strong>：</strong>聚集索引即索引结构和数据一起存放的索引，找到索引也就找到了数据。主键索引属于聚集索引。</strong></p><p>聚集索引查询速度非常快，定位到了索引的位置也就直接定位到了数据的值。</p><p><strong>聚集索引的缺点</strong></p><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><hr><p><strong><code>非聚集索引</code>：</strong>非聚集索引即索引结构和数据分开存放的索引。当你要找一个数据的时候，先在内存中搜索索引，然后通过索引找到磁盘对应的数据。 <strong>类似于根据偏旁部首找字，首先找到该字所在的地址，再根据地址找到这个字的信息。</strong></p><p>更新代价比聚集索引要小 。</p><p><strong>非聚集索引的缺点</strong></p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><h3 id="2-6-5、覆盖索引"><a href="#2-6-5、覆盖索引" class="headerlink" title="2.6.5、覆盖索引"></a>2.6.5、覆盖索引</h3><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><h3 id="2-6-6、联合索引"><a href="#2-6-6、联合索引" class="headerlink" title="2.6.6、联合索引"></a>2.6.6、联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><p>使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。(最左前缀匹配原则)</p><h3 id="2-6-7、创建索引的注意事项"><a href="#2-6-7、创建索引的注意事项" class="headerlink" title="2.6.7、创建索引的注意事项"></a>2.6.7、创建索引的注意事项</h3><p><strong>1、选择合适的字段创建索引</strong></p><ul><li>不为 NULL 的字段</li><li>被频繁查询的字段 </li><li>被作为条件查询的字段 </li><li>频繁需要排序的字段 </li><li>被经常频繁用于连接的字段</li></ul><p><strong>2、被频繁更新的字段应该慎重建立索引。</strong></p><p><strong>3、尽可能的考虑建立联合索引而不是单列索引。</strong></p><p><strong>4、注意避免冗余索引</strong> 。</p><p><strong>5、考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><h3 id="2-6-8、-MySQL-如何为表字段添加索引？"><a href="#2-6-8、-MySQL-如何为表字段添加索引？" class="headerlink" title="2.6.8、 MySQL 如何为表字段添加索引？"></a>2.6.8、 MySQL 如何为表字段添加索引？</h3><p>1.添加 PRIMARY KEY（主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY ( `<span class="hljs-keyword">column</span>` )<br></code></pre></td></tr></table></figure><p>2.添加 UNIQUE(唯一索引)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">ALTER TABLE `table_name` ADD UNIQUE ( `column` )<br></code></pre></td></tr></table></figure><p>3.添加 INDEX(普通索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `<span class="hljs-keyword">column</span>` )<br></code></pre></td></tr></table></figure><p>4.添加 FULLTEXT(全文索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> FULLTEXT ( `<span class="hljs-keyword">column</span>`)<br></code></pre></td></tr></table></figure><p>5.添加多列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` )<br></code></pre></td></tr></table></figure><h3 id="2-6-9、什么情况下不会用到索引"><a href="#2-6-9、什么情况下不会用到索引" class="headerlink" title="2.6.9、什么情况下不会用到索引"></a>2.6.9、什么情况下不会用到索引</h3><p>如果条件中有or，即使其中有部分条件带索引也不会使用(这也是为什么尽量少用or的原因)<br>对于多列索引，不是使用的第一部分，则不会使用索引<br>like查询是以%开头<br>存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引<br>where 子句里对索引列上有数学运算，用不上索引<br>where 子句里对有索引列使用函数，用不上索引<br>如果MySQL估计使用全表扫描要比使用索引快,则不使用索引</p><h2 id="2-7、MySQL三大日志-binlog、redo-log和undo-log"><a href="#2-7、MySQL三大日志-binlog、redo-log和undo-log" class="headerlink" title="2.7、MySQL三大日志(binlog、redo log和undo log)"></a>2.7、MySQL三大日志(binlog、redo log和undo log)</h2><h3 id="2-7-1、redo-log-重做日志"><a href="#2-7-1、redo-log-重做日志" class="headerlink" title="2.7.1、redo log(重做日志)"></a>2.7.1、redo log(重做日志)</h3><p>是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215323923.png"></p><h3 id="2-7-2、bin-log"><a href="#2-7-2、bin-log" class="headerlink" title="2.7.2、bin log"></a>2.7.2、bin log</h3><p>负责记录数据库的操作，只要表数据发生更新，那么就会产生日志。</p><p>主要用来 集群化管理，主要用来 <strong>主从复制</strong> 和 <strong>数据恢复</strong> </p><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong>：只有sql语句</li><li><strong>row</strong> ：记录sql语句的时候会包含具体的数据，比较占空间</li><li><strong>mixed</strong>：前两者的结合，判断sql会引起数据不一致就调用row，不会就使用statement</li></ul><h3 id="2-7-3、undo-log"><a href="#2-7-3、undo-log" class="headerlink" title="2.7.3、undo log"></a>2.7.3、undo log</h3><p>如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。</p><p><strong><code>总结：</code></strong></p><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p><h2 id="2-8、MVCC"><a href="#2-8、MVCC" class="headerlink" title="2.8、MVCC"></a>2.8、MVCC</h2><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。</p><hr><p><strong><code>隐藏字段</code></strong></p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。</li></ul><hr><p><strong><code>ReadView</code></strong></p><ul><li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li><li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li><li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li></ul><p><strong>事务可见性示意图</strong>：</p><p><img src="https://javaguide.cn/assets/trans_visible.048192c5.png" alt="trans_visible"></p><hr><p><strong><code>undo-log</code></strong></p><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><hr><p><strong><code>RC 和 RR 隔离级别下 MVCC 的差异</code></strong></p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表</li></ul><p><strong>总结：</strong> <strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/E%60%60M%7B%5BHMESZ2J5R79K2V_7N.png" alt="数据可见性算法"></p><p><strong><code>MVCC➕Next-key-Lock 防止幻读</code></strong></p><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 [Next-key Lockopen in new window]来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h2 id="2-9、Mysql架构"><a href="#2-9、Mysql架构" class="headerlink" title="2.9、Mysql架构"></a>2.9、Mysql架构</h2><p><img src="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220724215337684.png" alt="image-20220724215337684"></p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。</li></ul><p><strong><code>总结</code></strong></p><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li><li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li></ul><hr><h2 id="2-10、隐式转换"><a href="#2-10、隐式转换" class="headerlink" title="2.10、隐式转换"></a>2.10、隐式转换</h2><p>规则：</p><ol><li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>&#39;abc&#39;</code>、<code>&#39;a123bc&#39;</code>、<code>&#39;abc123&#39;</code>都会转化为<code>0</code>；</li><li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>&#39;123abc&#39;</code>会转换为<code>123</code>，<code>&#39;012abc&#39;</code>会转换为<code>012</code>也就是<code>12</code>，<code>&#39;5.3a66b78c&#39;</code>会转换为<code>5.3</code>，其他同理。</li></ol><p><strong>总结：</strong></p><ol><li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li><li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li><li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li><li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;h2 id=&quot;1-1、数据库范式&quot;&gt;&lt;a href=&quot;#1-1、数据库范式&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>十大排序</title>
    <link href="https://eliseo.top/2022/07/15/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <id>https://eliseo.top/2022/07/15/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</id>
    <published>2022-07-15T15:34:06.000Z</published>
    <updated>2022-07-15T15:37:20.131Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:冒泡排序</span><br><span class="hljs-comment">     * @return: int[]</span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 8:48</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:选择排序</span><br><span class="hljs-comment">     * @return: int[]</span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 8:52</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectionSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIndex != i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>                arr[i] = arr[minIndex];<br>                arr[minIndex] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:插入排序</span><br><span class="hljs-comment">     * @return: int[]</span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 9:06</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertionSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;<br>                arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>                preIndex--;<br>            &#125;<br>            arr[preIndex + <span class="hljs-number">1</span>] = current;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @description:希尔排序</span><br><span class="hljs-comment">     * @return: int[] </span><br><span class="hljs-comment">     * @author: Mr.Wang</span><br><span class="hljs-comment">     * @time: 2022/7/15 9:39</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>                <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>                    arr[preIndex + gap] = arr[preIndex];<br>                    preIndex -= gap;<br>                &#125;<br>                arr[preIndex + gap] = current;<br><br>            &#125;<br>            gap /= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;;<br>        shellSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: quickSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 15:57</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">quickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span> || arr == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (L &lt; R) &#123;<br>            swap(arr,  (<span class="hljs-type">int</span>) (L + Math.random() * (R - L + <span class="hljs-number">1</span>)),R);<br>            <span class="hljs-type">int</span>[] p = partition(arr, L, R);<br>            quickSort(arr, <span class="hljs-number">0</span>, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>            quickSort(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R;<br>        <span class="hljs-keyword">while</span> (L &lt; more) &#123;<br>            <span class="hljs-keyword">if</span> (arr[L] &lt; arr[R]) &#123;<br>                less++;<br>                swap(arr,less,L);<br>                L++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[L] &gt; arr[R]) &#123;<br>                more--;<br>                swap(arr,more,L);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                L++;<br>            &#125;<br>        &#125;<br>        swap(arr,more,R);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;<br>    &#125;<br><br><br><br>    <span class="hljs-comment">// 1 2 3 4 8  4</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[L];<br>        arr[L] = arr[R];<br>        arr[R] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        quickSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>归并排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: mergeSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 9:53</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 归并排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">mergeSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 属于归并排序中的划分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (L == R) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + (R - L) / <span class="hljs-number">2</span>;<br>        process(arr, <span class="hljs-number">0</span>, mid);<br>        process(arr, mid+<span class="hljs-number">1</span>, R);<br>        merge(arr, L, mid, R);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>]; <span class="hljs-comment">//辅助数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> L;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> M + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;<br>            <span class="hljs-comment">// 数组中哪一个小 哪一个在前</span><br>            <span class="hljs-keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;<br>                help[i] = arr[p1];<br>                i++;<br>                p1++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                help[i] = arr[p2];<br>                i++;<br>                p2++;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">//如果p1没越界，就把p1剩下的拷到help中</span><br>        <span class="hljs-keyword">while</span> (p1 &lt;= M) &#123;             <span class="hljs-comment">// 以下两个while只会执行一个 也就是p1 p2 必然会有一个越界</span><br>            help[i] = arr[p1];<br>            i++;<br>            p1++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p2 &lt;= R) &#123;<br>            help[i] = arr[p2];<br>            i++;<br>            p2++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>            arr[L + i] = help[i];<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br>        mergeSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>堆排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: heapSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 21:46</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:左神视频25：44</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">heapSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">heapsize</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            heapInsert(arr, i);<br>        &#125;<br>        swap(arr, <span class="hljs-number">0</span>, --heapsize);<br>        <span class="hljs-keyword">while</span> (heapsize &gt; <span class="hljs-number">0</span>) &#123;<br>            heapify(arr, <span class="hljs-number">0</span>, heapsize);<br>            swap(arr, <span class="hljs-number">0</span>, --heapsize);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 判断大根堆是否成立，如果不成立</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;<br>            swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//堆化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapsize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; heapsize) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span> &lt; heapsize &amp;&amp; arr[left] &lt; arr[left + <span class="hljs-number">1</span>] ? left + <span class="hljs-number">1</span> : left;<br>            last = arr[last] &gt; arr[index] ? last : index;<br>            <span class="hljs-keyword">if</span> (last == index) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            swap(arr, last, index);<br>            index = last;<br>            left = (index * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[L];<br>        arr[L] = arr[R];<br>        arr[R] = temp;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br>        heapSort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基数排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wang.算法;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: com.wang.算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: radixSort</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Mr.Wang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CreateTime</span>: 2022/7/15 22:15</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:左神视频1：51：25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">radixSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));<br>    &#125;<br><br>    <span class="hljs-comment">// 计算数组中最大的数字有几位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxbits</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            max = Math.max(max, arr[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>            res++;<br>            max /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// digit是这个数组中最大的数字有几位</span><br>    <span class="hljs-comment">// 对应的词频下标数减1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> digit)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; d &lt; radix; d++) &#123; <span class="hljs-comment">// 有几位就进出几次桶</span><br>            <span class="hljs-comment">// count[0] 表示当前位(d位)小于等于0的数字有几个</span><br>            <span class="hljs-comment">// count[1] 表示当前位(d位)小于等于1的数字有几个</span><br>            <span class="hljs-comment">// count[2] 表示当前位(d位)小于等于2的数字有几个</span><br>            <span class="hljs-comment">// count[i] 表示当前位(d位)小于等于i的数字有几个</span><br>            <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[radix];<br>            <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;<br>                j = getDiggit(arr[i], d);<br>                count[j]++;<br>            &#125;<br><br>            <span class="hljs-comment">// 将count处理成累加和 也就是处理成小于当前位的数有几个</span><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;<br>                count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>            &#125;<br><br>            <span class="hljs-comment">// 数组从右往左遍历</span><br>            <span class="hljs-comment">// 模拟数字出桶过程</span><br>            <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;<br>                j = getDiggit(arr[i], d);<br>                help[count[j] - <span class="hljs-number">1</span>] = arr[i];<br>                count[j]--;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;<br>                arr[i] = help[j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 得到数组中这个数字的第d位的数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDiggit</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> &#123;<br>        <span class="hljs-keyword">return</span> ((x / ((<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://eliseo.top/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://eliseo.top/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-13T14:00:15.000Z</published>
    <updated>2022-07-24T13:55:08.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、图"><a href="#一、图" class="headerlink" title="一、图"></a>一、图</h1><p>图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：**G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p><h2 id="1-1、图的基本元素"><a href="#1-1、图的基本元素" class="headerlink" title="1.1、图的基本元素"></a>1.1、图的基本元素</h2><h3 id="1-1-1、顶点"><a href="#1-1-1、顶点" class="headerlink" title="1.1.1、顶点"></a><strong>1.1.1、顶点</strong></h3><p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）</p><p>对应到好友关系图，每一个用户就代表一个顶点。</p><hr><h3 id="1-1-2、边"><a href="#1-1-2、边" class="headerlink" title="1.1.2、边"></a><strong>1.1.2、边</strong></h3><p>顶点之间的关系用边表示。</p><p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p><hr><h3 id="1-1-3、度"><a href="#1-1-3、度" class="headerlink" title="1.1.3、度"></a><strong>1.1.3、度</strong></h3><p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。</p><p>对应到好友关系图，度就代表了某个人的好友数量。</p><hr><h3 id="1-1-4、无向图和有向图"><a href="#1-1-4、无向图和有向图" class="headerlink" title="1.1.4、无向图和有向图"></a><strong>1.1.4、无向图和有向图</strong></h3><p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。</p><p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图</p><hr><h3 id="1-1-5、无权图和带权图"><a href="#1-1-5、无权图和带权图" class="headerlink" title="1.1.5、无权图和带权图"></a><strong>1.1.5、无权图和带权图</strong></h3><p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。</p><p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p><h2 id="1-2、图的存储"><a href="#1-2、图的存储" class="headerlink" title="1.2、图的存储"></a>1.2、图的存储</h2><hr><h3 id="1-2-1、邻接矩阵存储"><a href="#1-2-1、邻接矩阵存储" class="headerlink" title="1.2.1、邻接矩阵存储"></a><strong>1.2.1、邻接矩阵存储</strong></h3><p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。</p><p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 <code>A[i][j]=n</code> 。</p><p>在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，<code>A[i][j]</code>=1，当顶点i和顶点j没有关系时，<code>A[i][j]</code>=0。如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8.3ba1bccc.png" alt="无向图的邻接矩阵存储"></p><p>值得注意的是：<strong>无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。</strong></p><p><img src="https://javaguide.cn/assets/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8.46663a1b.png" alt="有向图的邻接矩阵存储"></p><p><strong><code>邻接矩阵存储的方式虽然比较直接简单，但是比较浪费空间。</code></strong></p><hr><h3 id="1-2-2、邻接表存储"><a href="#1-2-2、邻接表存储" class="headerlink" title="1.2.2、邻接表存储"></a><strong>1.2.2、邻接表存储</strong></h3><p>邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 <strong>邻接表</strong>。如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8.2869ec57.png" alt="无向图的邻接表存储"></p><p><img src="https://javaguide.cn/assets/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8.362b00d5.png" alt="有向图的邻接表存储"></p><ul><li>在无向图中，邻接表元素个数等于边的条数的两倍。</li><li>在有向图中，邻接表元素个数等于边的条数。</li></ul><h2 id="1-3、图的搜索"><a href="#1-3、图的搜索" class="headerlink" title="1.3、图的搜索"></a>1.3、图的搜索</h2><h3 id="1-3-1、广度优先搜索"><a href="#1-3-1、广度优先搜索" class="headerlink" title="1.3.1、广度优先搜索"></a>1.3.1、广度优先搜索</h3><p>广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：</p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE%E7%A4%BA.4f9122d2.png" alt="广度优先搜索图示"></p><p><strong>广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列</strong> 。具体过程如下图所示：</p><p><strong>第1步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A21.c43db853.png" alt="广度优先搜索1"></p><p><strong>第2步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A22.d42ff990.png" alt="广度优先搜索2"></p><p><strong>第3步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A23.e46fdfec.png" alt="广度优先搜索3"></p><p><strong>第4步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A24.d7bbf332.png" alt="广度优先搜索4"></p><p><strong>第5步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A25.2f52a074.png" alt="广度优先搜索5"></p><p><strong>第6步：</strong></p><p><img src="https://javaguide.cn/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A26.98a33175.png" alt="广度优先搜索6"></p><h3 id="1-3-2、深度优先搜索"><a href="#1-3-2、深度优先搜索" class="headerlink" title="1.3.2、深度优先搜索"></a>1.3.2、深度优先搜索</h3><p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE%E7%A4%BA.a5e0d06f.png" alt="深度优先搜索图示"></p><p><strong>和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈</strong> 。具体过程如下图所示：</p><p><strong>第1步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A21.3c4595de.png" alt="深度优先搜索1"></p><p><strong>第2步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A22.c79a5d25.png" alt="深度优先搜索1"></p><p><strong>第3步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A23.6d7c7ecb.png" alt="深度优先搜索1"></p><p><strong>第4步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A24.89719079.png" alt="深度优先搜索1"></p><p><strong>第5步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A25.d36925bc.png" alt="深度优先搜索1"></p><p><strong>第6步：</strong></p><p><img src="https://javaguide.cn/assets/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A26.ef5280c9.png" alt="深度优先搜索1"></p><h1 id="二、堆"><a href="#二、堆" class="headerlink" title="二、堆"></a>二、堆</h1><h2 id="2-1、什么是堆？"><a href="#2-1、什么是堆？" class="headerlink" title="2.1、什么是堆？"></a>2.1、什么是堆？</h2><p>任意一个节点的值都大于等于（或小于等于）所有子节点的值</p><h2 id="2-2、堆的用途"><a href="#2-2、堆的用途" class="headerlink" title="2.2、堆的用途"></a>2.2、堆的用途</h2><p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong></p><h2 id="2-3、堆的分类"><a href="#2-3、堆的分类" class="headerlink" title="2.3、堆的分类"></a>2.3、堆的分类</h2><p>分为最大堆和最小堆</p><ul><li><strong>最大堆</strong> ：堆中的每一个节点的值都大于等于子树中所有节点的值</li><li><strong>最小堆</strong> ：堆中的每一个节点的值都小于等于子树中所有节点的值</li></ul><h2 id="2-4、堆的存储"><a href="#2-4、堆的存储" class="headerlink" title="2.4、堆的存储"></a>2.4、堆的存储</h2><p>若根结点的序号为1，对于树中任意节点i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）</p><p>堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8.03237dbe.png" alt="堆的存储"></p><h2 id="2-5、堆的操作"><a href="#2-5、堆的操作" class="headerlink" title="2.5、堆的操作"></a>2.5、堆的操作</h2><h3 id="2-5-1、插入元素"><a href="#2-5-1、插入元素" class="headerlink" title="2.5.1、插入元素"></a>2.5.1、插入元素</h3><blockquote><p>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</p></blockquote><p><strong>1.将要插入的元素放到最后</strong></p><p><strong>2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换</strong></p><h3 id="2-5-2、删除堆顶元素"><a href="#2-5-2、删除堆顶元素" class="headerlink" title="2.5.2、删除堆顶元素"></a>2.5.2、删除堆顶元素</h3><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”<strong>堆化</strong>“，堆化的方法分为两种：</p><ul><li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li><li>另一种是自顶向下堆化，元素由最顶部向下移动。</li></ul><hr><p><strong>自底向上的堆化</strong></p><p>1、将堆顶的元素也就是下标为1的元素删除</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A01.cd68b7ff.png" alt="删除堆顶元素1"></p><p>2、对比下标为2，3的元素，哪一个比较大就将他的下标变成1</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A02.59fc6629.png" alt="删除堆顶元素2"></p><p>3、一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A03.b5c78c7d.png" alt="删除堆顶元素3"></p><hr><p><strong>自顶向下(推荐使用)</strong></p><p>1、我们将最后一个元素移动到堆顶。</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A04.90633757.png" alt="删除堆顶元素4"></p><p>2、然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A05.ca1fc0c4.png" alt="删除堆顶元素5"></p><p><img src="https://javaguide.cn/assets/%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A06.9549fe90.png" alt="删除堆顶元素6"></p><h3 id="2-5-3、堆的操作总结"><a href="#2-5-3、堆的操作总结" class="headerlink" title="2.5.3、堆的操作总结"></a>2.5.3、堆的操作总结</h3><ul><li><strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li><li><strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。<strong>最好采用自顶向下堆化的方式。</strong></li></ul><h2 id="2-6、堆排序"><a href="#2-6、堆排序" class="headerlink" title="2.6、堆排序"></a>2.6、堆排序</h2><p>重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>详细过程如下图所示：</p><p>取出第一个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F1.4a22573f.png" alt="堆排序1"></p><p>取出第二个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F2.26994f33.png" alt="堆排序2"></p><p>取出第三个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F3.e411601b.png" alt="堆排序3"></p><p>取出第四个元素并堆化：</p><p><img src="https://javaguide.cn/assets/%E5%A0%86%E6%8E%92%E5%BA%8F4.2b2472be.png" alt="堆排序4"></p><p>取出第五个元素并堆化：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeEAAAEjCAMAAAAytEmDAAABMlBMVEX////a6Pz/5sxsjr8AAAD/MzMTFBbfqyfY5fkLDAy2wtPZnQPgy9zoqLS0v9DjuUwgIyajrr5/iJM0ODzovVlESU8dHyHM2eyvuspxeILzcXjE0eOptMT94sJ5gYz47M6Zo7L316GLlKHisz+gqrn8Q0TY5vrix9iPmKbe2OqDi5ctMDTc4PO7x9niwdHluMZVWmLI1ee/y93qnalmbHb1ZmxtYlfR3/KTnKpsc31ZX2f7S00YGRz63bXv2Jvtjpjzz47vzYTrzX7vyHrpyHJhaHHtxW9LT1bmuE89QUfgrzMkJyrcpx3aoA7P3O/3Wl/f0OLvhY/9PD3jvMzmsL7Hs59cYmtQVVzwfofydn758Nr36sr+5cn047fz4rTslJ/ltkg7NS+xn46fj3/dx7FaUUh/PS8lAAALSElEQVR42uzdTYrcMBCGYVE0EUELbUR2wgjfITsb/2GMsZfZTPcMM/m5/xWS9cBMq7u9kJT3ucKHLUsuVan/xbmd7Lrtxph9W+3UnhXKUfW10cvchcZf5OKb0M2LNnVfKRTgadCb67y85zu36eFJIW/PdndBPhLcbp8V8vVS61E+N+r6RSFPldW9XNdry4KcpcHMEmc2g0JuqvW1kVjN68pjnJnWjHKL0bQKGZl0kNsEPSlkw9VebuVrp5AJu8g9FquQBevkPo6Is+AWudfCizoDUy33q/ncSl6rvdzPazZNiatMkEcEw9FH2tZRHjOuCgkbXuVRr5xRJ6wyjTyq4T2dMDvL42Z2xcl60XIETUlAqupejtDXCkl61nIMTe1WmuwoxxhZiZP0tMtRdopsUzQ4OYpjT5wiHeQoQSskp9rkOBunHunpnRzH9QqpqTs5TseWOD3GS4Q/p9N3uc4bhcSctUT4fYpLWDT3i1PTLnKV//UlNuGFWo/UTLNc8fPr6Z/IhGcKtlJjO7ni1+mGhDsOLlOzhqvP8Nvb27fYhAPFPKnZGonwIzbhZlNIy+4PTdjvCmkxl0MTvrAhTo2RQxMWEk4Nz3DpWIdLx7d06dYQlTD74WzZLiphzrSyNc1RCXMuna12iUqYf0vZOuuohPk/nC/jJRI1HnmiTqt01FqWjnrp4nHnoXTcWyoddw+Lx/3h0tEDoHj08SgdvXiKRz+t0tETr3j0tSwevWlLR3/p4tEjvnjMeSges1qKx7yl4jEzrXjMPSwes0uLx/zh4jFDvHyDmSXObDiLzlJldS/X9dryAOfqpdajfG7UNT/8c/ZsdxfkI8Htlpqs3D0NenOdl/d85zY9UDZbhKqvjV7mLjT+IhffhG5etKl7lt+SnNvJrttujNm31U4t94MBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/ZgwMBAAAAACD/10ZQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhj46JAACBAIbBvX/PeGCjJHunAgAAAAAAAAAA/GNoW7PvaR9oHa63Dtdbh+utw/XW4XrrcL11uN46XG8drrcO19vDzrm0KA5EYZSCQ0hcSB7kRUITgjTBIGhoiJFsRURwaf//fzJacR4Mg3bdhTNk8i16VcdbqUOVdTtND4a7MJypPyS7XFJZZXtelnNbOutVWZ5l7PusrBJh3dZbVvm7eKUXi0UjYZv5kFhUNyvftvFzwwF46g+Zgyt64uwEcMqEq7WGmahu0+u6uYT1LIB6JpxzBbxJ2CNDKgFrHwCc7csN2y46ri1ZrU2H0PCmR8fJzNnMQSc6iwyfLanhCLnhNUNmzwyfN5vvLuIfUtr2p+E2M6rsgZUkFizMZ50AUsMVuF4VwcWc7SBMtkAhMrxHaNiGsLylMWcbcLx5AN0zw59RlKvcddNlDUGiF+sEQTEYrlywDlfJvuu6K3WuryMfVt6Bfx0N69ca3ms/JdTmbAiJUgfwJYbncJQZzqCU3rR8PdumLL0vndIL+HnG+ehowx/o9Fe3PYSqAyt+WDmAXKlctNJtkiSO0PCurht9gkTmbF4UtnoPYG7O3rjDm8xwDlWZbjdKwAYwy0tPy/ii4ajbAaWKgWjda8NzIOy0Wz1mCRSPK0ewUmoFvezWYgkNDzlAKGJX6RFqSd0SGqHhCh2nErA91AY3rQXQ6NOqU77epnYArrrAWusi0+cv8Pmk8jA2A15v2N4DCxG7BZCsdOyQKqHhlHsSc9b5jX1u+DTcOD7UfrCov4ePEOx2u2HnxhZa/pPKf89wFgCpjPV6AM+cvdC3UsOd5ezboodPcxao8+IE4RcN64HpzXAI/vduKYJf7vNvQPqssvv9lI5ebTixgKX4hD8f4WjMxnD0/RBC3xbV1ct6Mp+zpXdvBZax4U/Y37sPVcPe11nd97CTPak89NceBC827AF9rgSs/fHRDaeWZcxu+JHYvFuy7evPhaSuqqHRPRPvpoZTOA0NtavWw34utttY3dQD4fOuJdWfdHmt4Y0FYSzrPCLY6DnXxmzs3ALgnE1ZG33edZKzQ130ebXVsgwNJ8C66ABXVcAyv4DVqgJYAtXTDoDt1oH8tYZ9IDxcsxN0WnD0lhbsZXOWfg8HcFykDixFnZblVxF8GBtW61/64ZAhS71HLuoTnOzxEwfoBO+vNXzgHke0WgMav9ZwzpCTLf+tpbP5quHD3fC953AKvf/bjnvTtdYflgGHx5XbEOB4Ft54eqFhC7lhlfcAQaPkhn0JW0QAh1jC2juA00r0fjjOf779OyfFyjZ74tjz4n/yfemjTmvhZX+hrj0v8o20bpsXzfQXAP81OxkeOzsZHjs7GR47OxkeOzsZHjs7GR47OxkeOzsZHjs7GR47OxkeOzsZHjs7/T+tsWfaw2NnJ8NjZ7+1c0Y7jQJRGM4kZwxuoNldI7XVNMZYWVoEW2xaWxOujGlMhBai7VXf/y32MENLTJQwXAg7O/8Fc4z5MrbfMCDVowzLzirDsrPKsOysMiw7qwzLzirDsrPKsOysMiw7qwzLzhYans/n9fzU1ftpObFhuJXmtQ7RRNnIMJy8EmMTI+aFbviu0LyO53s2L21Wihu+AYBaDFfvp+X1KSbUxVmHHhKJsltK9bwSYiNKuwSjrShmbZRnA5pmpWHps9L/dwxX76dlr7mjhSPM2pUN2wEyel6JsPEiM7yiPFZZdpcBK0KMrDTKG25PCwy32yKGv7HbEl/XEzfBF5sIs07AMmHLQ4C1KIueV+XZLgNSwxGOvrXBycuyuDQCFwFqkxA9R7hEwq8Nn5mmeY7jiWlektH7EcDwqbU3fG+a6X8LL03zlhDtAb9pPmkNNYx+LPbG+cIsj92n60iIdQ9eXWHDk4PhBJcmDn3Ey7E2Lgbu2Ytwd8cSt6/oS8PaMcAf3m6nPT0CluNxZvgOYMBbc7SINgSW5auA4W/spxUnSea5omFEDbF5Hdd11ygmr8qzkesG3LBP6YZfxo1yrBWGAQ4hAh5fHROU/aXhrPXOAOCZNbLo9I5Q6yeGfwPA/O0YoCdg+Ht78UQ7fKlhxXkNhgqy/NTLKyHWQMN8WHBhfnmWXxgsZLcFq4MbPgM41sgpwCXpDYfXJC3vPzGMhyvWHuylsYYTijGqsHzTs2owzFWtvBUeA4F5LZwu3J//G1wdBXdaJsDZlGkmNxed9xf41LAGAO/z+TsOo6Ya9hYUE1ddHVtSi2HSpVl2QixdRCUNdwA616x1zusQMJ8bHsMh46YaJsTBbXpSiQ1xadRk2NlQzFpkl06J0D6sy27RLs1usk6eAC5Ys5PHzq/OB8O/eZu71hSw5nltomFttQpw8CjtV5k3ZjeltRjG2J6rsbulkuxk/7wj5jcPYdGdFmYIGJObRM9vueEn1n/oB6Bh8pgeyOtsdtnM6zDu0DZ7GBBWmTfA7a4mw/Zu5xPi4DnsCDzxSPa/OCHl4NEuMjwAzANhVmftK8gN9/A4GJjM8Bzg5+xyCXDaTMMb3J9jv4+LW5zl+1w9hpmfndvFL8qyuBj63TReejZv4y27NBUYHgHmFoslZLnLDN/CPi3SPtqXzTQcU561I8zyHcCtx3D+1FIvyep0H594WeUVGianWbu/8QsAnMzwcM4Nk+tUa2/J3vTxM2BeWkTA8Df20yIuu5OeRFXY/T4nzi4OZhZVDXPFi7gki1xumCRrHNdJ2U8etLNfI/Ix5z+mh3p0cX1e+2ee5OvYXmw38nNadiz8wQ238rx6oqu/APhfWWVYdlYZlp1VhmVnlWHZWWVYdlYZlp1VhmVnlWHZWWVYdlYZlp1VhmVnVT8t2fMXdEkHpCpN8mQAAAAASUVORK5CYII=" alt="堆排序5"></p><p>取出第六个元素并堆化：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeEAAABRCAMAAADSKe79AAAA3lBMVEXa6Pxsjr8AAAD/MzPgy9yAiJQTFBYLDA20v9AzNzumscEgIybX5fn8Q0RudX/Y5vrL2esdHyLE0OJbYGlESE7op7R5gIziwtJmbHa7x9jhx9e2wtPltsWTnKpVWmLR3/Kst8fuiZPydXyPmKVOU1uYorH1aG7O2+6gqrmIkZ37SUwkJyoYGRy/y9zwf4jzcXj9PD3f0OLskJssLzPb5fnc4fXjvMyirbydp7Y+Qkfd3/Hd2euMlaJze4VhZ3DH1Oavusvmr734WFznqrfqn6rrmaVKTlXe1uj2XmM6PkPPHJPiAAAIcklEQVR42uyc24raUBSGd3/IeZPJiaJIDhCDDSZXuVDB05Xg+79Qk2Wc9qJV9yrYWvd/ozB+rDX7S3ZW4jDii87/HfFFsKPZl2Bfs2vNasOa1YbfhX3NrjWrDWtWG34X9jW71qw2rFlt+F3Y1+xas4qG/SSZiV8kiuMdr7K069qW3K6n2+2Cx37MtuWRWTdf1WXxwV7pb+t1y2Fb+5KAVTfafk2D+4YdwBW/iA14rN84WqLPMmKuVgbMWHWnDdUtOOzKHNhuxuy5BPCVw25wSclg5XwgrfTphqUHiic5q3XwwTR8aECxInU2skAJFyzDC5NrOATfcDays3uGF0Egr53mn5tW/sNwHilVXgFmcTSBtXrXNgCu4RTw3DIEYnXWB5JjCqBiGZ6AaVgCyXZIq862gOXaDuDfMzwPw0IUnucbHeAUtFhL4FxdDJceYJ56yYbneVOx6Dxvd7NyDBj9p4FMvesj+Ib35KcGOnU2AY5CnACDY9gGNjzDEVBzJy2Dum3r2n1ol/6GMVY0sBQyPAGl6d02QCJ8wAxuVnaAQggXcNS7zouisJiG465raQcJ1Vm3qqT4cABbnR24+VeeYRco6116EAz2DMyK7YpkPGg49DMAWxEM77OGDNsAEr8BNoI+UwOoblcOgakQU6DhTS0mz/CYE5Cw2OnuDHScujXQMg2XoFglg22Ajiatxw23tFv5wqDTVDqD4RjISBci2n/7zO9Uvnw2AvB8w3IC4BuLTdGHs9KBBV8wDe8w5qjOWp/so4aXl4ljIvYXi3QdPgNOHA9qKxoZSf6dyn/PcNS3C5/HrmgUX6mzMZqca9g3rX1eNcBcnQXQueslsHnUcHI1nADG9W4pBH6a578C8O9V9q67dPhsw8ceRc3e4RcbYKPMLoCzYSRAYkhWXVrWpXrPJlDQPm8qG54D+/HuY/jh3qD01gJzHMXuTVormnicpxqmkmgKwWDlZOL3L2vAVGYDfCZQ7llKya0rOrqutgA+VA37l0MqGwxnl/O5StNA9OqHJPfvWnZ0hYmfa/jQg0nfJYcNgQP13KkbtobQvLRQZSVov/M5e8d4V5qSLEXDRwBZ5QPwaNgz3Bgwc1EN7wGUtysXANLUAtznGjYAJPM+GWu1NivDBCa8nrnXYQc4r3cW6z68AEyjDIGJsmGRYYxH0zWlpj06FnPap4n+fdsU5+O5hk8YY6mz7hUN/sQwv+5S8p9aWsGjhk/D9E6G5X4A13T+5/718XbWvxxoRj7drpzTUbHJmRNPQzsXZ/LgGxZFQwflVPANGxy2olH2FHBYSYqXU9b3w4Fry09hx2oqFZ/Eu27wb35f+vtE39zoL9SVduUeuHVzd93qvwB4b/Y1u9asNqxZbfhd2NfsWrPasGa14XdhX7NrzWrDmtWG34V9za41qw1rdmT1/9P63t75NicNBHH4ZhdLUQoETGMxiMFKbWopwRBr0NbwR/D7fyGXTSDOWDB3DhOQ+71IdoY+k22fu2uA9vjfc6DjUrN6ldasNnws7GF2rVltWLPa8LGwh9m1ZrVhzWrDx8IeZtea1YY1m8Vwo9HIp2vPNEM1dhiYE6uqwFab6/iSLLebVnJsZAZxUZjMLF+GDe2pPY/LEZUjBcNVAMjHcAexoMTaZ0gZF+TZENfxJFluN62kWA/xjkdmDyn9SXbW4V6dIZVTLmeHY3jkoKLheR85bijNjpQMp+2mlQTrB+PEMJGcZlZ2lgCOEJOkNLMbrrW3GK7Vdmu4iRRFww5i14qItqXZ4YCzoBVgKMGm7XIlZ7iDFDbs0XnapHnsZmVdxIFFAM7Fgjx7DjW+2fB3wzDqdC4Zxr14vDwB+PRwujL8yjDe0WNfDONCiHKFHjRelXdo2PoHw12eBHeIU8V1Z36GfU+KTdu1pA1314YjGpp0OiM8C8tLjht7tue0uvvCp+XL22i4XAR4F2+3U2ufAKd4mxhOtgB4AXDKm/PE/za6O8NDy7L6ioaDKKqK6oJoWTb9mU/krpu2y5WUYc+yHDIcr7m9eFKb2djmeOzQaUH92vHo6JLsjYaTrXeeAfwQ7wFOKuek+foJw/QV0GgUAc53eqfFY1mR9Qb0rY4Vr2siLuSvy+2mlRRrxobNeEqOEWeyv9GaE8TOttHB9FuAYlm8BHgvzkule7EsXz1hmA7XvD3Yzd4ajpAyUWN9F7GZh2FW1bN7dHQkrlugyy1W85/g2WbDwgB422bNovq8cnkDTxouA8Blo3FJp8d9NWy7SAlUR0dH5GCYZ2CSgRSLriemmQxXAL7d89Y5V5+A8rThOqxzu6+GhQhpme4qsLxIBjkZDuPnw4jTrKy/JMYjIaL1Kj3ZYvgCoPQA8Jw3O/lY+fztD8NFMtwGquNc7aNh33EcOtmIZyrXDfimNAfDnLlt+Xy3lI31u6vXO4L45mGxiU1ovkk2YpNvhWikhh9487TXQIbFx+VBXLVarf38Pewi0qAe0NiWZ5nriXwMjwYDWmJDmsNhJpabxWj9Ws1QDOk432b4GVAqgq22rr5Cavh8OXGvDTZM4l+07n8CvNxPwz1an4Mp0Y48y883zHwMs5+ZdUftZ2SrfVqoOsvYy747QWcjm9CPQLngTx1I8iYxfAEcNlw7WZX7aTjAOP1QnuUVwMrHcPqqZSEjW8BVpsJOKnurYfEy2e7v9gYASi061GPD4gN/ggGZf02P/gDKzanYrWFX0bCw+E564SmwPI9CpZ7Tdl0Fw531fRO6QVbW/M2wiPp07kdZ33kon/6x53j9dXtdPz7/UM//Pc/NGdnBfD/fp/1L5vbE8hXZasEuVPVfABwre5hda1Yb1qw2fCzsYXatWW1Ys9rwsbCH2bVmtWHNasPHwh5m15rVhjWr99M6kvwC1z+0SNUVhy0AAAAASUVORK5CYII=" alt="堆排序6"></p><h1 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h1><p>树的特点：</p><ol><li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li><li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li><li>一棵树不包含回路。</li></ol><p><img src="/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220724215505026.png" alt="二叉树"></p><ul><li><strong>节点</strong> ：树中的每个元素都可以统称为节点。</li><li><strong>根节点</strong> ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li><li><strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li><li><strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li><li><strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li><li><strong>叶子节点</strong> ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li><li><strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li><li><strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li><li><strong>节点的层数</strong> ：节点的深度+1。</li><li><strong>树的高度</strong> ：根节点的高度。</li></ul><h2 id="3-1、二叉树的分类"><a href="#3-1、二叉树的分类" class="headerlink" title="3.1、二叉树的分类"></a>3.1、二叉树的分类</h2><p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^(k+1)-1</code> 个节点（满二叉树的情况），至少有 2^(k) 个节点</p><h3 id="3-1-1、满二叉树"><a href="#3-1-1、满二叉树" class="headerlink" title="3.1.1、满二叉树"></a>3.1.1、满二叉树</h3><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。如下图所示：</p><p><img src="https://javaguide.cn/assets/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.9025b079.png" alt="img"></p><h3 id="3-1-2、完全二叉树"><a href="#3-1-2、完全二叉树" class="headerlink" title="3.1.2、完全二叉树"></a>3.1.2、完全二叉树</h3><p>除了最后一层以外，每一层都是慢的，并且最后一层或者是满的，或者是在右边缺少连续若干节点。</p><p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。</p><p><img src="https://javaguide.cn/assets/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.c4f02f51.png" alt="img"></p><p>当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。</p><h3 id="3-1-3、平衡二叉树"><a href="#3-1-3、平衡二叉树" class="headerlink" title="3.1.3、平衡二叉树"></a>3.1.3、平衡二叉树</h3><p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p><ol><li>可以是一棵空树</li><li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li></ol><p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p><h2 id="3-2、二叉树的存储"><a href="#3-2、二叉树的存储" class="headerlink" title="3.2、二叉树的存储"></a>3.2、二叉树的存储</h2><h3 id="3-2-1、链式存储"><a href="#3-2-1、链式存储" class="headerlink" title="3.2.1、链式存储"></a>3.2.1、链式存储</h3><ul><li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li><li>左节点指针 left</li><li>右节点指针 right。</li></ul><p><img src="https://javaguide.cn/assets/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91.8dfe7691.png" alt="img"></p><h3 id="3-2-2、顺序存储"><a href="#3-2-2、顺序存储" class="headerlink" title="3.2.2、顺序存储"></a>3.2.2、顺序存储</h3><p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 <code>2i</code> 的位置，它的右子节点存储在下标为 <code>2i+1</code> 的位置。</p><p>一棵完全二叉树的数组顺序存储如下图所示：</p><p><img src="https://javaguide.cn/assets/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.ec1113ca.png" alt="img"></p><h1 id="四、红黑树"><a href="#四、红黑树" class="headerlink" title="四、红黑树"></a>四、红黑树</h1><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment">漫画：什么是红黑树？</a></p><h1 id="五、布隆过滤器"><a href="#五、布隆过滤器" class="headerlink" title="五、布隆过滤器"></a>五、布隆过滤器</h1><p>传来一个数据，将这个数据利用hash函数变成二进制，然后放到一个数组中，数组中原来全是0，数据通过hash函数编程二进制之后，将数组中的对应位置编程1，下一次传入数据的时候通过hash函数计算之后去数组中对应地方寻找，如果所寻找的对应位置是1，那么这个数据就存在。</p><p>在redis中，存在redis之前 数据库之前，用来解决缓存穿透</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、图&quot;&gt;&lt;a href=&quot;#一、图&quot; class=&quot;headerlink&quot; title=&quot;一、图&quot;&gt;&lt;/a&gt;一、图&lt;/h1&gt;&lt;p&gt;图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：**G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://eliseo.top/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://eliseo.top/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-07-12T07:34:04.000Z</published>
    <updated>2022-07-24T13:56:04.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统基础"><a href="#一、操作系统基础" class="headerlink" title="一、操作系统基础"></a>一、操作系统基础</h1><h2 id="1-1-什么是操作系统？"><a href="#1-1-什么是操作系统？" class="headerlink" title="1.1 什么是操作系统？"></a>1.1 什么是操作系统？</h2><ol><li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><h2 id="1-2、什么是系统调用？"><a href="#1-2、什么是系统调用？" class="headerlink" title="1.2、什么是系统调用？"></a>1.2、什么是系统调用？</h2><p>进程在系统上的运行分为两个级别：</p><ol><li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li><li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>按功能可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能</li></ul><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220724215539929.png"></p><h2 id="1-3、操作系统的内核-Kernel"><a href="#1-3、操作系统的内核-Kernel" class="headerlink" title="1.3、操作系统的内核(Kernel)"></a>1.3、操作系统的内核(Kernel)</h2><ol><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li><li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li></ol><h3 id="1-4、中央处理器（CPU，Central-Processing-Unit）"><a href="#1-4、中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="1.4、中央处理器（CPU，Central Processing Unit）"></a>1.4、中央处理器（CPU，Central Processing Unit）</h3><ol><li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li><li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li><li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li></ol><h2 id="1-5、Kernel-vs-CPU"><a href="#1-5、Kernel-vs-CPU" class="headerlink" title="1.5、Kernel vs CPU"></a>1.5、Kernel vs CPU</h2><ol><li>操作系统的CPU属于硬件，Kernel属于操作系统层面</li><li>CPU主要提供运算、处理各种指令的能力；而内核主要负责系统管理</li></ol><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220724215551114.png" alt="Kernel_Layout"></p><h1 id="二、进程和线程"><a href="#二、进程和线程" class="headerlink" title="二、进程和线程"></a>二、进程和线程</h1><h2 id="2-1、进程和线程的区别"><a href="#2-1、进程和线程的区别" class="headerlink" title="2.1、进程和线程的区别"></a>2.1、进程和线程的区别</h2><p>线程是进程的一个小单位，一个进程中可能有多个线程，进程之间是相互独立的，但是线程之间却不是，可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h2 id="2-2、进程的状态"><a href="#2-2、进程的状态" class="headerlink" title="2.2、进程的状态"></a>2.2、进程的状态</h2><p>创建、就绪、运行、阻塞、结束</p><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712164004769.png" alt="进程的状态"></p><h2 id="2-3、进程间的通信方式"><a href="#2-3、进程间的通信方式" class="headerlink" title="2.3、进程间的通信方式"></a>2.3、进程间的通信方式</h2><ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于<code>具有亲缘关系的父子进程间或者兄弟进程之间的通信</code>。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，<code>可以实现本机任意两个进程通信。</code></li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于<code>通知接收进程某个事件已经发生；</code></li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符(队列ID)标识。管道和消息队列的通信数据都是<strong>先进先出</strong>的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是<strong>消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除</strong>。消息队列可以<code>实现消息的随机查询</code>,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要<code>用于实现线程之间的互斥与同步。</code></li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是**<code>最有用</code>**的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用<code>于在客户端和服务器之间通过网络进行通信</code>。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程</li></ol><h2 id="2-4、线程之间的同步方式"><a href="#2-4、线程之间的同步方式" class="headerlink" title="2.4、线程之间的同步方式"></a>2.4、线程之间的同步方式</h2><p><strong>1、互斥量：</strong>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p><strong>2、信号量：</strong> 允许同一时刻多个线程访问同一个资源，但是线程数量要有一个限制</p><p><strong>3、事件：</strong> 通过通知操作的方式来保持多线程同步</p><h2 id="2-5、进程的调度算法"><a href="#2-5、进程的调度算法" class="headerlink" title="2.5、进程的调度算法"></a>2.5、进程的调度算法</h2><ul><li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列调度算法：</strong>(<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/449587?fr=aladdin)%EF%BC%9A">https://baike.baidu.com/item/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/449587?fr=aladdin)：</a>  多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h2 id="2-6、死锁产生的条件"><a href="#2-6、死锁产生的条件" class="headerlink" title="2.6、死锁产生的条件"></a>2.6、死锁产生的条件</h2><ul><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul><h2 id="2-7、解决死锁的方法"><a href="#2-7、解决死锁的方法" class="headerlink" title="2.7、解决死锁的方法"></a>2.7、解决死锁的方法</h2><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ul><h3 id="2-7-1、死锁的预防"><a href="#2-7-1、死锁的预防" class="headerlink" title="2.7.1、死锁的预防"></a>2.7.1、死锁的预防</h3><p>一般是破坏死锁产生的条件的第二个和第四个条件</p><p><strong>1、静态分配</strong>，负责破坏第二个条件，当一个进程在执行之前申请到他所需要的所有资源，并且所有资源都满足之后才开始执行。 <strong>严重降低了资源利用率</strong></p><p><strong>2、层次分配策略</strong>，将所有的资源按层次分配，当一个进程得到某一次的一个资源以后，只能申请再高一级的资源；当一个进程要释放某层的一个资源，那么他就只能通过先释放高层的资源以后再释放底层级的资源，</p><h3 id="2-7-2、死锁的避免"><a href="#2-7-2、死锁的避免" class="headerlink" title="2.7.2、死锁的避免"></a>2.7.2、死锁的避免</h3><p>银行家算法：<a href="https://blog.csdn.net/qq_33414271/article/details/80245715">一句话+一张图说清楚——银行家算法</a></p><p>有一个Available(空闲资源数量)，当有进程申请资源的时候，Available尝试着分配给进程p1，如果没有出现死锁，那么我就继续往下分配给接下来的p2….，如果出现死锁，那么我就不分配给p1，尝试着分配给p2。若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–&gt;回收（Work+已分配给P0的A0=Work）–&gt;分配给P3–&gt;回收(Work+A3=Work) –&gt; 分配给P2 –&gt; ······满足所有进程）。</p><p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p><h3 id="2-7-3、死锁的检测"><a href="#2-7-3、死锁的检测" class="headerlink" title="2.7.3、死锁的检测"></a>2.7.3、死锁的检测</h3><p>资源分配图化简：</p><blockquote><p>第一步：先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞（“不阻塞”即：系统有足够的空闲资源分配给它）的； 第二步：把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来； 第三步：看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点； 第四步：最后，所有的资源和进程都变成孤立的点。这样的图就叫做“可完全简化”； 如果一个图可完全简化，则不会产生死锁；如果一个图不可完全简化（即：图中还有“边”存在），则会产生死锁。这就是“死锁定理”。 </p></blockquote><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712221401480.png"></p><p>第一步：先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。<br>第二步：再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。<br>第三步：看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。<br>第四步：再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示：</p><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712221408659.png"></p><p>第五步：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图： </p><p><img src="/2022/07/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220712221423591.png"></p><p>因此不会产生死锁。</p><h3 id="2-7-4、死锁的解除"><a href="#2-7-4、死锁的解除" class="headerlink" title="2.7.4、死锁的解除"></a>2.7.4、死锁的解除</h3><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p><ol><li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li><li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li><li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除</li></ol><h1 id="三、操作系统内存管理"><a href="#三、操作系统内存管理" class="headerlink" title="三、操作系统内存管理"></a>三、操作系统内存管理</h1><hr><h2 id="3-1、操作系统的内存管理主要是干什么？"><a href="#3-1、操作系统的内存管理主要是干什么？" class="headerlink" title="3.1、操作系统的内存管理主要是干什么？"></a>3.1、操作系统的内存管理主要是干什么？</h2><p>主要负责的是内存的分配与回收，以及地址转换(就是将逻辑地址转换为对应的物理地址)</p><hr><h2 id="3-2、操作系统的内存管理机制有哪些？"><a href="#3-2、操作系统的内存管理机制有哪些？" class="headerlink" title="3.2、操作系统的内存管理机制有哪些？"></a>3.2、操作系统的内存管理机制有哪些？</h2><p>分为<strong>连续分配管理机制</strong>以及<strong>非连续分配管理机制</strong>两种</p><p><code>连续分配管理机制</code>：</p><ul><li>块式管理：将内存划分为几个固定大小的块，每一个块只包含一个进程，当有进程需要内存的时候，就分配给它一个块；但是如果这个程序只需要一点点内存的话，这个块中就会有一些内存没有被利用，这些没有被利用但是被分配出去的内存就被称为碎片。</li></ul><p><code>非连续分配管理机制</code>：</p><ul><li>页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li>段式管理：段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息。 段式管理通过段表对应逻辑地址和物理地址。</li><li>段页式管理机制：段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。</li></ul><p><strong>逻辑地址：</strong> 是用户可以看见的地址</p><p><strong>物理地址：</strong> 对应的是CPU地址上传来的地址，是在内存条中相对应的地址</p><p>逻辑地址就相当于是windows系统上一个文件 例如：G:\A-学习笔记\Android开发 物理地址则是这个文件在CPU上处于那里，物理地址不可见，逻辑地址可见</p><hr><h2 id="3-3、快表和多级页表"><a href="#3-3、快表和多级页表" class="headerlink" title="3.3、快表和多级页表"></a>3.3、快表和多级页表</h2><p><strong>快表：</strong>一种高速缓存器(Cache)，其中的内容是页表的一部分内容或者页表的全部内容</p><p><strong>使用快表之后的地址转换过程是：</strong></p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><hr><p><strong>页表就是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。</strong></p><p><strong>⻚表的作⽤</strong>是将虚拟地址转换为物理地址</p><hr><p><strong>多级页表：</strong></p><p><strong>可以压缩页表占用的内存</strong>，将一个内存(4GB)全部分为一级页表(4KB，占用4B)之后，需要1M个页表项，每一个页表占用4MB的内存空间；但是当我们使用二级页表之后，一级页表映射4MB，二级页表映射4KB，这个时候就会有1K个一级页表，每一个一级页表对应1K个二级页表，但是一级页表不会全部被使用，所以也不需要这个一级页表对应的二级页表，假设只有20%的页表被使用，那么页表占用空间就只有0.804MB（1K * 4B + 0.2 * 1K * 1K * 4B = 0.804MB）</p><hr><h2 id="3-4、分页机制和分段机制有哪些共同点和区别呢？"><a href="#3-4、分页机制和分段机制有哪些共同点和区别呢？" class="headerlink" title="3.4、分页机制和分段机制有哪些共同点和区别呢？"></a>3.4、<strong>分页机制和分段机制有哪些共同点和区别呢？</strong></h2><ol><li>共同点：<ul><li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul></li><li>区别：<ul><li><strong>页的大小是固定的</strong>，由操作系统决定；而<strong>段的大小不固定</strong>，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要</li></ul></li></ol><h2 id="3-5、逻辑地址和物理地址"><a href="#3-5、逻辑地址和物理地址" class="headerlink" title="3.5、逻辑地址和物理地址"></a>3.5、逻辑地址和物理地址</h2><p>在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址</p><h2 id="3-6、CPU寻址"><a href="#3-6、CPU寻址" class="headerlink" title="3.6、CPU寻址"></a>3.6、CPU寻址</h2><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。</p><hr><p><strong><code>为什么要有虚拟地址空间？</code></strong></p><p><strong>没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存，容易造成对操作系统的破坏，而且根本无法同时运行两个以及两个以上的程序。</strong>微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。</p><p><img src="https://img-blog.csdnimg.cn/72ab76ba697e470b8ceb14d5fc5688d9.png"></p><h1 id="四、虚拟内存"><a href="#四、虚拟内存" class="headerlink" title="四、虚拟内存"></a>四、虚拟内存</h1><h2 id="4-1、什么是虚拟内存？"><a href="#4-1、什么是虚拟内存？" class="headerlink" title="4.1、什么是虚拟内存？"></a>4.1、什么是虚拟内存？</h2><p><strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。<strong>虚拟内存技术：</strong>即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。</p><p><strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间。</strong></p><h2 id="4-2、局部性原理"><a href="#4-2、局部性原理" class="headerlink" title="4.2、局部性原理"></a>4.2、局部性原理</h2><p>表现在以下两个方面：</p><p><strong>1、时间局部性：</strong>由于存在循环，可能一个指令一个数据被执行或者被访问之后过一段时间就再次执行或者访问</p><p><strong>2、空间局部性：</strong>程序在一段时间内所访问的地址，可能集中在一定的范围之内</p><h2 id="4-3、虚拟存储器"><a href="#4-3、虚拟存储器" class="headerlink" title="4.3、虚拟存储器"></a>4.3、虚拟存储器</h2><ul><li>虚拟存储器的定义<ul><li>虚拟存储器是指<strong>仅把作业的一部分装入内存便可运行作业</strong>的存储管理系统，</li><li>它具有<strong>请求调入功能</strong>和<strong>置换功能</strong>，能从逻辑上对内存容量进行扩充，</li><li>其逻辑容量由外存容量和内存容量之和决定，其<strong>运行速度接近于内存</strong>，<strong>成本接近于外存</strong>。</li></ul></li></ul><h2 id="4-4、虚拟内存的技术实现"><a href="#4-4、虚拟内存的技术实现" class="headerlink" title="4.4、虚拟内存的技术实现"></a>4.4、虚拟内存的技术实现</h2><p>虚拟内存的技术实现主要建立在离散分配的内存管理方式的基础上，所以主要有三种方式：</p><ol><li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。<strong>请求分页是目前最常用的一种实现虚拟存储器的方法</strong>。请求分页存储管理系统中，在作业开始运行之前，<strong>仅装入当前要执行的部分段即可运行</strong>。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，<strong>增加了请求调段功能、分段置换功能</strong>。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li></ol><h2 id="4-5、页面置换算法"><a href="#4-5、页面置换算法" class="headerlink" title="4.5、页面置换算法"></a>4.5、页面置换算法</h2><p><a href="https://www.jianshu.com/p/18285ecffbfb">页面置换算法</a></p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下d的若千页面中哪个是未来最长时间内不再被访问的，<strong>因而该算法无法实现</strong>。一般作为衡量其他置换算法的方法。**(填数的时候，当数字不在框中的时候，选择该数字后面中出现最远的数字加以替换)**</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> ： 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。 <strong>算法性能差</strong> (填数的时候，当数字不在框中时，横着找最长的连续数字将这个数字划掉，然后将新的数字填入)</li><li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。(当数字不在框中的时候，选择最前面的数字将其划掉，然后将新的数字填入，当数字在框中的时候，将前面相同的数划掉，这一列不写数字。)</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> ：该置换算法选择在之前时期使用最少的页面作为淘汰页</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、操作系统基础&quot;&gt;&lt;a href=&quot;#一、操作系统基础&quot; class=&quot;headerlink&quot; title=&quot;一、操作系统基础&quot;&gt;&lt;/a&gt;一、操作系统基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是操作系统？&quot;&gt;&lt;a href=&quot;#1-1-什么是操作系统？&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://eliseo.top/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://eliseo.top/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-07-12T01:33:38.000Z</published>
    <updated>2022-07-24T13:58:12.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、OSI和TCP-IP网络分层"><a href="#一、OSI和TCP-IP网络分层" class="headerlink" title="一、OSI和TCP/IP网络分层"></a>一、OSI和TCP/IP网络分层</h1><h2 id="1-1、OSI七层协议"><a href="#1-1、OSI七层协议" class="headerlink" title="1.1、OSI七层协议"></a>1.1、OSI七层协议</h2><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215655470.png" alt="OSI七层协议"></p><p><strong>有些功能在多个层中重复出现。</strong></p><h2 id="1-2、TCP-IP-四层模型"><a href="#1-2、TCP-IP-四层模型" class="headerlink" title="1.2、TCP/IP 四层模型"></a>1.2、TCP/IP 四层模型</h2><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p><img src="https://javaguide.cn/assets/TCP-IP-4-model.a534f46f.png" alt="TCP-IP-4-model"></p><hr><p><strong><code>应用层</code></strong></p><p><strong>位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong></p><hr><p><strong><code>传输层</code></strong></p><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong>     </p><p><strong>运输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><p><img src="https://javaguide.cn/assets/transport-layer.583ce71a.png" alt="transport-layer"></p><hr><p><strong><code>网络层（网际层/IP层）</code></strong></p><p><strong>网络层负责为分组交换网上的不同主机提供通信服务，网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p><hr><p><strong><code>网络接口层</code></strong></p><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><ol><li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li><li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li></ol><h2 id="1-3、为什么要分层？"><a href="#1-3、为什么要分层？" class="headerlink" title="1.3、为什么要分层？"></a>1.3、为什么要分层？</h2><p>1、各层之间相互独立</p><p>2、提高了整体灵活性</p><p>3、大问题化小</p><h1 id="二、Http-vs-HTTPS"><a href="#二、Http-vs-HTTPS" class="headerlink" title="二、Http vs HTTPS"></a>二、Http vs HTTPS</h1><h2 id="2-1、HTTP-默认端口80"><a href="#2-1、HTTP-默认端口80" class="headerlink" title="2.1、HTTP(默认端口80)"></a>2.1、HTTP(默认端口80)</h2><p>全称：超文本传输协议，顾名思义：就是用来规范超文本(html代码)的传输。具体来说，主要是来规范浏览器和服务器端的行为的，并且HTTP是一个无状态的协议，也就是服务器不需要维护客户端发来的请求的消息。</p><hr><p><strong><code>通信过程：</code></strong></p><ol><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li><li>服务器接收来自浏览器的 TCP 连接。</li><li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li><li>关闭 TCP 连接。</li></ol><hr><p><strong><code>优点</code></strong></p><p>扩展性强、速度快、跨平台支持性好</p><h2 id="2-2、HTTPS-默认端口443"><a href="#2-2、HTTPS-默认端口443" class="headerlink" title="2.2、HTTPS(默认端口443)"></a>2.2、HTTPS(默认端口443)</h2><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p><hr><p><strong><code>优点：</code></strong></p><p>保密性好、信任度高。</p><h2 id="2-3、HTTPS-的核心—SSL-TLS协议"><a href="#2-3、HTTPS-的核心—SSL-TLS协议" class="headerlink" title="2.3、HTTPS 的核心—SSL/TLS协议"></a>2.3、HTTPS 的核心—SSL/TLS协议</h2><p><strong><code>SSL与TLS的区别</code></strong></p><p>SSL刚发行就是3.0，然后在SSL3.0的基础上进行了进一步升级 就变成<code>TLS1.0</code>    </p><hr><h3 id="2-3-1、工作原理"><a href="#2-3-1、工作原理" class="headerlink" title="2.3.1、工作原理"></a>2.3.1、工作原理</h3><hr><p><strong><code>非对称加密：</code></strong></p><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。</p><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215733002.png"></p><p><strong>单向函数：</strong>已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p><p><strong>单向陷门函数：</strong>一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p><hr><p><strong><code>对称加密</code></strong></p><p>由于非对称加密的计算代价大，效率低，所以实际上使用的是对称加密。</p><p><strong>对称加密：</strong>通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p><p><img src="https://javaguide.cn/assets/symmetric-encryption.20454cea.png" alt="img"></p><hr><p><strong><code>证书颁发机构</code></strong></p><p>为了公钥传输的信赖性问题，第三方机构应运而生——<strong>证书颁发机构</strong>（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>。</p><p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p><hr><p><strong><code>数字签字</code></strong></p><p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能</p><blockquote><p>CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p><p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p><p>客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p></blockquote><p>带有证书的公钥传输机制如下：</p><ol><li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li><li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li><li>S 获得 CA 颁发的证书，将该证书传递给 C。</li><li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li><li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li></ol><p><img src="https://javaguide.cn/assets/public-key-transmission.a8809fd8.png" alt="img"></p><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220712110017350.png"></p><h1 id="三、HTTP-1-0-vs-HTTP-1-1-应用层"><a href="#三、HTTP-1-0-vs-HTTP-1-1-应用层" class="headerlink" title="三、HTTP 1.0 vs HTTP 1.1(应用层)"></a>三、HTTP 1.0 vs HTTP 1.1(应用层)</h1><h2 id="3-1、缓存处理"><a href="#3-1、缓存处理" class="headerlink" title="3.1、缓存处理"></a>3.1、缓存处理</h2><h3 id="3-1-1、HTTP-1-0"><a href="#3-1-1、HTTP-1-0" class="headerlink" title="3.1.1、HTTP/1.0"></a>3.1.1、HTTP/1.0</h3><p>如果服务器接收到了请求头，并判断<code>If-Modified-Since</code>时间后，资源确实没有修改过，则返回给客户端一个<code>304 not modified</code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。</p><p><img src="https://javaguide.cn/assets/HTTP1.0cache1.2f2b7eac.png" alt="HTTP1.0cache1"></p><p><img src="https://javaguide.cn/assets/HTTP1.0cache2.7430070e.png" alt="HTTP1.0cache2"></p><h3 id="3-1-2、HTTP-1-1"><a href="#3-1-2、HTTP-1-1" class="headerlink" title="3.1.2、HTTP/1.1"></a>3.1.2、HTTP/1.1</h3><p>HTTP/1.1的缓存机制在HTTP/1.0的基础上，大大增加了灵活性和扩展性。基本工作原理和HTTP/1.0保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是<code>Cache-Control</code></p><h2 id="3-2、连接方式"><a href="#3-2、连接方式" class="headerlink" title="3.2、连接方式"></a>3.2、连接方式</h2><p><strong>HTTP/1.0 默认使用短连接</strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。</p><p><strong>为了解决 HTTP/1.0 存在的资源浪费的问题， HTTP/1.1 优化为默认长连接模式 。</strong> 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该TCP连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p><p>有必要说明的是，HTTP/1.0仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在HTTP/1.1中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p><p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p><p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p><h2 id="3-3、Host头处理"><a href="#3-3、Host头处理" class="headerlink" title="3.3、Host头处理"></a>3.3、Host头处理</h2><p>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，但是HTTP/1.0并没有考虑这个问题，假设我们有一个资源URL是<a href="http://example1.org/home.html%EF%BC%8CHTTP/1.0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%AD%EF%BC%8C%E5%B0%86%E4%BC%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E6%98%AF%60GET">http://example1.org/home.html，HTTP/1.0的请求报文中，将会请求的是`GET</a> /home.html HTTP/1.0`.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p><p>因此，HTTP/1.1在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">GET /home.html HTTP/1.1<br>Host: example1.org<br></code></pre></td></tr></table></figure><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p><h2 id="3-4、带宽优化"><a href="#3-4、带宽优化" class="headerlink" title="3.4、带宽优化"></a>3.4、带宽优化</h2><h3 id="3-4-1、状态码100"><a href="#3-4-1、状态码100" class="headerlink" title="3.4.1、状态码100"></a>3.4.1、状态码100</h3><p>HTTP/1.1中新加入了状态码<code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应，过程如下图：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYUAAADSCAMAAACSASyBAAAA4VBMVEX///8AAADg4OAfHx+enp6goKDnplIAgsb/46Wl4////8ZeXl7G//9SpucAVaViYmLGggD/x4SEx//n/////+elVQCEAAAcHBwAAISjo6NSAFJSAAAAAFJSAISEAFLAwMA6OjqEAISlVVLv7+8WFhZSpsjn46VSVaXnx4R+fn7n4//n/+fG/8aEwefG46XGx4TGglKl4+cAgqWZh5HGgoSlVYSlggCEggBSVQDn5Of/4+fXzcyP0cZSgsalyqVSgoQAVVLnx6WEpqXnpoTGplJRUlHGx//n/8aEVaWlpoSEglJdQquRAAALx0lEQVR42uydiZbSMBSGE0ebKZIx7QCDgo77vu/77jke3/+BzL1Z2g7IMuAQpv93BFq6eMyXm7SJ3AoAAAAAAAAAAAAAAAAAAAAAAAAAAPA/MVo02b3cjcuZDgt7+wLUMesskd4PqY9YGKlq+VIuRDHskoX2msikRXcG0sHFU0jdLDRpGXbd5zhf4txNyrhhnNeNw4L9h/f61kIZGg8u9YiqVVf6pJVlzi06g2CU/w4jAyzWNU+w0LBgl6i0uNby6jhf0UJnMM4bFpSIFCG8VCE9sMBRUNrX3v7uyMXEsLtSi8RG6xV/wkJYbHsPzW03WzC0QOHApTf+OJC0tEosiCJW74zCa9ICtVcko+3EWJisw0dKx2j79VKVlXt5Y8u/oHNNs0Dr2d5dyfhIayPBQmyYq44hIxGxs67QYgn4+MqnkTVcn+zEtDskgoWPHA1GxTJjilg7d0e3+sdotQtJRjPS67v/RizQy6iwpb0EC4/c5VEZvlZHdrPFSO3Rsl2OqkWE1dssa+5znvV1r1+7pWglsXfm63VbO6lIKnw99cVjlr2ULBotftRcwUFo3bi+qTNoq4XQO/OfUFPrd3Gm3k8XbGZhuLGvLrT4vYIFf7mUw0K0YEvsTSwzE5vxVe4XJi1QwE3uAgtGCW/BtjtlqKDDrl8oV7pfaFpgq9Maredtt0Dl4i2Y8VtXU01sc4pVRjAm+wXqd6bd1rU+Fmw5ewuG7qFkaV+6urLXYo0tEofWJFWImNbetKnOQI5z+8ZxMHkxOhkL7SwoAAAAAAAAAAAAAAAAAABsBRe2GXFaODi/veyI08LBRbGtnIWFBICFFICFFICFFICFFICFFICFFICFFICFFICFFICFFICFFICFFICFY7D7aUo+rUwJo2o/hjEKFmam/3EFZaQjZnQY51ktW4Ep7VvnSt4oZ8f716rKcDDshq29+8ad/J2RChYWs1D/JW+vr+NGTnUjOte6nGWlspDJWK6967mPhSqRTVTpvithYTULXI0LesmvtENI/vRWiQojPboRKZUco2FhZQuZtl+WvANTUB6UmB1CNfqFTPu0cpzJrPdtJEtYWNVCIcvQ5lQWWE7VQ2QyUtqjlWuwCnnrfvxpPCzMT5E43ULMcbJ7Z3+mhZBelD+4E8+e96lTCMDCarHAFErMsTCqbPIJpLJdMi81O2tYOL4FU4olYkGYcc5mqvpvlSAWVrLA16lLxIKRJX0XfoUfsxO1xsKHdVuId8ezLRTfYyxwrWcLVQLeQlJmTVo+SQsfxIY43Dn3PyxkeiI1TcOCVI0WyVuoNnP5c5bTk7Rw7+qh2AxX5cG5Ex1HYmclFT/fNasqYWBsi3Tlg2SfmIUbUm7Iw6GU1gPGVJl7clMerkr2AAsuGNbr4d25BSH/7GGbLdw8tx5+yfV6ONxZkAPp2Lm5xRbkznq4Kb2GM+JkcbFwcBYtkmueN9I13HAOFumdi7Io/ZiopiFSfXS4YW9/1iwaX942r03rx5cJWDjcgAPmnncw30LvVfdpTsXGZXnnwbeRioPWVOzzZ9He0fxPJh2kYO9Bv6y8TMLmHl/KT8rC1Q1dIt24SQ4Ws/Bi/6V/mgmPmdJQj33VR97mz6Lx0QXlseRIetQvszk53V92f5yUhUNysAnOkoMFLfRv9XWwQG9+wMjHAg1Pz5xFcw7+5CSntI0THdqzFpTXNp3O7wevuid173woNs5CvXMhG5RNC7Nn0Th9731rSfOo3fuf47wXY4G/o1HVjCfahg/9aqF3H5360bxlLbhYqAZNmy3S7Fm0ekZlGqqz+h5UsUBFzrubYbcY5361HWOqx7LwcDB+dj2nPoBs+DE9ioU5s2iVM1onarFgj6XM47TTl5EWfhUWppP5OYGyM3h+PzY/i8yixQhiOXxg+Ax7lmFY26+2ZH5hSQvUTlAlZxlqspuYM4vGFjLFFvjN7mQjymhTukjRbJIF8ios/ItgoeQR6tAe0Q3B3Fk0tmA0C+AT2Y7dbjXOrBk+GefuYThK+FVYmGEhk+O3fFXk7n6Hj0dqgVk0skBVXIU+pNen8icvheJM8IbuJEhkGVZh4V8W/FVkSbduBHewaoFZNG7CtGvNKChsST/NXXQ8/TzSFDLKDLukLKzCwjQMl2AYTqo9sKCQ43zmLFrjYTeFVDYejPYHpjKat3kwppoCsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACsJACBxfPbCunyYLcXk6PhTPbjAAAAAAAAAAAAAAAAAAAAGgrZ7cZcVo42NlixGkB/wcjBWAhBWAhBWAhBWAhBdKwYDMCwMIG4IxvFdmwCwsL4tO9UFKXkXQ86kuH6gyqNFUuY0mmZtR2U8bEGhUaFpaxEJ+sEPLW8saYMinTjQfm1Z+kR7JUETPiUhoT9Atrt7B7iXPrNR+Yx0/Si0GRKd8cFdGC0XwCWFifhZBvNezAT9L7t4XH1kOm7No4h4U1WOBttmQLJfwOkaMWbo/oiaxs4eGgpFPQk2VgYSEL0jHdQmjqhSnnW6D0eWzhzr7RtNm6Rb+wjlioHl67sAVqlWwQ2IPtBlhYnwWq3ktY4Cyg9pRWByys0UKmxeL9gtF8pFFG40p1nRae5rMsDKR0scDXSO6iVrMdWFifhSqjs1Fxo/jXlSov+WVY+Nveua22DQRhWOvSXZx4zUjErVOoHXBaaBtIQ5Le9KYXPdD3f6HuP3tA0ZrESiyzcufHlrVmpYv5NHuaFXNYsclJKeNmEnCOKCMUxiahUIKEQgkSCiVIKJSg4ils/jcKm6o4rS8mA1HAqP8xnfxuFb73mACQeQmFyWlxmyXXF+p0mBYJkZvpU7O6JD0/CAUwUG+rsuQYKDUZiIL+8a44Co6BUmW5AjOAKwxAIWbX7CS4C+ZH2B9HztCDH41EGEwCB90K7ddhkkyo4X/n30zFF5qeFJiBuqwKEhhA68nuujzvs4qEfiFLcBcWlsigBr4wdMPGjxSwmIRrPQRUsgjKcdoejTCb8hl6cMMeFMAAup3sR5s95Wzur90pkGFL5gnuYNTIKQJ7SAGW7jQ+uBXwoSpbn6z/t0euc7VnfSrfF8LznCe4S0n1UuhZqY4voK2yVfSb1kKsNv6WZPgqtFEj94WB+wVSLLs1wR0K6BganJjMFzwom1OgRCH40/j7hcHHSN4Xtie4g+XdB9ZFlRYFYgpM45EWyX2OZYwU5wtDUsgT3HG/APM7o+Jv+APjQE/s6vp+ITkB0JHJemfUReEY5gvDz53zBHd49kOKYeUszrtXjUfhCvOfiC6nEE4+UtVhpFrzLtcjmTvLOtL4dCQURi6hUIKEQgkSCiXo8BSwIVIovJgClijmf1bTsKmoLettXHd3F2mcRrXTaGueZwuF8x7Gt26+oLFIxPuyJ4vlLDcsU0ApmZ4rx6lCSzxn5jl2DEh8WVihsBMFNl0wLJluJJRdY3mNY4w1WK1iMeBJQjltzWuEwm4U8I4B//LhAZ90rp09oy/AMcgGn9CBAi6N3Mjik7avViQUntTX6dn91RvVlgmWT8/4ye37q9VfxdpCIW6Wx4IRB3zwrgPYkqlqW+lGKOyk6AbUtAY917wTHrrDu4JdX6iBxFP4iJgpSJgUoAAF6Z2fQYGU1XigbTAitsCzRWvbGiMlCnhrylMwQFhzJAKYgJKMu4EDIxT6CD1uA4NWtLwJ0U1nZr++ejdrjZFyCtqEuClqnd3PqEHBUXA3EQp9HMGNZBqGESNuNvW6+KM9J8spWD8salDwzZo2oV8QCv1ABAr8bGMvTKCAIoJnqykZ/0pPt1/AlfxO7YdFEyiAgPvib6HQkwI84Rf6WJgzUoDQ5K9uPhPaf3eO1sv7AhABDDdgoBMoYLrHvTMZodCTAvm9Q3FODAoJENuUj2Q7I1WcQemEZIz0PAp1DEtioLn11UDKF5FQV6GtgnNEWU+BlLuNUBirhEIJEgolSCiUIKFQgoRCCTomCq9GrOpY9HrMqkQikUgkEolEIpFIJOroHxA0Ou5lMYdmAAAAAElFTkSuQmCC" alt="HTTP1.1continue1"></p><p><img src="https://javaguide.cn/assets/HTTP1.1continue2.7d63532b.png" alt="HTTP1.1continue2"></p><p>然而在HTTP/1.0中，并没有<code>100 (Continue)</code>状态码，要想触发这一机制，可以发送一个<code>Expect</code>头部，其中包含一个<code>100-continue</code>的值</p><h1 id="四、TCP三次握手与四次握手"><a href="#四、TCP三次握手与四次握手" class="headerlink" title="四、TCP三次握手与四次握手"></a>四、TCP三次握手与四次握手</h1><p><strong>简单示意图：</strong></p><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215756378.png" alt="三次握手"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h2 id="4-1、为什么要三次握手"><a href="#4-1、为什么要三次握手" class="headerlink" title="4.1、为什么要三次握手"></a>4.1、为什么要三次握手</h2><p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双方收发功能都正常，缺一不可。</p><h2 id="4-2、第-2-次握手传回了-ACK，为什么还要传回"><a href="#4-2、第-2-次握手传回了-ACK，为什么还要传回" class="headerlink" title="4.2、第 2 次握手传回了 ACK，为什么还要传回"></a>4.2、第 2 次握手传回了 ACK，为什么还要传回</h2><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p><h2 id="4-3、为什么要四次握手？"><a href="#4-3、为什么要四次握手？" class="headerlink" title="4.3、为什么要四次握手？"></a>4.3、为什么要四次握手？</h2><p><img src="/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220724215807607.png" alt="四次握手"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ul><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、OSI和TCP-IP网络分层&quot;&gt;&lt;a href=&quot;#一、OSI和TCP-IP网络分层&quot; class=&quot;headerlink&quot; title=&quot;一、OSI和TCP/IP网络分层&quot;&gt;&lt;/a&gt;一、OSI和TCP/IP网络分层&lt;/h1&gt;&lt;h2 id=&quot;1-1、OSI七层</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://eliseo.top/2022/07/10/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://eliseo.top/2022/07/10/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-10T13:54:52.000Z</published>
    <updated>2022-07-11T10:29:00.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Interface"><a href="#一、Interface" class="headerlink" title="一、Interface"></a>一、Interface</h1><p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p><p>interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p><ol><li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li><li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li></ol><hr><p><strong>接口与类的区别</strong></p><ol><li>interface 和 class 的区别，好像是废话，主要有：<ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li></ul></li><li>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</li></ol><p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p><h1 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h1><h2 id="2-1、语法格式："><a href="#2-1、语法格式：" class="headerlink" title="2.1、语法格式："></a>2.1、语法格式：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(parameters) -&gt; expression 或<br>(parameters) -&gt;&#123; statements; &#125;<br></code></pre></td></tr></table></figure><ul><li>左侧：指定了Lambda表达式需要的所有参数</li><li>右侧：制定了Lambda体，即Lambda表达式要执行的功能。</li></ul><h2 id="2-2、代替匿名内部类："><a href="#2-2、代替匿名内部类：" class="headerlink" title="2.2、代替匿名内部类："></a>2.2、代替匿名内部类：</h2><p><strong>1.<code>Runnable</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;The runable now is using!&quot;</span>);<br>            &#125;<br>&#125;).start();<br><span class="hljs-comment">//用lambda</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();<br></code></pre></td></tr></table></figure><p><strong>2.<code>Comparator</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; strings = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>Collections.sort(strings, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>    <span class="hljs-keyword">return</span> o1 - o2;&#125;<br>&#125;);<br><br><span class="hljs-comment">//Lambda</span><br>Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);<br><span class="hljs-comment">//分解开</span><br>Comparator&lt;Integer&gt; comperator = (Integer o1, Integer o2) -&gt; o1 - o2;<br>Collections.sort(strings, comperator);<br></code></pre></td></tr></table></figure><p><strong>3.<code>Listener</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>();<br>button.addItemListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">itemStateChanged</span><span class="hljs-params">(ItemEvent e)</span> &#123;<br>   e.getItem();<br>&#125;<br>&#125;);<br><span class="hljs-comment">//lambda</span><br>button.addItemListener(e -&gt; e.getItem());<br></code></pre></td></tr></table></figure><h2 id="2-3、方法的引用"><a href="#2-3、方法的引用" class="headerlink" title="2.3、方法的引用"></a>2.3、方法的引用</h2><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><p>目标引用放在 <code>::</code> 之前，目标引用提供的方法名称放在 <code>::</code> 之后，即 <code>目标引用::方法</code>。</p><h1 id="三、Stream"><a href="#三、Stream" class="headerlink" title="三、Stream"></a>三、Stream</h1><h2 id="3-1、Stream操作分类"><a href="#3-1、Stream操作分类" class="headerlink" title="3.1、Stream操作分类"></a>3.1、Stream操作分类</h2><p>**<code>主要是对集合的操作，</code>**它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。</p><p>Stream的操作可以分为两大类：中间操作、终结操作</p><p>中间操作可分为：</p><p>无状态（Stateless）操作：指元素的处理不受之前元素的影响<br>有状态（Stateful）操作：指该操作只有拿到所有元素之后才能继续下去<br>终结操作可分为：</p><p>短路（Short-circuiting）操作：指遇到某些符合条件的元素就可以得到最终结果<br>非短路（Unshort-circuiting）操作：指必须处理完所有元素才能得到最终结果</p><p><img src="https://img-blog.csdnimg.cn/20201218181011714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5MzM5NDUyNjg5,size_16,color_FFFFFF,t_70" alt="Stream操作分类"></p><p><strong><code>Stream操作的三个步骤：</code></strong></p><p>1）创建Stream：一个数据源（如：集合数组），获取一个流，Stream的实例化</p><p>2）中间操作：一个中间操作链，对数据源的数据进行处理（如：过滤、映射等）</p><p>3）终止操作（终端操作）：一旦执行终止操作，就执行中间操作链，并产生结果。之后，就不会再被使用。<br><img src="https://img-blog.csdnimg.cn/20211011115043745.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pil5rC054WO6Iy2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h2 id="3-2、Stream常用方法的实战"><a href="#3-2、Stream常用方法的实战" class="headerlink" title="3.2、Stream常用方法的实战"></a>3.2、Stream常用方法的实战</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stream8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;gkh&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">// 返回abc</span><br>        Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="hljs-string">&quot;abc&quot;</span>.equals(s));<br>        <span class="hljs-comment">// 计算符合条件的流的数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringStream.count();<br>        System.out.println(count); <span class="hljs-comment">// 2</span><br><br>        <span class="hljs-comment">// 遍历strings</span><br>        strings.stream().forEach(System.out::println);<br><br>        <span class="hljs-comment">// limit 获取第一个元素的stream</span><br>        Stream&lt;String&gt; limit = strings.stream().limit(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// toArray 想看流里面有什么的时候就可以转换成String[]</span><br>        String[] array = limit.toArray(String[]::<span class="hljs-keyword">new</span>);<br><br>        <span class="hljs-comment">// map 对每一个元素进行操作返回新流</span><br>        Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="hljs-string">&quot;22&quot;</span>);<br>        map.forEach(System.out::println);<br><br>        <span class="hljs-comment">// sorted 排序并打印</span><br>        strings.stream().sorted().forEach(System.out::println);<br><br>        <span class="hljs-comment">// Collectors collect 把abc放入到容器中</span><br>        List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="hljs-string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());<br>        <span class="hljs-comment">// 把list转换为String，之间用，隔开</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">mergedString</span> <span class="hljs-operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>        System.out.println(mergedString); <span class="hljs-comment">// abc,def,gkh,abc</span><br><br>        <span class="hljs-comment">// 对数组进行统计</span><br>        List&lt;Integer&gt; number = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>);<br>        number.forEach(System.out::println);<br><br>        <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">statistics</span> <span class="hljs-operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();<br>        System.out.println(<span class="hljs-string">&quot;列表中的最大值：&quot;</span> + statistics.getMax());<br>        System.out.println(<span class="hljs-string">&quot;列表中的最小值：&quot;</span> + statistics.getMin());<br>        System.out.println(<span class="hljs-string">&quot;列表的平均数：&quot;</span> + statistics.getAverage());<br>        System.out.println(<span class="hljs-string">&quot;列表中的所有数之和：&quot;</span> + statistics.getSum());<br><br>        <span class="hljs-comment">// concat合并</span><br>        <span class="hljs-comment">// Arrays.asList(&quot;xyz&quot;, &quot;jqx&quot;) 是一个不可变的 不能使用add等一系列对list的增删改查</span><br>        List&lt;String&gt; strings2 = Arrays.asList(<span class="hljs-string">&quot;xyz&quot;</span>, <span class="hljs-string">&quot;jqx&quot;</span>);<br>        Stream.concat(strings2.stream(),strings.stream()).count();<br><br>        <span class="hljs-comment">// 注意 一个stream是能操作一次，不能断开</span><br>        <span class="hljs-type">Stream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> strings.stream();<br>        <span class="hljs-comment">// 第一次使用</span><br>        stream.limit(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 第二次使用</span><br>        stream.forEach(System.out::println);<br>        <span class="hljs-comment">// 报错：java.lang.IllegalStateException: stream has already been operated upon or closed</span><br>        <br>        <span class="hljs-comment">// 如果要一个stream完成两个操作的话 可以使用.拼接起来</span><br>        stream.limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3、小结"><a href="#3-3、小结" class="headerlink" title="3.3、小结"></a>3.3、小结</h2><p>从源码和实例中我们可以总结出一些 stream 的特点</p><ol><li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li><li>方法参数都是函数式接口类型</li><li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li><li>Stream 不保存数据，不改变数据源</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Interface&quot;&gt;&lt;a href=&quot;#一、Interface&quot; class=&quot;headerlink&quot; title=&quot;一、Interface&quot;&gt;&lt;/a&gt;一、Interface&lt;/h1&gt;&lt;p&gt;interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://eliseo.top/2022/07/08/JVM-1/"/>
    <id>https://eliseo.top/2022/07/08/JVM-1/</id>
    <published>2022-07-08T02:33:45.000Z</published>
    <updated>2022-07-24T14:02:57.338Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/08/JVM-1/image-20220716215746191.png"></p><h1 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h1><h2 id="1-1、运行时数据区"><a href="#1-1、运行时数据区" class="headerlink" title="1.1、运行时数据区"></a>1.1、运行时数据区</h2><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="1-1-1、程序计数器"><a href="#1-1-1、程序计数器" class="headerlink" title="1.1.1、程序计数器"></a>1.1.1、程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p><img src="/2022/07/08/JVM-1/image-20220604110733931.png"></p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><img src="/2022/07/08/JVM-1/image-20220604143627082.png" alt="pc寄存器的使用场景"></p><h3 id="1-1-2、Java虚拟机栈"><a href="#1-1-2、Java虚拟机栈" class="headerlink" title="1.1.2、Java虚拟机栈"></a>1.1.2、Java虚拟机栈</h3><p>虚拟机栈<strong>是线程私有的</strong>，<code>生命周期与线程一样</code>，随着线程的存在而存在，随着线程的消亡而消亡。</p><p>除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><p><img src="/2022/07/08/JVM-1/image-20220724220028947.png" alt="栈"></p><p><img src="/2022/07/08/JVM-1/image-20220606093338725.png" alt="栈帧的基本结构"></p><p><strong>局部变量表：</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>操作数栈：</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接(指向运行时常量池的方法引用)：</strong> 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p><p><img src="/2022/07/08/JVM-1/image-20220724220055120.png"></p><p><strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><h3 id="1-1-3、本地方法栈"><a href="#1-1-3、本地方法栈" class="headerlink" title="1.1.3、本地方法栈"></a>1.1.3、本地方法栈</h3><p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p><h3 id="1-1-4、堆"><a href="#1-1-4、堆" class="headerlink" title="1.1.4、堆"></a>1.1.4、堆</h3><p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆</strong>；Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p><strong>堆空间的细分</strong></p><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</p><ul><li>Java7及之前堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>永久区</strong><ul><li>新生区又被分为eden(伊甸)区和Survivor(幸存者)区 幸存者区又分为幸存者1区(from区)和幸存者2区(to区)</li></ul></li><li>Java8及之后堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>元空间</strong></li><li>新生区&lt;=&gt;新生代&lt;=&gt;年轻代 养老区&lt;=&gt;老年区&lt;=&gt;老年代 永久区&lt;=&gt;永久代</li><li>堆大小=新生区+养老区，元空间或者永久区有他自己的大小</li><li><strong>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。</strong></li></ul><p><img src="https://javaguide.cn/assets/hotspot-heap-structure.784465da.png" alt="hotspot-heap-structure"></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><hr><p><strong>为什么要建立两个Survivor区？</strong><br>建立两个Survivor区，分别是S0和S1（From和To），MinorGC流程如下：</p><p>把new的对象放在Eden区中，一旦Eden满了，触发一次Minor GC，Eden区中存活的对象会送到S0中，Eden被清空；再次new对象放入Eden区中，Eden又满了，触发Minor GC，Eden和S0中存活的对象放入到S1中，然后S0和Eden清空，然后S0和S1交换角色，S1变成了S0，作为下一次GC的主要目标，S0变成了S1，存放下一次GC存活的对象。<br>如此循环往复，对象头的分代年龄达到16次，则会被送到老年代中。</p><p>官方推荐新生代占java堆的3/8，幸存代(S区)占新生代的1/10</p><h3 id="1-1-5、方法区"><a href="#1-1-5、方法区" class="headerlink" title="1.1.5、方法区"></a>1.1.5、方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，<u>是各个线程共享的内存区域。</u>他的实际的物理内存空间可以是<u>不连续的</u>。关闭JVM就会释放这个区域的内存</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src="https://javaguide.cn/assets/method-area-implementation.68e9c9cd.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>元空间不在虚拟机设置的内存中，而是使用本地内存。永久代因为使用的是虚拟机设置的内存，所以会出现OOM，但是将永久代替换为原空间以后就没有这个问题。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:PermSize=N <span class="hljs-comment">//方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的初始（和最小大小）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></p><h3 id="1-1-6、运行时常量池"><a href="#1-1-6、运行时常量池" class="headerlink" title="1.1.6、运行时常量池"></a>1.1.6、运行时常量池</h3><p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 <code>将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)</code>。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。<br><strong>方法区的Class文件信息，Class常量池和运行时常量池的三者关系</strong></p><p><img src="/2022/07/08/JVM-1/image-20220708232527703.png"></p><h3 id="1-1-7、字符串常量池"><a href="#1-1-7、字符串常量池" class="headerlink" title="1.1.7、字符串常量池"></a>1.1.7、字符串常量池</h3><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是字符串常量池。<strong>字符串常量池由String类私有的维护</strong>。</p><p>DK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><img src="https://javaguide.cn/assets/method-area-jdk1.6.02db832c.png" alt="img"></p><p><img src="https://javaguide.cn/assets/method-area-jdk1.7.eaf4234f.png" alt="img"></p><p><img src="https://javaguide.cn/assets/method-area-jdk1.8.b19d81f7.png" alt="img"></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h3 id="1-1-8、直接内存"><a href="#1-1-8、直接内存" class="headerlink" title="1.1.8、直接内存"></a>1.1.8、直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。</p><p>通常，访问直接内存的速度会优于Java堆，即读写性能高。</p><h2 id="1-2、HotSpot-虚拟机对象探秘"><a href="#1-2、HotSpot-虚拟机对象探秘" class="headerlink" title="1.2、HotSpot 虚拟机对象探秘"></a>1.2、HotSpot 虚拟机对象探秘</h2><h3 id="1-2-1、对象的创建过程"><a href="#1-2-1、对象的创建过程" class="headerlink" title="1.2.1、对象的创建过程"></a>1.2.1、对象的创建过程</h3><p><img src="https://img-blog.csdnimg.cn/07d02dbb0e3546b6a720b0d277a03889.png" alt="对象的创建过程"></p><h4 id="Step1：类加载检查"><a href="#Step1：类加载检查" class="headerlink" title="Step1：类加载检查"></a>Step1：类加载检查</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace（元空间）的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2：分配内存"><a href="#Step2：分配内存" class="headerlink" title="Step2：分配内存"></a>Step2：分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p><p><strong>如果内存规整</strong>：虚拟机将采用的是<code>指针碰撞法（Bump The Point）</code>来为对象分配内存。</p><ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul><p><strong>如果内存不规整：</strong>虚拟机需要维护一个<code>空闲列表（Free List）</code>来为对象分配内存。</p><ul><li>虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul><p><strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong><code>内存分配并发问题（补充内容，需要掌握）</code></strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。通过设置 <code>-XX:+UseTLAB</code>参数来设定</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法进行初始化"><a href="#Step5-执行-init-方法进行初始化" class="headerlink" title="Step5:执行 init 方法进行初始化"></a>Step5:执行 init 方法进行初始化</h4><p>从 Java 程序的视角来看，对象创建才刚开始，<code>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="1-2-2、对象的内存布局"><a href="#1-2-2、对象的内存布局" class="headerlink" title="1.2.2、对象的内存布局"></a>1.2.2、对象的内存布局</h3><p><img src="https://img-blog.csdnimg.cn/a97a450c6432470f94dd97bd4c3d4dac.png" alt="对象的内存布局"></p><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></p><h3 id="1-2-3对象的访问定位"><a href="#1-2-3对象的访问定位" class="headerlink" title="1.2.3对象的访问定位"></a>1.2.3对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</p><p><img src="https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.1cf25227.png" alt="对象的访问定位-使用句柄"></p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 <strong>reference 中存储的直接就是对象的地址。</strong></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。</p><p><img src="https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.9bfd6702.png" alt="对象的访问定位-直接指针"></p><h1 id="二、JVM垃圾回收"><a href="#二、JVM垃圾回收" class="headerlink" title="二、JVM垃圾回收"></a>二、JVM垃圾回收</h1><h2 id="2-1、-JVM-内存分配与回收"><a href="#2-1、-JVM-内存分配与回收" class="headerlink" title="2.1、 JVM 内存分配与回收"></a>2.1、 JVM 内存分配与回收</h2><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆</strong>。 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="/2022/07/08/JVM-1/image-20220724220119040.png"></p><p>Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><h3 id="2-1-1、对象优先在Eden区分配"><a href="#2-1-1、对象优先在Eden区分配" class="headerlink" title="2.1.1、对象优先在Eden区分配"></a>2.1.1、对象优先在Eden区分配</h3><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><h3 id="2-1-2、大对象直接进入老年代"><a href="#2-1-2、大对象直接进入老年代" class="headerlink" title="2.1.2、大对象直接进入老年代"></a>2.1.2、大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="2-1-3、长期存活的对象将进入老年代"><a href="#2-1-3、长期存活的对象将进入老年代" class="headerlink" title="2.1.3、长期存活的对象将进入老年代"></a>2.1.3、长期存活的对象将进入老年代</h3><p>对象通常在Eden区里诞生，如果经过第一次Minor GC还存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄加+1，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。</p><h3 id="2-1-4、动态对象年龄判定"><a href="#2-1-4、动态对象年龄判定" class="headerlink" title="2.1.4、动态对象年龄判定"></a>2.1.4、动态对象年龄判定</h3><p>HopStop虚拟机并不是永远要求对象的年龄必须达到<code>-XX：MaxTenuringThreshold</code>才能晋升老年代，如果在<strong>survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半</strong>，年龄大于等于该年龄的对象就可以直接进入老年代。无需等到MaxTenuringThreshold中要求的年龄。</p><h3 id="2-1-5、空间分配担保"><a href="#2-1-5、空间分配担保" class="headerlink" title="2.1.5、空间分配担保"></a>2.1.5、空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><hr><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区</p><h2 id="2-2、判断对象是否已经死亡"><a href="#2-2、判断对象是否已经死亡" class="headerlink" title="2.2、判断对象是否已经死亡"></a>2.2、判断对象是否已经死亡</h2><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><h3 id="2-2-1、引用计数法"><a href="#2-2-1、引用计数法" class="headerlink" title="2.2.1、引用计数法"></a>2.2.1、引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><hr><p><strong>循环引用：</strong></p><p><img src="https://img-blog.csdnimg.cn/ef82e7291ec74d78aeea2fe36232c765.png" alt="循环引用"></p><h3 id="2-2-2、可达性分析算法"><a href="#2-2-2、可达性分析算法" class="headerlink" title="2.2.2、可达性分析算法"></a>2.2.2、可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p><p><img src="https://javaguide.cn/assets/jvm-gc-roots.39234b20.png" alt="可达性分析算法"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="2-2-3、引用"><a href="#2-2-3、引用" class="headerlink" title="2.2.3、引用"></a>2.2.3、引用</h3><p>引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>如果一个对象有强引用，那么就相当于是生活中<strong>必不可少的生活用品</strong>，哪怕内存空间不足，jvm哪怕抛出异常也不愿意随意回收具有强引用的对象</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象有软引用，那么就相当于是生活中<strong>可有可无的生活用品</strong>，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收。</strong></p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用<strong>必须</strong>和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-2-4、如何判断一个常量是废弃常量？"><a href="#2-2-4、如何判断一个常量是废弃常量？" class="headerlink" title="2.2.4、如何判断一个常量是废弃常量？"></a>2.2.4、如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="2-2-5、如何判断一个类是无用的类？"><a href="#2-2-5、如何判断一个类是无用的类？" class="headerlink" title="2.2.5、如何判断一个类是无用的类？"></a>2.2.5、如何判断一个类是无用的类？</h3><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的<strong>仅仅是“可以”</strong>，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="2-3、垃圾收集算法"><a href="#2-3、垃圾收集算法" class="headerlink" title="2.3、垃圾收集算法"></a>2.3、垃圾收集算法</h2><h3 id="2-3-1、标记-清除算法"><a href="#2-3-1、标记-清除算法" class="headerlink" title="2.3.1、标记-清除算法"></a>2.3.1、标记-清除算法</h3><p>分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。<strong>它是最基础的收集算法。</strong></p><p>但是会有<strong>两个问题</strong>：</p><p>1、效率问题</p><p>2、空间问题（标记清除后，会产生大量不连续的碎片）</p><p><img src="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg" alt="标记-清除算法"></p><h3 id="2-3-2、标记-复制算法"><a href="#2-3-2、标记-复制算法" class="headerlink" title="2.3.2、标记-复制算法"></a>2.3.2、标记-复制算法</h3><p>可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://javaguide.cn/assets/90984624.e8c186ae.png" alt="标记-复制算法"></p><h3 id="2-3-3、标记-整理算法"><a href="#2-3-3、标记-整理算法" class="headerlink" title="2.3.3、标记-整理算法"></a>2.3.3、标记-整理算法</h3><p>标记过程与标记-清除算法一样，但是后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://javaguide.cn/assets/94057049.22c58294.png" alt="标记-整理算法 "></p><h3 id="2-3-4、分代收集算法"><a href="#2-3-4、分代收集算法" class="headerlink" title="2.3.4、分代收集算法"></a>2.3.4、分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h2 id="2-4、垃圾回收器"><a href="#2-4、垃圾回收器" class="headerlink" title="2.4、垃圾回收器"></a>2.4、垃圾回收器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p><img src="/2022/07/08/JVM-1/image-20220724220136406.png"></p><h3 id="2-4-1、Serial-收集器（串行回收）"><a href="#2-4-1、Serial-收集器（串行回收）" class="headerlink" title="2.4.1、Serial 收集器（串行回收）"></a>2.4.1、Serial 收集器（串行回收）</h3><p>串行收集器是一个<strong>单线程</strong>收集器，不仅仅意味着他只会使用一个垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://javaguide.cn/assets/46873026.3a9311ec.png" alt=" Serial 收集器 "></p><p>但是 它<strong>简单而高效</strong></p><h3 id="2-4-2、ParNew-收集器（并行回收）"><a href="#2-4-2、ParNew-收集器（并行回收）" class="headerlink" title="2.4.2、ParNew 收集器（并行回收）"></a>2.4.2、ParNew 收集器（并行回收）</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="ParNew 收集器 "></p><p><strong><code>首要选择</code></strong></p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="2-4-3、Parallel-Scavenge-收集器（吞吐量优先的并行回收）"><a href="#2-4-3、Parallel-Scavenge-收集器（吞吐量优先的并行回收）" class="headerlink" title="2.4.3、Parallel Scavenge 收集器（吞吐量优先的并行回收）"></a>2.4.3、Parallel Scavenge 收集器（吞吐量优先的并行回收）</h3><p>标记-复制算法的多线程收集器，相比于ParNew收集器，他的关注点在 <strong>吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong></p><p>吞吐量表示在单位时间内通过某个网络或接口的数据量 ，包括全部上传和下载的流量。</p><p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="Parallel Scavenge 收集器 "></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p>JDK1.8默认使用的是 Parallel Scavenge + Parallel Old</p><h3 id="2-4-4、Serial-Old-收集器"><a href="#2-4-4、Serial-Old-收集器" class="headerlink" title="2.4.4、Serial Old 收集器"></a>2.4.4、Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="2-4-5、Parallel-Old-收集器"><a href="#2-4-5、Parallel-Old-收集器" class="headerlink" title="2.4.5、Parallel Old 收集器"></a>2.4.5、Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="2-4-6、CMS-收集器（低停顿时间）"><a href="#2-4-6、CMS-收集器（低停顿时间）" class="headerlink" title="2.4.6、CMS 收集器（低停顿时间）"></a>2.4.6、CMS 收集器（低停顿时间）</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。是一种基于标记-清楚算法实现的</strong></p><p>运转过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫</li></ul><p><img src="https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png" alt="CMS 垃圾收集器 "></p><p>主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="2-4-7、G1-收集器（区域化分代式）"><a href="#2-4-7、G1-收集器（区域化分代式）" class="headerlink" title="2.4.7、G1 收集器（区域化分代式）"></a>2.4.7、G1 收集器（区域化分代式）</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率<code>满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征</code>.</strong></p><p>侧重点在于<strong>回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）</strong></p><div class="note note-success">            <p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。Region中还有一类特殊的Humongous区域，专门用来存储大对象（只要超过了一个Region容量一半的对象）。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region 之中，G1的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待</p>          </div><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200730161610159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMjI4MTI4NDk=,size_16,color_FFFFFF,t_70" alt="G1运行过程"></p><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记：</strong>需要停顿线程，但是耗时很短，</li><li><strong>并发标记：</strong>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="2-4-8、ZGC-收集器"><a href="#2-4-8、ZGC-收集器" class="headerlink" title="2.4.8、ZGC 收集器"></a>2.4.8、ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><h1 id="三、类加载过程"><a href="#三、类加载过程" class="headerlink" title="三、类加载过程"></a>三、类加载过程</h1><h2 id="3-1、类的生命周期"><a href="#3-1、类的生命周期" class="headerlink" title="3.1、类的生命周期"></a>3.1、类的生命周期</h2><p><img src="/2022/07/08/JVM-1/image-20220717120404351.png" alt="类的生命周期"></p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690785011/2F1143CD0902210BA8783DBC8CB76D0A" alt="类加载过程"></p><h2 id="3-2、类加载过程"><a href="#3-2、类加载过程" class="headerlink" title="3.2、类加载过程"></a>3.2、类加载过程</h2><p>加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="/2022/07/08/JVM-1/image-20220724220201809.png" alt="加载Class文件的过程"></p><h3 id="3-2-1、加载"><a href="#3-2-1、加载" class="headerlink" title="3.2.1、加载"></a>3.2.1、加载</h3><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象，作为方法区这些数据的访问入口</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：第一点比较常见的就是从 <code>ZIP</code> 包中读取（日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础）、其他文件生成（典型应用就是 <code>JSP</code>）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了</p><h3 id="3-2-2、验证"><a href="#3-2-2、验证" class="headerlink" title="3.2.2、验证"></a>3.2.2、验证</h3><p>验证（Verify）：</p><ul><li>目的在子确保Class文件的字节流文件包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害到虚拟机自身安全。</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul><p><img src="/2022/07/08/JVM-1/image-20220724220221738.png" alt="验证阶段示意图"></p><h3 id="3-2-3、准备"><a href="#3-2-3、准备" class="headerlink" title="3.2.3、准备"></a>3.2.3、准备</h3><ul><li>准备（Prepare）：<ul><li>为类变量分配内存并设置该变量的默认初始值，即零值。例如：int类型为0。</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中</li></ul></li></ul><h3 id="3-2-4、解析"><a href="#3-2-4、解析" class="headerlink" title="3.2.4、解析"></a>3.2.4、解析</h3><ul><li>解析（Resolve）：<ul><li>将常量池内的符号引用转换为直接引用的过程，一般在初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="3-2-5、初始化"><a href="#3-2-5、初始化" class="headerlink" title="3.2.5、初始化"></a>3.2.5、初始化</h3><ul><li><strong>初始化阶段就是执行类构造方法<code>&lt;client&gt;()</code>的过程</strong></li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量(静态变量)的赋值动作和静态代码块中的语句合并而来的。（如果没有静态变量赋值动作或静态代码就没有<code>&lt;client&gt;()</code>方法） <strong>必须要有静态变量赋值动作或者静态代码块</strong></li><li>构造器方法中指令按照语句<strong>在源文件中出现的顺序</strong>执行。</li><li><strong><code>&lt;client&gt;()</code>不同于类的构造器。</strong>（关联：构造器是虚拟机视角下的<code>&lt;client&gt;()</code>）</li><li>若该类有父类，JVM会保证子类的<code>&lt;client&gt;()</code>执行前，父类的<code>&lt;client&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;client&gt;()</code>方法在多线程下被同步加锁。一个类只会被加载一次</li></ul><p><img src="http://www.eliseo.top/2022/05/08/JVM/image-20220511215809705.png"></p><h2 id="3-3、卸载"><a href="#3-3、卸载" class="headerlink" title="3.3、卸载"></a>3.3、卸载</h2><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在 JVM 生命周期内，由 <strong>jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</strong></p><h1 id="四、类加载器详解"><a href="#四、类加载器详解" class="headerlink" title="四、类加载器详解"></a>四、类加载器详解</h1><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><h2 id="4-1、双亲委派机制"><a href="#4-1、双亲委派机制" class="headerlink" title="4.1、双亲委派机制"></a>4.1、双亲委派机制</h2><p>即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。<strong>通俗点说：就是先查看类是否已经被加载过，如果被加载过那么久直接返回，否则九一直询问父类是否加载，如果所有父类都没有加载过，那么就自己加载。</strong></p><p><img src="/2022/07/08/JVM-1/image-20220724220251452.png" alt="ClassLoader"></p><p><strong>双亲委派模型的好处</strong></p><p>双亲委派模型保证了 Java 程序的稳定运行，<strong>可以避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），<strong>也保证了 Java 的核心 API 不被篡改</strong>。</p><hr><p>Java文件的运行过程</p><ol><li>Java文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><p>只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找</p><h1 id="JVM的常用参数"><a href="#JVM的常用参数" class="headerlink" title="JVM的常用参数"></a>JVM的常用参数</h1><p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or later)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/08/JVM-1/image-20220716215746191.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、Java内存区域&quot;&gt;&lt;a href=&quot;#一、Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;一、Java内</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="https://eliseo.top/2022/07/07/java%E9%9B%86%E5%90%88/"/>
    <id>https://eliseo.top/2022/07/07/java%E9%9B%86%E5%90%88/</id>
    <published>2022-07-07T12:41:24.000Z</published>
    <updated>2022-07-14T02:10:31.881Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全的集合：vector，hashtable，剩下的集合都不安全</p><h1 id="说说-List-Set-Queue-Map-四者的区别？"><a href="#说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="说说 List, Set, Queue, Map 四者的区别？"></a>说说 List, Set, Queue, Map 四者的区别？</h1><p><code>list:</code>有序的可重复的，一般对付排序的问题</p><p><code>set:</code>(注重独一无二的性质): 无序的、不可重复的。</p><p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树</li></ul><h1 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h1><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><p>这些接口拥有众多的实现类，其中最常用的实现类有HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。</p><h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>在传入（add）第一个参数的时候，源码中会调用<code>ensureCapacityInternal()</code>方法，当传入的参数&lt;10的时候，<code>ensureCapacityInternal()</code>方法会默认ArrayList的大小为10；</p><p>当传入的参数大于10个之后，会进入<code>grow()</code>方法，进行扩容</p><h1 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h1><p><strong>使用场景：</strong></p><p><code>comparable接口</code>一般用在实体类，实体类实现这个接口，然后可以通过重写<code>compareTo方法</code>，对实体类的<code>Integer</code>类型的参数进行比较。</p><p><code>Comparator接口</code>在实体类被实现，用于自定义比较一些非 <code>Integer</code>类型的参数进行比较，用于自定义比较。也可以用在方法中 使用一个自定义比较器实现自定义比较。</p><h1 id="Queue-与-Deque"><a href="#Queue-与-Deque" class="headerlink" title="Queue 与 Deque"></a>Queue 与 Deque</h1><p>Queue是单端队列，从一端插入，从另一端删除，遵循**先进先出(FIFO)**原则。</p><p><img src="/2022/07/07/java%E9%9B%86%E5%90%88/image-20220707212625845.png"></p><p>Deque是双端队列，队列两端均可以插入与删除。</p><p><img src="/2022/07/07/java%E9%9B%86%E5%90%88/image-20220707212700993.png"></p><p>实际上还有 <code>push()</code>方法与<code>pop()</code>方法，用于模拟栈</p><h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><p><code>hashMap</code>可以存储null的k-v，但是作为k只能有一个null，value则是可以存在多个null，</p><p><code>TreeMap</code>自己本身默认是按照key的升序进行排列的，但是也可以自定义比较器</p><p><strong>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h1 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h1><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h1 id="hashCode-与-equals-的相关规定："><a href="#hashCode-与-equals-的相关规定：" class="headerlink" title="hashCode()与 equals() 的相关规定："></a><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</h1><ol><li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li><li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li><li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li><li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li><li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><h1 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="==与 equals 的区别"></a>==与 equals 的区别</h1><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方)；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程安全的集合：vector，hashtable，剩下的集合都不安全&lt;/p&gt;
&lt;h1 id=&quot;说说-List-Set-Queue-Map-四者的区别？&quot;&gt;&lt;a href=&quot;#说说-List-Set-Queue-Map-四者的区别？&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://eliseo.top/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://eliseo.top/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-07-07T08:12:23.000Z</published>
    <updated>2022-07-24T13:59:59.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、使用线程池的好处："><a href="#一、使用线程池的好处：" class="headerlink" title="一、使用线程池的好处："></a>一、使用线程池的好处：</h1><p>1、降低资源消耗</p><p>2、提高响应速度</p><p>3、提高线程的客观理性</p><h1 id="二、Executor框架"><a href="#二、Executor框架" class="headerlink" title="二、Executor框架"></a>二、Executor框架</h1><h2 id="2-1、Executor-框架结构"><a href="#2-1、Executor-框架结构" class="headerlink" title="2.1、Executor 框架结构"></a>2.1、Executor 框架结构</h2><h3 id="1、任务-Runnable-callable"><a href="#1、任务-Runnable-callable" class="headerlink" title="1、任务(Runnable/callable)"></a>1、任务(Runnable/callable)</h3><h3 id="2、任务的执行-Executor"><a href="#2、任务的执行-Executor" class="headerlink" title="2、任务的执行(Executor)"></a>2、任务的执行(Executor)</h3><p><strong>需要更多关注的是 <code>ThreadPoolExecutor</code>这个类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractExecutorService实现了ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ScheduledExecutorService继承ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScheduledExecutorService</span><br></code></pre></td></tr></table></figure><h3 id="3、异步计算的结果-Future"><a href="#3、异步计算的结果-Future" class="headerlink" title="3、异步计算的结果(Future)"></a>3、异步计算的结果(Future)</h3><p>将<code>runnable</code>与<code>callable</code>接口的实现类提交给<code>ThreadPoolExecutor</code> 执行，使用<code>submit()</code>方法会得到一个返回值</p><h2 id="2-2、执行流程"><a href="#2-2、执行流程" class="headerlink" title="2.2、执行流程"></a>2.2、执行流程</h2><p><img src="https://javaguide.cn/assets/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.36e59afa.png" alt="Executor 框架的使用示意图"></p><ol><li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li><li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable  task）</code>）。</li><li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li></ol><h1 id="三、ThreadPoolExecutor-类的简单介绍-重点"><a href="#三、ThreadPoolExecutor-类的简单介绍-重点" class="headerlink" title="三、ThreadPoolExecutor 类的简单介绍(重点)"></a>三、ThreadPoolExecutor 类的简单介绍<code>(重点)</code></h1><h2 id="1、类分析"><a href="#1、类分析" class="headerlink" title="1、类分析"></a>1、类分析</h2><p>ThreadPoolExecutor类 一共提供了四个构造方法</p><p>最长的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>其他的常见参数：</strong></p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程会一直等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ol><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220707162623783.png" alt="线程池中各个参数的关系"></p><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略：</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 此策略将丢弃最早的未处理的任务请求。</li></ul><p>当不指定<code>RejectedExecutionHandler</code>饱和策略的时候默认使用<code>ThreadPoolExecutor.AbortPolicy</code></p><h2 id="3-2、推荐使用ThreadPoolExecutor-创建线程池"><a href="#3-2、推荐使用ThreadPoolExecutor-创建线程池" class="headerlink" title="3.2、推荐使用ThreadPoolExecutor 创建线程池"></a>3.2、推荐使用<code>ThreadPoolExecutor</code> 创建线程池</h2><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</p><p><strong>使用<code>Executors</code> 创建线程池的弊端：</strong></p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li></ul><h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a><strong>创建方式：</strong></h3><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数实现（推荐）</strong><img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.d54a5992.png" alt="通过构造方法实现"></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</strong> 我们可以创建三种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li><code>FixedThreadPool</code></li><li><code>SingleThreadExecutor</code></li><li>CachedThreadPool</li></ul><p>对应 Executors 工具类中的方法如图所示：</p><p><img src="https://javaguide.cn/assets/Executors%E5%B7%A5%E5%85%B7%E7%B1%BB.4b0cbd16.png" alt="通过Executor 框架的工具类Executors来实现"></p><h1 id="四、ThreadPoolExecutor-使用-分析"><a href="#四、ThreadPoolExecutor-使用-分析" class="headerlink" title="四、ThreadPoolExecutor 使用+分析"></a>四、ThreadPoolExecutor 使用+分析</h1><h2 id="4-1、线程池原理分析"><a href="#4-1、线程池原理分析" class="headerlink" title="4.1、线程池原理分析"></a>4.1、线程池原理分析</h2><p><strong><code>excute</code>方法(提交一个任务到线程池中去)详解：</strong></p><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220724215903960.png" alt="图解线程池实现原理"></p><p><strong><code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</strong></p><h2 id="4-2、常见对比"><a href="#4-2、常见对比" class="headerlink" title="4.2、常见对比"></a>4.2、常见对比</h2><h3 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h3><p><strong><code>Runnable</code>接口</strong>不会返回结果或抛出异常，但是 <strong><code>Callable</code>接口</strong>可以。</p><h3 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a><code>execute()</code> vs <code>submit()</code></h3><p><code>execute()</code>用于不会提交返回值的任务</p><p><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</p><p>示例1：使用 <code>get() </code>方法获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get();<br>System.out.println(s);<br>executorService.shutdown();<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">abc<br></code></pre></td></tr></table></figure><p>示例2：使用 <code>get（long timeout，TimeUnit unit） </code>方法获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>System.out.println(s);<br>executorService.shutdown();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException<br>at java.util.concurrent.FutureTask.get(FutureTask.java:205)<br></code></pre></td></tr></table></figure><h3 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h1 id="五、几种常见的线程池"><a href="#五、几种常见的线程池" class="headerlink" title="五、几种常见的线程池"></a>五、几种常见的线程池</h1><h2 id="5-1、FixedThreadPool"><a href="#5-1、FixedThreadPool" class="headerlink" title="5.1、FixedThreadPool"></a>5.1、FixedThreadPool</h2><h3 id="5-1-1、简介"><a href="#5-1-1、简介" class="headerlink" title="5.1.1、简介"></a>5.1.1、简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 创建一个可重用固定数量线程的线程池</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                   <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                   threadFactory);<br> &#125;<br></code></pre></td></tr></table></figure><p>1.固定大小的线程池nThreads；<br>2.corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；<br>3.keepAliveTime为0，一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效(由于采用了无界队列)；<br>4.阻塞队列采用了LinkedBlockingQueue，一个无界队列；由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</p><p><strong>被称为 <code>可重用固定线程数</code>的线程池，新创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</strong></p><h3 id="5-1-2、执行任务过程介绍"><a href="#5-1-2、执行任务过程介绍" class="headerlink" title="5.1.2、执行任务过程介绍"></a>5.1.2、执行任务过程介绍</h3><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图</p><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708084630822.png" alt="excute()运行示意图"></p><p><strong>说明：</strong></p><p>1、当前运行数小于corePoolSize的时候，有新的任务时，就会创建新的线程中</p><p>2、当前运行数大于或等于corePoolSize的时候，有新的任务时，就会将任务加到 <code>LinkedBlockingQueue</code></p><p>3、当线程池中的线程结束了手里的任务时，就会去<code>LinkedBlockingQueue</code>中获取任务执行</p><h2 id="5-2、SingleThreadExecutor-会导致OOM"><a href="#5-2、SingleThreadExecutor-会导致OOM" class="headerlink" title="5.2、SingleThreadExecutor(会导致OOM)"></a>5.2、SingleThreadExecutor(会导致OOM)</h2><h3 id="5-2-1、简介"><a href="#5-2-1、简介" class="headerlink" title="5.2.1、简介"></a>5.2.1、简介</h3><p><strong>只有<code>一个线程</code>的线程池。</strong></p><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *返回只有一个线程的线程池</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>         (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                 <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                 threadFactory));<br> &#125;<br></code></pre></td></tr></table></figure><p>将<code>corePoolSize</code>与<code>maximumPoolSize</code>都设置成1，保证只有一个线程能运行，剩下的参数与 <code>FixedThreadPool</code>相同</p><h3 id="5-2-2、执行任务过程介绍"><a href="#5-2-2、执行任务过程介绍" class="headerlink" title="5.2.2、执行任务过程介绍"></a>5.2.2、执行任务过程介绍</h3><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708090951289.png"></p><ol><li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li><li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li><li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行</li></ol><h2 id="5-3、CachedThreadPool-详解"><a href="#5-3、CachedThreadPool-详解" class="headerlink" title="5.3、CachedThreadPool 详解"></a>5.3、CachedThreadPool 详解</h2><h3 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h3><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>将<code>corePoolSize</code>设置成0，<code>maximumPoolSize</code>设置成<code>Integer.MAX.VALUE</code>。如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程，极端情况下，会导致耗尽CPU和内存资源。</p><h3 id="5-3-2、执行任务过程介绍"><a href="#5-3-2、执行任务过程介绍" class="headerlink" title="5.3.2、执行任务过程介绍"></a>5.3.2、执行任务过程介绍</h3><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708091916023.png" alt="execute()执行流程"></p><p>当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</p><h2 id="5-4、线程使用场景"><a href="#5-4、线程使用场景" class="headerlink" title="5.4、线程使用场景"></a>5.4、线程使用场景</h2><p><code>CachedThreadPool</code>：执行很多短期异步的小程序或者负载较轻的服务器 </p><p><code>FixedThreadPool</code>：适合执行长期任务</p><p><code>SingleThreadExecutor</code>：适合一个任务一个任务执行的场景</p><h1 id="六、ScheduledThreadPoolExecutor-了解即可"><a href="#六、ScheduledThreadPoolExecutor-了解即可" class="headerlink" title="六、ScheduledThreadPoolExecutor(了解即可)"></a>六、ScheduledThreadPoolExecutor(了解即可)</h1><h2 id="6-1、简介"><a href="#6-1、简介" class="headerlink" title="6.1、简介"></a>6.1、简介</h2><p><strong>主要用来在给定的延迟后运行任务，或者定期执行任务</strong></p><p>使用的任务队列<code>DelayQueue</code>封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行，如果执行所需时间一样，那么谁先进来的谁先执行</p><h2 id="6-2、运行机制"><a href="#6-2、运行机制" class="headerlink" title="6.2、运行机制"></a>6.2、运行机制</h2><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708094216584.png" alt="image-20220708094216584"></p><ol><li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>scheduleAtFixedRate()</code></strong> 方法或者 <strong><code>scheduleWithFixedDelay()</code></strong> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>DelayQueue</code></strong> 添加一个实现了 <strong><code>RunnableScheduledFuture</code></strong> 接口的 <strong><code>ScheduledFutureTask</code></strong> 。</li><li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li></ol><p><strong>为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code>做了如下修改</strong></p><p>1、将消息队列改为了 <code>DelayQueue</code></p><p>2、获取任务的方不同</p><p>3、执行周期任务后，增加了额外的处理</p><h2 id="6-3、ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#6-3、ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="6.3、ScheduledThreadPoolExecutor 执行周期任务的步骤"></a>6.3、ScheduledThreadPoolExecutor 执行周期任务的步骤</h2><p><img src="https://javaguide.cn/assets/ScheduledThreadPoolExecutor%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E6%AD%A5%E9%AA%A4.5bd57dd0.png" alt="ScheduledThreadPoolExecutor执行周期任务的步骤"></p><ol><li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li><li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li></ol><h1 id="七、线程池大小确定"><a href="#七、线程池大小确定" class="headerlink" title="七、线程池大小确定"></a>七、线程池大小确定</h1><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong></p><p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>N是指CPU的核心数，一般<strong>CPU 密集型任务设置线程池大小为：(N+1)；I/O 密集型任务线程池大小设置为(2N)</strong></p><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h1 id="八、如何使用线程池"><a href="#八、如何使用线程池" class="headerlink" title="八、如何使用线程池"></a>八、如何使用线程池</h1><p>一般是通过 <code>ThreadPoolExecutor</code> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。</p><p><code>ThreadPoolExecutor</code>的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">KEEP_ALIVE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//使用阿里巴巴推荐的创建线程池的方式</span><br>        <span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_TIME,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;CurrentThread name:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;date：&quot;</span> + Instant.now());<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//终止线程池</span><br>        executor.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Finished all threads&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="九、线程池的注意事项"><a href="#九、线程池的注意事项" class="headerlink" title="九、线程池的注意事项"></a>九、线程池的注意事项</h1><h2 id="9-1、使用-ThreadPoolExecutor-的构造函数声明线程池"><a href="#9-1、使用-ThreadPoolExecutor-的构造函数声明线程池" class="headerlink" title="9.1、使用 ThreadPoolExecutor 的构造函数声明线程池"></a>9.1、使用 <code>ThreadPoolExecutor </code>的构造函数声明线程池</h2><p><strong>线程池必须手动通过 <code>ThreadPoolExecutor </code>的构造函数来声明，避免使用<code>Executors </code>类的 <code>newFixedThreadPool</code> 和 <code>newCachedThreadPool</code> ，因为可能会有 OOM 的风险。</strong>就是<strong>使用有界队列，控制线程创建数量。</strong></p><h2 id="9-2、监测线程池运行状态"><a href="#9-2、监测线程池运行状态" class="headerlink" title="9.2、监测线程池运行状态"></a>9.2、监测线程池运行状态</h2><p>使用SpringBoot 中的 Actuator 组件</p><p>每一秒打印一次线程状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 打印线程池的状态</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> threadPool 线程池对象</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printThreadPoolStatus</span><span class="hljs-params">(ThreadPoolExecutor threadPool)</span> &#123;<br>       <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, createThreadFactory(<span class="hljs-string">&quot;print-images/thread-pool-status&quot;</span>, <span class="hljs-literal">false</span>));<br>       scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;<br>           log.info(<span class="hljs-string">&quot;=========================&quot;</span>);<br>           log.info(<span class="hljs-string">&quot;ThreadPool Size: [&#123;&#125;]&quot;</span>, threadPool.getPoolSize());<br>           log.info(<span class="hljs-string">&quot;Active Threads: &#123;&#125;&quot;</span>, threadPool.getActiveCount());<br>           log.info(<span class="hljs-string">&quot;Number of Tasks : &#123;&#125;&quot;</span>, threadPool.getCompletedTaskCount());<br>           log.info(<span class="hljs-string">&quot;Number of Tasks in Queue: &#123;&#125;&quot;</span>, threadPool.getQueue().size());<br>           log.info(<span class="hljs-string">&quot;=========================&quot;</span>);<br>       &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="9-3、不同类别的业务使用不同的线程池"><a href="#9-3、不同类别的业务使用不同的线程池" class="headerlink" title="9.3、不同类别的业务使用不同的线程池"></a>9.3、不同类别的业务使用不同的线程池</h2><p>一个项目中有多个不同的业务，建议每一个业务都使用各自的线程池</p><p>如果多个业务使用一个线程池，那么可能会造成<code>死锁</code></p><p>假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 **”死锁”**。</p><p><img src="https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81.8ea83cdb.png" alt="线程池使用不当导致死锁"></p><h2 id="9-4、初始化线程池的时候别忘了给线程池命名"><a href="#9-4、初始化线程池的时候别忘了给线程池命名" class="headerlink" title="9.4、初始化线程池的时候别忘了给线程池命名"></a>9.4、初始化线程池的时候别忘了给线程池命名</h2><p><strong>好处：</strong>有助于定位问题。</p><h3 id="9-4-1、给线程池命名一般使用两种方法："><a href="#9-4-1、给线程池命名一般使用两种方法：" class="headerlink" title="9.4.1、给线程池命名一般使用两种方法："></a>9.4.1、给线程池命名一般使用两种方法：</h3><p>**1.利用 guava 的 <code>ThreadFactoryBuilder</code> **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)<br></code></pre></td></tr></table></figure><p><strong>2.自己实现 <code>ThreadFactor</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、使用线程池的好处：&quot;&gt;&lt;a href=&quot;#一、使用线程池的好处：&quot; class=&quot;headerlink&quot; title=&quot;一、使用线程池的好处：&quot;&gt;&lt;/a&gt;一、使用线程池的好处：&lt;/h1&gt;&lt;p&gt;1、降低资源消耗&lt;/p&gt;
&lt;p&gt;2、提高响应速度&lt;/p&gt;
&lt;p&gt;3、</summary>
      
    
    
    
    <category term="面试" scheme="https://eliseo.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://eliseo.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转图像</title>
    <link href="https://eliseo.top/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://eliseo.top/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2022-07-06T14:27:36.000Z</published>
    <updated>2022-07-06T14:31:10.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/image-20220706222939152.png" alt="旋转图像"></p><p><strong>方法一：加入一个二维数组存放数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[j][n - i - <span class="hljs-number">1</span>] = matrix[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[i][j] = res[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：直接原地交换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// 先上下交换 然后在沿着对角线交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 上下交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = matrix[i];<br>            matrix[i] = matrix[n - i - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>        <span class="hljs-comment">// 对角线交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/image-20220706222939152.png&quot; alt=&quot;旋转图像&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：加入一个二维数组存放数据&lt;/stro</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="https://eliseo.top/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://eliseo.top/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2022-07-06T14:26:28.000Z</published>
    <updated>2022-07-06T14:32:49.944Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/image-20220706223151247.png" alt="全排列"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        backtrace(<span class="hljs-number">0</span>, list, nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> index, List&lt;Integer&gt; list, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从第一位往后固定</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123; <span class="hljs-comment">// 要是这个位置没有元素</span><br>                list.add(nums[i]);<br>                used[i] = <span class="hljs-literal">true</span>;<br>                backtrace(index + <span class="hljs-number">1</span>, list, nums, used);<br>                <span class="hljs-comment">// 移除list数组最后一个值</span><br>                list.remove(list.size() - <span class="hljs-number">1</span>);<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/image-20220706223151247.png&quot; alt=&quot;全排列&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>接雨水</title>
    <link href="https://eliseo.top/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://eliseo.top/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2022-07-04T08:31:07.000Z</published>
    <updated>2022-07-04T08:33:49.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20220704163322027.png" alt="接雨水"></p><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 双指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 那边小那边就往里走</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            leftMax = Math.max(height[left], leftMax);<br>            rightMax = Math.max(height[right], rightMax);<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                <span class="hljs-comment">// 计算最高值和当前值之间的储水量</span><br>                ans += leftMax - height[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += rightMax - height[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20220704163322027.png&quot; alt=&quot;接雨水&quot;&gt;&lt;/p&gt;
&lt;p&gt;双指针&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://eliseo.top/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://eliseo.top/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-06-13T02:12:35.000Z</published>
    <updated>2022-06-13T02:13:28.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/image-20220613101313587.png" alt="搜索旋转排序数组"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 数组找东西 优先想到二分法，虽然数组不有序，但是局部有序 所以我们现在有序的地方寻找，然后再在无序的地方寻找</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[r]) &#123; <span class="hljs-comment">// 有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/image-20220613101313587.png&quot; alt=&quot;搜索旋转排序数组</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>最长有效括号</title>
    <link href="https://eliseo.top/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>https://eliseo.top/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-06-13T01:10:53.000Z</published>
    <updated>2022-06-13T01:13:37.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/image-20220613091241176.png" alt="最长有效括号"></p><p><strong>解法：栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.push(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 如果加入的元素是(</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 将(的下标放入栈内</span><br>                stack.push(i);<br>            &#125;<br>            <span class="hljs-comment">// 如果加入的元素是 (，那么存在</span><br>            <span class="hljs-comment">// 1、)前面有(</span><br>            <span class="hljs-comment">// 2、前面没有左括号和它进行匹配，那么这个右括号就形成了新的边界。新的子串匹配时，起点必须在该边界右边</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123; <span class="hljs-comment">// 加入的元素不是(,是)</span><br>                stack.pop();<br>                <span class="hljs-comment">// 如果栈是空的</span><br>                <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 将这个右括号的下标作为最后一个没有被匹配的右括号</span><br>                    stack.push(i);<br>                &#125;<br>                <span class="hljs-comment">// 匹配到了。那么这个有括号的下标减去栈顶元素(也就是最后一个没有被匹配的括号)就是当前长度</span><br>                max =  Math.max(max, i - stack.peek());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/image-20220613091241176.png&quot; alt=&quot;最长有效括号&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>下一个排列</title>
    <link href="https://eliseo.top/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://eliseo.top/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2022-06-07T03:36:00.000Z</published>
    <updated>2022-06-07T03:39:17.697Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/image-20220607113633064.png" alt="下一个排列"></p><p><strong>题意分析：</strong></p><p>找到一个比nums刚好还大的一个数字，也就是用nums的所给数字组成一个比刚开始的nums大的数字中的最小的数字就是所要输出的数</p><p><strong>题解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">// [1,2,3,8,5,7,6,4]</span><br>    <span class="hljs-comment">// 先从后往前找 找到最靠右的第一个变小的值 然后找到这个值右边比这个值小的值</span><br>    <span class="hljs-comment">// 然后交换这两个值</span><br>    <span class="hljs-comment">// 然后将最小的最大值的右边的数字按从小到大排序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i--;<br>        &#125; <span class="hljs-comment">// 5</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j--;<br>            &#125; <span class="hljs-comment">// 6</span><br>            swap(nums, i, j);<br>        &#125;<br>        sort(nums, i+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/image-20220607113633064.png&quot; alt=&quot;下一个排列&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意分析：&lt;/stron</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="https://eliseo.top/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://eliseo.top/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-06-07T00:41:48.000Z</published>
    <updated>2022-06-07T00:45:01.128Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220607084424542.png" alt="合并K个升序链表"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 防止溢出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br><br>    <span class="hljs-comment">// 空指针</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dum;<br><br>        <span class="hljs-keyword">while</span>(a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(a.val &lt; b.val) &#123;<br>                cur.next = a;<br>                a = a.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur.next = b;<br>                b = b.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = a != <span class="hljs-literal">null</span> ? a : b;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220607084424542.png&quot; alt=&quot;合并K个升序链表&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
</feed>
