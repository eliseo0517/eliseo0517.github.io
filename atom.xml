<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eliseo的小屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-29T06:49:08.972Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mr.Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树的深度</title>
    <link href="http://example.com/2022/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://example.com/2022/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-04-29T06:48:08.000Z</published>
    <updated>2022-04-29T06:49:08.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/image-20220429144838269.png" alt="image-20220429144838269"></p><p><strong>解法：(递归)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/image-20220429144838269.png&quot; alt=&quot;image-20220429144838269&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2022/04/29/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/04/29/%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-29T04:44:27.000Z</published>
    <updated>2022-04-30T09:12:23.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>最差情况下时间复杂度为O(N^2)</strong></p><p><strong>时间复杂度最低的快速排序，</strong>在数组中随机找一个数，然后将他与最后一个数字交换，然后以最后一个数字为num进行荷兰国旗问题，同时在小于和大于num的区域随机选取一个数字，然后将他与小于和大于num区域的最后一个数字交换重复执行荷兰国旗问题，最后得到一串从小到大排序的数组，<strong>时间复杂度为O(N*logN)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    quickSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//arr[l...r]排好序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;R)&#123;<br>        swap(arr,L+(<span class="hljs-keyword">int</span>) (Math.random() * (R-L+<span class="hljs-number">1</span>)), R); <span class="hljs-comment">//swap为自带的交换函数；L+(int) (Math.random() * (R-L+1)) 表示在该数组中随机选取一位数字</span><br>        <span class="hljs-keyword">int</span>[] p = partition(arr,L,R);<br>        quitSort(arr,L,p[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>); <span class="hljs-comment">// &lt;区</span><br>        quitSort(arr,p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,R); <span class="hljs-comment">// &gt;区</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//这是一个处理arr[l...r]的函数</span><br><span class="hljs-comment">//默认以arr[r]做划分，arr[r] -&gt; p    &lt;p   ==p    &gt;p</span><br><span class="hljs-comment">//返回等于区域（左边界，右边界），所以返回一个长度为2的数组res，res[0] res[1]</span><br><span class="hljs-keyword">public</span> staic <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)&#123;<br>    <span class="hljs-keyword">int</span> less = L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt;区右边界</span><br>    <span class="hljs-keyword">int</span> more = R; <span class="hljs-comment">// &gt;区左边界</span><br>    <span class="hljs-keyword">while</span>(L &lt; more)&#123; <span class="hljs-comment">// L表示当前数的位置 arr[R] -&gt; 划分值</span><br>        <span class="hljs-keyword">if</span>(arr[L] &lt; arr[R])&#123; <span class="hljs-comment">//当前数  &lt;  划分值</span><br>            less++;<br>            swap(arr, less, L);<br>            L++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[L] &gt; arr[R])&#123; <span class="hljs-comment">// 当前值 &gt; 划分值</span><br>            more--;<br>            swap(arr, more, L);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            L++;<br>        &#125;<br>    &#125;<br>    swap(arr,more,R);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;less + <span class="hljs-number">1</span>,more&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><p><strong>1、在一个有序数组中，找某个数是否存在</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有序，小到大查找某值.</span><br><span class="hljs-keyword">int</span> fir=<span class="hljs-number">0</span>,last=arr_length-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (fir&lt;=last)&#123;<br>mid=(fir+last)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (arr[mid]==num)<br><span class="hljs-keyword">return</span> mid;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span> (arr[mid]&lt;num)<br>fir=mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>last=mid-<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>2、在一个有序数组中，找&gt;=某个数最左侧的位置（找&lt;=某个数最右侧的位置）</strong>                </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> fir=<span class="hljs-number">0</span>,last=arr_length-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (fir&lt;=last)&#123;<br>mid=(fir+last)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>  (arr[mid]&gt;=num)<br>last=mid-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> (arr[mid]&lt;num)<br>ir=mid+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>1、堆结构就是用数组实现完全的二叉树结构</p><p>2、完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p><p>3、完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p><p>4、对结构的heapInsert与heapify操作</p><p>5、堆结构的增大和减少</p><p>6、优先级队列结构，就是堆结构</p><p><strong>大根堆</strong>即指在逻辑上的二叉树结构中，根结点&gt;子结点，总是最大的，<strong>并且在堆的每一个局部都是如此</strong></p><p><strong>小根堆</strong>的性质与大根堆类似，只不过在二叉树的结构中，根结点&lt;子结点</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img src="/2022/04/29/%E7%AE%97%E6%B3%95/image-20220430115218088.png" alt="image-20220430115218088"></p><h2 id="使用递归实现："><a href="#使用递归实现：" class="headerlink" title="使用递归实现："></a><strong>使用递归实现：</strong></h2><p><strong>先序遍历(头左右)：</strong>每一次第一次到达节点就打印</p><p><strong>中序遍历(左头右)：</strong>每一次第二次到达节点就打印</p><p><strong>后序遍历(左右头)：</strong>每一次最后一次到达节点就打印</p><p><strong>使用递归实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bianli</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = data;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历二叉树</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        f(head.left);<br>        f(head.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 先序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderRecur</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>        preOrderRecur(head.left);<br>        preOrderRecur(head.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderRecur</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inOrderRecur(head.left);<br>        System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>        inOrderRecur(head.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">posOrderRecur</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>        posOrderRecur(head.left);<br>        posOrderRecur(head.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用非递归实现（栈）："><a href="#使用非递归实现（栈）：" class="headerlink" title="使用非递归实现（栈）："></a><strong>使用非递归实现（栈）：</strong></h2><p><strong>先序遍历(头左右)：</strong></p><p>前提：先将根节点加入栈中</p><p>1、每次从栈中弹出一个节点cur</p><p>2、打印（处理）cur</p><p>3、先把cur右孩子压到栈里，再把cur左孩子压到栈里去，如果有的左右孩子的话</p><p>4、周而复始</p><p><strong>中序遍历(左头右)：</strong></p><p><img src="/2022/04/29/%E7%AE%97%E6%B3%95/image-20220430171115049.png" alt="image-20220430171115049"></p><p><strong>每次都是左头右，然后把右当作头，综上所述最后都是左头左头</strong></p><p>1、每一棵子树整棵树左边界进栈</p><p>2、依次弹出每一个节点的过程中，打印</p><p>3、看看这个弹出的节点是否有右树，没有就继续弹出栈内的节点</p><p>3、有右树就对右树进行第一步</p><p><strong>后序遍历(左右头)：</strong></p><p>前提：多加一个收集栈，先将根节点加入栈中</p><p>1、每次从栈中弹出一个节点cur</p><p>2、把当前节点（cur）放到收集栈里去</p><p>3、先把cur左孩子压到栈里，再把cur右孩子压到栈里去，如果有的左右孩子的话</p><p>4、周而复始</p><p>5、最后弹出收集栈<strong>（左右头）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bianli</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = data;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 非递归（栈）先序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">perOrderUnRecur</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;per-order&quot;</span>);<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>            stack.add(head);<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                head = stack.pop();<br>                System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>                <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;<br>                    stack.push(head.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;<br>                    stack.push(head.left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">// 非递归（栈）中序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderUnRecur</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in-order&quot;</span>);<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>                    stack.push(head);<br>                    head = head.left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    head = stack.pop();<br>                    System.out.println(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>                    head = head.right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">// 非递归（栈）后序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">posOrderUnRecur</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;pos-order&quot;</span>);<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>            Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>            s1.push(head);<br>            <span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;<br>                head = s1.pop();<br>                s2.push(head);<br>                <span class="hljs-keyword">if</span> (head.left != <span class="hljs-keyword">null</span>) &#123;<br>                    s1.push(head.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (head.right != <span class="hljs-keyword">null</span>) &#123;<br>                    s1.push(head.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;<br>                System.out.println(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最差情况下时间复杂度为O(N^2)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度最低的快速排序</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据流中的中位数</title>
    <link href="http://example.com/2022/04/29/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://example.com/2022/04/29/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2022-04-29T04:39:23.000Z</published>
    <updated>2022-04-29T04:44:13.832Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/29/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220429124407888.png" alt="数据流中的中位数"></p><p><strong>大根堆</strong>即指在逻辑上的二叉树结构中，根结点&gt;子结点，总是最大的，<strong>并且在堆的每一个局部都是如此</strong></p><p><strong>小根堆</strong>的性质与大根堆类似，只不过在二叉树的结构中，根结点&lt;子结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>   <span class="hljs-comment">//小根堆</span><br>    PriorityQueue&lt;Integer&gt; A;<br>    <span class="hljs-comment">//大根堆</span><br>    PriorityQueue&lt;Integer&gt; B;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;<br>        A = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; (y - x));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (A.size() != B.size()) &#123;<br>            <span class="hljs-comment">// 两个堆</span><br>            A.add(num);<br>            B.add(A.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            B.add(num);<br>            A.add(B.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (A.size() == B.size()) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>) (A.peek() + B.peek())/<span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//奇数，直接返回小的堆顶</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)A.peek();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj.addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/29/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220429124407888.png&quot; alt=&quot;数据流中的中位数</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>扑克牌中的顺子</title>
    <link href="http://example.com/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <id>http://example.com/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</id>
    <published>2022-04-28T08:59:59.000Z</published>
    <updated>2022-04-28T09:08:47.493Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/image-20220428170008577.png" alt="扑克牌中的顺子"></p><p><strong>解法：（排序）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义大小王的数量</span><br>        <span class="hljs-keyword">int</span> jocker = <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<span class="hljs-comment">// 对nums进行排序（可以判断大小王的数量）</span><br>        <span class="hljs-comment">// 为什么i &lt; 4 因为需要判断这个数与后面的数是否重复，i &lt; 4</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                jocker++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[jocker] &lt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/image-20220428170008577.png&quot; alt=&quot;扑克牌中的顺子&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>把数组排成最小的数</title>
    <link href="http://example.com/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://example.com/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</id>
    <published>2022-04-28T08:34:20.000Z</published>
    <updated>2022-04-28T08:35:00.170Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/image-20220428163449786.png" alt="把数组排成最小的数"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/image-20220428163449786.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第k大节点</title>
    <link href="http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-28T08:26:32.000Z</published>
    <updated>2022-04-28T08:31:29.371Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/image-20220428162801246.png" alt="二叉搜索树的第k大节点"></p><p><strong>解法：</strong></p><p>二叉搜索树：右节点大，所以判断第几大的时候就先遍历右节点，然后右节点遍历一次 k–，直到k变成1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-keyword">int</span> res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            res = root.val;<br>        &#125;<br>        k--;<br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/image-20220428162801246</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与双向链表</title>
    <link href="http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-28T07:16:40.000Z</published>
    <updated>2022-04-28T08:20:13.318Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20220428151835975.png" alt="二叉搜索树与双向链表"></p><p><strong>解法：（中序遍历）</strong></p><p><strong>二叉搜索树：</strong>若它的左子树不空，则左子树上所有结点的值均小于它的 根结点 的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为 二叉排序树 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node left;</span><br><span class="hljs-comment">    public Node right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Node pre, head;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        dfs(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span>) pre.right = cur;<br>        <span class="hljs-keyword">else</span> head = cur;<br>        cur.left = pre;<br>        pre = cur;<br>        dfs(cur.right);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/image-20220428151835975.</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中何为某一值的路径</title>
    <link href="http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-04-28T06:32:12.000Z</published>
    <updated>2022-04-28T06:33:29.901Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428143306147.png" alt="二叉树中何为某一值的路径"><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>   <span class="hljs-comment">// list:子树的和</span><br>    <span class="hljs-comment">// res:结果集</span><br>    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        dfs(root, target, sum);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-comment">//等于空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        list.add(root.val);<br>        <span class="hljs-comment">//符合情况,即叶子节点加之前的sum等于target</span><br>        <span class="hljs-keyword">if</span> (sum + root.val == target &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(list));<br>        &#125;<br>        dfs(root.left, target, sum + root.val);<br>        dfs(root.right, target, sum + root.val);<br>        <span class="hljs-comment">// sum -= root.val;</span><br>        <span class="hljs-comment">//清除list</span><br>        list.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BD%95%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/image-</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="http://example.com/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>http://example.com/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2022-04-28T02:45:14.000Z</published>
    <updated>2022-04-28T02:46:14.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220428104546299.png" alt="机器人的运动范围"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 用来判断格子是否已经被走过</span><br>        <span class="hljs-keyword">boolean</span>[][] istrue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n, k, istrue);<br>    &#125;<br><br>    <span class="hljs-comment">// a,b当前位置；</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">boolean</span>[][] istrue)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n<br>                &amp;&amp; (a % <span class="hljs-number">10</span> + a / <span class="hljs-number">10</span> + a / <span class="hljs-number">100</span> + b % <span class="hljs-number">10</span> + b / <span class="hljs-number">10</span> + b / <span class="hljs-number">100</span>) &lt;= k<br>                &amp;&amp; istrue[a][b] == <span class="hljs-keyword">false</span>) &#123;<br>            istrue[a][b] = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// 1是(0,0)位置</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(a + <span class="hljs-number">1</span>, b, m, n, k, istrue)<br>                    + dfs(a - <span class="hljs-number">1</span>, b, m, n, k, istrue)<br>                    + dfs(a, b + <span class="hljs-number">1</span>, m, n, k, istrue)<br>                    + dfs(a, b - <span class="hljs-number">1</span>, m, n, k, istrue);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/image-20220428104546299.png&quot; alt=&quot;机器人的运动范围</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>矩阵中的路径</title>
    <link href="http://example.com/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://example.com/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-04-28T02:30:02.000Z</published>
    <updated>2022-04-28T02:31:39.758Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428103103367.png" alt="矩阵中的路径"></p><p><strong>解法：（DFS）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        <span class="hljs-comment">// toCharArray()将字符串转换为字符数组。</span><br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-comment">// 遍历board中的所有元素，将所有元素进行dfs()</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-comment">//如果找到，再返回true</span><br>                <span class="hljs-keyword">if</span> (dfs(board,chars,i,j,<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//数组，单词，长宽，宽度，k：第几个字母</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">char</span>[] chars,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//如果越界或者没找到字母</span><br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span> || m &gt; board.length - <span class="hljs-number">1</span> || n &lt;<span class="hljs-number">0</span> || n &gt; board[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> || board[m][n] != chars[k]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到了字母并且是最后一个</span><br>        <span class="hljs-keyword">if</span> (board[m][n] == chars[k] &amp;&amp; k == chars.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到字母但不是最后一个,就让他看他的上下左右，已经走过的让它变成~以防止再次访问，dfs之后要回退，因为在下一次dfs时候还可能再次访问这个格子</span><br>        <span class="hljs-keyword">char</span> s =  board[m][n] ;<br>        board[m][n] = <span class="hljs-string">&#x27;~&#x27;</span>;<br>        <span class="hljs-keyword">boolean</span> res =  dfs(board,chars,m + <span class="hljs-number">1</span>,n,k + <span class="hljs-number">1</span>) || dfs(board,chars,m,n + <span class="hljs-number">1</span>,k + <span class="hljs-number">1</span>) || dfs(board,chars,m - <span class="hljs-number">1</span>,n,k + <span class="hljs-number">1</span>) || dfs(board,chars,m,n - <span class="hljs-number">1</span>,k + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 四个格子都尝试了之后 恢复到原来的样子</span><br>        board[m][n] = s;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/image-20220428103103367.png&quot; alt=&quot;矩阵中的路径&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>翻转单词顺序</title>
    <link href="http://example.com/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-04-26T13:47:35.000Z</published>
    <updated>2022-04-26T13:49:36.235Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/image-20220426214848087.png" alt="翻转单词顺序"></p><p><strong>解法：（快慢指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 去掉首位的空格</span><br>        s = s.trim();<br>        <span class="hljs-comment">// 加入两个快慢指针</span><br>        <span class="hljs-keyword">int</span> i = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = s.length() - <span class="hljs-number">1</span>;<br>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 当i不是空格的时候 往左遍历</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            <span class="hljs-comment">// j指向下一个单词</span><br>            j = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/image-20220426214848087.png&quot; alt=&quot;翻转单词顺序&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>和为s的两个数字</title>
    <link href="http://example.com/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</id>
    <published>2022-04-26T08:24:20.000Z</published>
    <updated>2022-04-26T08:29:56.762Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/image-20220426162523495.png" alt="和为s的两个数字"></p><p><strong>解法：（左右指针）</strong></p><p>定义左右指针，左右指针的值的和sum，如果sum&gt;target，那么右指针往左；如果sum&lt;target，那么左指针往右；如果sum== target，那么输出数组[nums[i],nums[j]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> sum = nums[i] + nums[j];<br>            <span class="hljs-keyword">if</span> (sum &lt; target)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;nums[i],nums[j]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/image-20220426162523495.png&quot; alt=&quot;和为s的两个数字&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <link href="http://example.com/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://example.com/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</id>
    <published>2022-04-26T07:57:28.000Z</published>
    <updated>2022-04-26T08:01:33.840Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/image-20220426155826475.png" alt="调整数组顺序使奇数位于偶数前面"></p><p><strong>解法：（左右指针）</strong></p><p>左指针指向偶数的时候，右指针指向奇数的时候就左右指针的值通过一个中间值进行交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tmp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[left] % <span class="hljs-number">2</span>) == <span class="hljs-number">1</span>) left++;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[right] % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) right--;<br>            tmp = nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>两个链表的第一个公共节点</title>
    <link href="http://example.com/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-26T07:30:36.000Z</published>
    <updated>2022-04-26T07:38:25.373Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/image-20220426153130626.png" alt="两个链表的第一个公共节点"></p><p><strong>解法：（双指针）</strong></p><p>假设链表headA有a个节点，链表headB有b个节点，公共节点距离链表尾部有c个节点；</p><p>那么链表headA从开始到公共节点有a-c个节点，链表headB从开始到公告节点有b-c个节点，</p><p>当链表headA的指针A遍历完链表headA之后遍历链表headB，当走到公共节点的时候一共走了a-c+c+b-c = a+b-c步数</p><p>当链表headB的指针B遍历完链表headB之后遍历链表headA，当走到公共节点的时候一共走了b-c+c+a-c = b+a-c步数</p><p>此时</p><p>1、A与B重合若两链表 有公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node</p><p>2、若两链表 无 公共尾部 (即 c = 0 ) ：指针 A，B 同时指向 null 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        ListNode A = headA;<br>        ListNode B = headB;<br>        <span class="hljs-keyword">while</span> (A != B) &#123;<br>            A = A != <span class="hljs-keyword">null</span> ? A.next : headB;<br>            B = B != <span class="hljs-keyword">null</span> ? B.next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/image-</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="http://example.com/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-26T06:52:38.000Z</published>
    <updated>2022-04-26T06:55:22.984Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220426145316487.png" alt="合并两个排序的链表"></p><p><strong>解法一：（双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br><br>    ListNode(<span class="hljs-keyword">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义一个伪节点</span><br>        ListNode a = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode cur = a;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = (l1 != <span class="hljs-keyword">null</span> ? l1 : l2);<br>        <span class="hljs-keyword">return</span> a.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（递归）</strong></p><p>一个一个节点的判断，l1的头节点与l2的头节点进行比较，然后节点往下判断下一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br><br>    ListNode(<span class="hljs-keyword">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/26/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220426145316487.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数第k个节点</title>
    <link href="http://example.com/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-25T14:32:21.000Z</published>
    <updated>2022-04-25T14:54:22.319Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220425223235483.png" alt="链表中倒数第k个节点"></p><p><strong>解法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br><br>        <span class="hljs-comment">// 先让快的走k个距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 当快的走到了最后的时候，慢的链表就是所要求的链表</span><br>        <span class="hljs-keyword">while</span> (fast!=<span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220425223235483.png&quot; alt</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的节点</title>
    <link href="http://example.com/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2022-04-25T13:37:58.000Z</published>
    <updated>2022-04-25T13:45:44.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/image-20220425213903008.png" alt="删除链表的节点"></p><p><strong>解法一：（双节点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<br>        ListNode pre = head;<br>        ListNode cur = head.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span> &amp;&amp; cur.val != val) &#123;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//证明找到了要删除的节点,跳过这个要删除的节点</span><br>            pre.next = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（递归）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            <span class="hljs-comment">// 如果发现你的这个节点的值就是所要求的值，那么直接跳过这个节点</span><br>            head = head.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则自调</span><br>            head.next = deleteNode(head.next, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/image-20220425213903008.png&quot; alt=&quot;删除链表的节点&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <link href="http://example.com/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-04-25T08:18:12.000Z</published>
    <updated>2022-04-25T08:21:39.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425161854980.png" alt="最长不含重复字符的子字符串"></p><p><strong>解法一：</strong>（哈希表+动态规划）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// res结果 tmp当前长度</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>            <span class="hljs-comment">//找到j左边最近的与j位置字母相等的字母</span><br>            <span class="hljs-keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//找到的话就将这个字母置于j位置，没找到的话j位置置为-1</span><br>            dic.put(s.charAt(j), j);<br>            <span class="hljs-keyword">if</span> (tmp &lt; j - i) &#123;<br>                <span class="hljs-comment">//如果tmp &lt; j - i，就证明，没有遇到相同的字母，长度+1</span><br>                tmp = tmp + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//否则就是遇到了相等的字母，则左边界就应该由i来决定</span><br>                tmp = j - i;<br>            &#125;<br>            res = Math.max(res, tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓展：</p><div class="note note-success">            <p>哈希表的getOrDefault(key, default)方法，是在哈希表中搜索是否存在该方法参数列表中的key值，如果存在该key值，则返回哈希表中该key值对应的vakue值；如果不存在，则返回该方法参数列表中的default值</p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>把数字翻译成字符串</title>
    <link href="http://example.com/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-04-25T07:37:45.000Z</published>
    <updated>2022-04-25T07:39:49.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425153822764.png" alt="把数字翻译成字符串"></p><p><strong>解法：</strong></p><p>看见题就能想到要不两个数字作为一个字符输出，要不一个数字作为一个字符输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">// 把数字变成string类型</span><br>        String s = String.valueOf(num);<br>        <span class="hljs-comment">// 如果不+1，如果我给的num长度为3，那么转换成string类型长度也为3</span><br>        <span class="hljs-comment">// 到了for循环的时候从2开始就拿不到2个就出现越界问题</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 当num第1,2位的组成的数字∈[10,25]时，显然应有2种翻译方法，</span><br>        <span class="hljs-comment">// 即dp[2]=dp[1]+dp[0]=2，而显然dp[1] = 1因此推出dp[0] = 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-comment">// 取出两位</span><br>            <span class="hljs-comment">// substring这个方法截取的字符串从i-2开始，到字符串索引的i - 1结束</span><br>            String tmp = s.substring(i - <span class="hljs-number">2</span>, i);<br>            <span class="hljs-comment">// 如果两位数的ASCII码差值在10~25之间 证明可以转换成为一个字符</span><br>            <span class="hljs-keyword">if</span> (tmp.compareTo(<span class="hljs-string">&quot;10&quot;</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp.compareTo(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 一位计算</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220425153822764.png&quot; alt=</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>礼物的最大价值</title>
    <link href="http://example.com/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <id>http://example.com/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</id>
    <published>2022-04-25T02:42:24.000Z</published>
    <updated>2022-04-25T02:50:55.069Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220425104246376.png" alt="礼物的最大价值"></p><p><strong>解法一：</strong></p><p>暴力递归，对于一个格子只有两种情况：不是向下移动就是向右移动，所以定义两个变量，一个 == 向右移动的值 一个 == 向下移动的值 ，然后取max + 这个格子左上角的值</p><p>代码 <em>略</em></p><p><strong>解法二：</strong></p><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test14</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义行和列</span><br>        <span class="hljs-keyword">int</span> row = grid.length;<br>        <span class="hljs-keyword">int</span> column = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 多加一行一列 所以dp[1][0..column]相当于grid[0][0...column]</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row + <span class="hljs-number">1</span>][column + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[1][0..column]相当于grid[0][0...column] 所以i与j从1开始 直到 等于行与列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= column; j++) &#123;<br>                dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row][column];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] grid = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        System.out.println(maxValue(grid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/04/25/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20220425104246376.png&quot; alt=&quot;礼物的最大价值&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="剑指Offer" scheme="http://example.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="剑指Offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
