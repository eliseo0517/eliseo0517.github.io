<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eliseo的小屋</title>
  
  
  <link href="https://eliseo.top/atom.xml" rel="self"/>
  
  <link href="https://eliseo.top/"/>
  <updated>2022-07-10T01:34:33.236Z</updated>
  <id>https://eliseo.top/</id>
  
  <author>
    <name>Mr.Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM</title>
    <link href="https://eliseo.top/2022/07/08/JVM-1/"/>
    <id>https://eliseo.top/2022/07/08/JVM-1/</id>
    <published>2022-07-08T02:33:45.000Z</published>
    <updated>2022-07-10T01:34:33.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h1><h2 id="1-1、运行时数据区"><a href="#1-1、运行时数据区" class="headerlink" title="1.1、运行时数据区"></a>1.1、运行时数据区</h2><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="1-1-1、程序计数器"><a href="#1-1-1、程序计数器" class="headerlink" title="1.1.1、程序计数器"></a>1.1.1、程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p><img src="/2022/07/08/JVM-1/image-20220604110733931.png"></p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><img src="/2022/07/08/JVM-1/image-20220604143627082.png" alt="pc寄存器的使用场景"></p><h3 id="1-1-2、Java虚拟机栈"><a href="#1-1-2、Java虚拟机栈" class="headerlink" title="1.1.2、Java虚拟机栈"></a>1.1.2、Java虚拟机栈</h3><p>虚拟机栈<strong>是线程私有的</strong>，<code>生命周期与线程一样</code>，随着线程的存在而存在，随着线程的消亡而消亡。</p><p>除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><p><img src="https://javaguide.cn/assets/stack.357796df.png" alt="栈"></p><p><img src="/2022/07/08/JVM-1/image-20220606093338725.png" alt="栈帧的基本结构"></p><p><strong>局部变量表：</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>操作数栈：</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接(指向运行时常量池的方法引用)：</strong> 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/jvmimage-20220331175738692.png" alt="img"></p><p><strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><h3 id="1-1-3、本地方法栈"><a href="#1-1-3、本地方法栈" class="headerlink" title="1.1.3、本地方法栈"></a>1.1.3、本地方法栈</h3><p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p><h3 id="1-1-4、堆"><a href="#1-1-4、堆" class="headerlink" title="1.1.4、堆"></a>1.1.4、堆</h3><p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆</strong>；Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p><strong>堆空间的细分</strong></p><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</p><ul><li>Java7及之前堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>永久区</strong><ul><li>新生区又被分为eden(伊甸)区和Survivor(幸存者)区 幸存者区又分为幸存者1区(from区)和幸存者2区(to区)</li></ul></li><li>Java8及之后堆内存<strong>逻辑上</strong>分为三部分:新生区+养老区+<strong>元空间</strong></li><li>新生区&lt;=&gt;新生代&lt;=&gt;年轻代 养老区&lt;=&gt;老年区&lt;=&gt;老年代 永久区&lt;=&gt;永久代</li><li>堆大小=新生区+养老区，元空间或者永久区有他自己的大小</li><li><strong>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。</strong></li></ul><p><img src="https://javaguide.cn/assets/hotspot-heap-structure.784465da.png" alt="hotspot-heap-structure"></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><hr><p><strong>为什么要建立两个Survivor区？</strong><br>建立两个Survivor区，分别是S0和S1（From和To），MinorGC流程如下：</p><p>把new的对象放在Eden区中，一旦Eden满了，触发一次Minor GC，Eden区中存活的对象会送到S0中，Eden被清空；再次new对象放入Eden区中，Eden又满了，触发Minor GC，Eden和S0中存活的对象放入到S1中，然后S0和Eden清空，然后S0和S1交换角色，S1变成了S0，作为下一次GC的主要目标，S0变成了S1，存放下一次GC存活的对象。<br>如此循环往复，对象头的分代年龄达到16次，则会被送到老年代中。</p><h3 id="1-1-5、方法区"><a href="#1-1-5、方法区" class="headerlink" title="1.1.5、方法区"></a>1.1.5、方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，<u>是各个线程共享的内存区域。</u>他的实际的物理内存空间可以是<u>不连续的</u>。关闭JVM就会释放这个区域的内存</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src="https://javaguide.cn/assets/method-area-implementation.68e9c9cd.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>元空间不在虚拟机设置的内存中，而是使用本地内存。永久代因为使用的是虚拟机设置的内存，所以会出现OOM，但是将永久代替换为原空间以后就没有这个问题。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:PermSize=N <span class="hljs-comment">//方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的初始（和最小大小）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">//设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></p><h3 id="1-1-6、运行时常量池"><a href="#1-1-6、运行时常量池" class="headerlink" title="1.1.6、运行时常量池"></a>1.1.6、运行时常量池</h3><p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 <code>将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)</code>。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。<br><strong>方法区的Class文件信息，Class常量池和运行时常量池的三者关系</strong></p><p><img src="/2022/07/08/JVM-1/image-20220708232527703.png"></p><h3 id="1-1-7、字符串常量池"><a href="#1-1-7、字符串常量池" class="headerlink" title="1.1.7、字符串常量池"></a>1.1.7、字符串常量池</h3><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是字符串常量池。<strong>字符串常量池由String类私有的维护</strong>。</p><p>DK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><img src="https://javaguide.cn/assets/method-area-jdk1.6.02db832c.png" alt="img"></p><p><img src="https://javaguide.cn/assets/method-area-jdk1.7.eaf4234f.png" alt="img"></p><p><img src="https://javaguide.cn/assets/method-area-jdk1.8.b19d81f7.png" alt="img"></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h3 id="1-1-8、直接内存"><a href="#1-1-8、直接内存" class="headerlink" title="1.1.8、直接内存"></a>1.1.8、直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。</p><p>通常，访问直接内存的速度会优于Java堆，即读写性能高。</p><h2 id="1-2、HotSpot-虚拟机对象探秘"><a href="#1-2、HotSpot-虚拟机对象探秘" class="headerlink" title="1.2、HotSpot 虚拟机对象探秘"></a>1.2、HotSpot 虚拟机对象探秘</h2><h3 id="1-2-1、对象的创建过程"><a href="#1-2-1、对象的创建过程" class="headerlink" title="1.2.1、对象的创建过程"></a>1.2.1、对象的创建过程</h3><p><img src="https://img-blog.csdnimg.cn/07d02dbb0e3546b6a720b0d277a03889.png" alt="对象的创建过程"></p><h4 id="Step1：类加载检查"><a href="#Step1：类加载检查" class="headerlink" title="Step1：类加载检查"></a>Step1：类加载检查</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace（元空间）的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2：分配内存"><a href="#Step2：分配内存" class="headerlink" title="Step2：分配内存"></a>Step2：分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p><p><strong>如果内存规整</strong>：虚拟机将采用的是<code>指针碰撞法（Bump The Point）</code>来为对象分配内存。</p><ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul><p><strong>如果内存不规整：</strong>虚拟机需要维护一个<code>空闲列表（Free List）</code>来为对象分配内存。</p><ul><li>虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul><p><strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong><code>内存分配并发问题（补充内容，需要掌握）</code></strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。通过设置 <code>-XX:+UseTLAB</code>参数来设定</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法进行初始化"><a href="#Step5-执行-init-方法进行初始化" class="headerlink" title="Step5:执行 init 方法进行初始化"></a>Step5:执行 init 方法进行初始化</h4><p>从 Java 程序的视角来看，对象创建才刚开始，<code>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="1-2-2、对象的内存布局"><a href="#1-2-2、对象的内存布局" class="headerlink" title="1.2.2、对象的内存布局"></a>1.2.2、对象的内存布局</h3><p><img src="https://img-blog.csdnimg.cn/a97a450c6432470f94dd97bd4c3d4dac.png" alt="对象的内存布局"></p><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></p><h3 id="1-2-3对象的访问定位"><a href="#1-2-3对象的访问定位" class="headerlink" title="1.2.3对象的访问定位"></a>1.2.3对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</p><p><img src="https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.1cf25227.png" alt="对象的访问定位-使用句柄"></p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 <strong>reference 中存储的直接就是对象的地址。</strong></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。</p><p><img src="https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.9bfd6702.png" alt="对象的访问定位-直接指针"></p><h1 id="二、JVM垃圾回收"><a href="#二、JVM垃圾回收" class="headerlink" title="二、JVM垃圾回收"></a>二、JVM垃圾回收</h1><h2 id="2-1、-JVM-内存分配与回收"><a href="#2-1、-JVM-内存分配与回收" class="headerlink" title="2.1、 JVM 内存分配与回收"></a>2.1、 JVM 内存分配与回收</h2><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆</strong>。 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://javaguide.cn/assets/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.c5bf5d75.png" alt="img"></p><p>Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><h3 id="2-1-1、对象优先在Eden区分配"><a href="#2-1-1、对象优先在Eden区分配" class="headerlink" title="2.1.1、对象优先在Eden区分配"></a>2.1.1、对象优先在Eden区分配</h3><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><h3 id="2-1-2、大对象直接进入老年代"><a href="#2-1-2、大对象直接进入老年代" class="headerlink" title="2.1.2、大对象直接进入老年代"></a>2.1.2、大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="2-1-3、长期存活的对象将进入老年代"><a href="#2-1-3、长期存活的对象将进入老年代" class="headerlink" title="2.1.3、长期存活的对象将进入老年代"></a>2.1.3、长期存活的对象将进入老年代</h3><p>对象通常在Eden区里诞生，如果经过第一次Minor GC还存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄加+1，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。</p><h3 id="2-1-4、动态对象年龄判定"><a href="#2-1-4、动态对象年龄判定" class="headerlink" title="2.1.4、动态对象年龄判定"></a>2.1.4、动态对象年龄判定</h3><p>HopStop虚拟机并不是永远要求对象的年龄必须达到<code>-XX：MaxTenuringThreshold</code>才能晋升老年代，如果在<strong>survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半</strong>，年龄大于等于该年龄的对象就可以直接进入老年代。无需等到MaxTenuringThreshold中要求的年龄。</p><h3 id="2-1-5、空间分配担保"><a href="#2-1-5、空间分配担保" class="headerlink" title="2.1.5、空间分配担保"></a>2.1.5、空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><hr><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区</p><h2 id="2-2、判断对象是否已经死亡"><a href="#2-2、判断对象是否已经死亡" class="headerlink" title="2.2、判断对象是否已经死亡"></a>2.2、判断对象是否已经死亡</h2><h3 id="2-2-1、引用计数法"><a href="#2-2-1、引用计数法" class="headerlink" title="2.2.1、引用计数法"></a>2.2.1、引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><hr><p><strong>循环引用：</strong></p><p><img src="https://img-blog.csdnimg.cn/ef82e7291ec74d78aeea2fe36232c765.png" alt="循环引用"></p><h3 id="2-2-2、可达性分析算法"><a href="#2-2-2、可达性分析算法" class="headerlink" title="2.2.2、可达性分析算法"></a>2.2.2、可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p><p><img src="https://javaguide.cn/assets/jvm-gc-roots.39234b20.png" alt="可达性分析算法"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="2-2-3、引用"><a href="#2-2-3、引用" class="headerlink" title="2.2.3、引用"></a>2.2.3、引用</h3><p>引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>如果一个对象有强引用，那么就相当于是生活中<strong>必不可少的生活用品</strong>，哪怕内存空间不足，jvm哪怕抛出异常也不愿意随意回收具有强引用的对象</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象有软引用，那么就相当于是生活中<strong>可有可无的生活用品</strong>，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收。</strong></p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用<strong>必须</strong>和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-2-4、如何判断一个常量是废弃常量？"><a href="#2-2-4、如何判断一个常量是废弃常量？" class="headerlink" title="2.2.4、如何判断一个常量是废弃常量？"></a>2.2.4、如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="2-2-5、如何判断一个类是无用的类？"><a href="#2-2-5、如何判断一个类是无用的类？" class="headerlink" title="2.2.5、如何判断一个类是无用的类？"></a>2.2.5、如何判断一个类是无用的类？</h3><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的<strong>仅仅是“可以”</strong>，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="2-3、垃圾收集算法"><a href="#2-3、垃圾收集算法" class="headerlink" title="2.3、垃圾收集算法"></a>2.3、垃圾收集算法</h2><h3 id="2-3-1、标记-清除算法"><a href="#2-3-1、标记-清除算法" class="headerlink" title="2.3.1、标记-清除算法"></a>2.3.1、标记-清除算法</h3><p>分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。<strong>它是最基础的收集算法。</strong></p><p>但是会有<strong>两个问题</strong>：</p><p>1、效率问题</p><p>2、空间问题（标记清除后，会产生大量不连续的碎片）</p><p><img src="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg" alt="标记-清除算法"></p><h3 id="2-3-2、标记-复制算法"><a href="#2-3-2、标记-复制算法" class="headerlink" title="2.3.2、标记-复制算法"></a>2.3.2、标记-复制算法</h3><p>可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://javaguide.cn/assets/90984624.e8c186ae.png" alt="标记-复制算法"></p><h3 id="2-3-3、标记-整理算法"><a href="#2-3-3、标记-整理算法" class="headerlink" title="2.3.3、标记-整理算法"></a>2.3.3、标记-整理算法</h3><p>标记过程与标记-清除算法一样，但是后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://javaguide.cn/assets/94057049.22c58294.png" alt="标记-整理算法 "></p><h3 id="2-3-4、分代收集算法"><a href="#2-3-4、分代收集算法" class="headerlink" title="2.3.4、分代收集算法"></a>2.3.4、分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h2 id="2-4、垃圾回收器"><a href="#2-4、垃圾回收器" class="headerlink" title="2.4、垃圾回收器"></a>2.4、垃圾回收器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><h3 id="2-4-1、Serial-收集器（串行回收）"><a href="#2-4-1、Serial-收集器（串行回收）" class="headerlink" title="2.4.1、Serial 收集器（串行回收）"></a>2.4.1、Serial 收集器（串行回收）</h3><p>串行收集器是一个<strong>单线程</strong>收集器，不仅仅意味着他只会使用一个垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://javaguide.cn/assets/46873026.3a9311ec.png" alt=" Serial 收集器 "></p><p>但是 它<strong>简单而高效</strong></p><h3 id="2-4-2、ParNew-收集器（并行回收）"><a href="#2-4-2、ParNew-收集器（并行回收）" class="headerlink" title="2.4.2、ParNew 收集器（并行回收）"></a>2.4.2、ParNew 收集器（并行回收）</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="ParNew 收集器 "></p><p><strong><code>首要选择</code></strong></p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="2-4-3、Parallel-Scavenge-收集器（吞吐量优先的并行回收）"><a href="#2-4-3、Parallel-Scavenge-收集器（吞吐量优先的并行回收）" class="headerlink" title="2.4.3、Parallel Scavenge 收集器（吞吐量优先的并行回收）"></a>2.4.3、Parallel Scavenge 收集器（吞吐量优先的并行回收）</h3><p>标记-复制算法的多线程收集器，相比于ParNew收集器，他的关注点在 <strong>吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong></p><p>吞吐量表示在单位时间内通过某个网络或接口的数据量 ，包括全部上传和下载的流量。</p><p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="Parallel Scavenge 收集器 "></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p>JDK1.8默认使用的是 Parallel Scavenge + Parallel Old</p><h3 id="2-4-4、Serial-Old-收集器"><a href="#2-4-4、Serial-Old-收集器" class="headerlink" title="2.4.4、Serial Old 收集器"></a>2.4.4、Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="2-4-5、Parallel-Old-收集器"><a href="#2-4-5、Parallel-Old-收集器" class="headerlink" title="2.4.5、Parallel Old 收集器"></a>2.4.5、Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="2-4-6、CMS-收集器（低停顿时间）"><a href="#2-4-6、CMS-收集器（低停顿时间）" class="headerlink" title="2.4.6、CMS 收集器（低停顿时间）"></a>2.4.6、CMS 收集器（低停顿时间）</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。是一种基于标记-清楚算法实现的</strong></p><p>运转过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫</li></ul><p><img src="https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png" alt="CMS 垃圾收集器 "></p><p>主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="2-4-7、G1-收集器（区域化分代式）"><a href="#2-4-7、G1-收集器（区域化分代式）" class="headerlink" title="2.4.7、G1 收集器（区域化分代式）"></a>2.4.7、G1 收集器（区域化分代式）</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率<code>满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征</code>.</strong></p><p>侧重点在于<strong>回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）</strong></p><div class="note note-success">            <p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。Region中还有一类特殊的Humongous区域，专门用来存储大对象（只要超过了一个Region容量一半的对象）。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region 之中，G1的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待</p>          </div><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200730161610159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMjI4MTI4NDk=,size_16,color_FFFFFF,t_70" alt="G1运行过程"></p><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记：</strong>需要停顿线程，但是耗时很短，</li><li><strong>并发标记：</strong>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="2-4-8、ZGC-收集器"><a href="#2-4-8、ZGC-收集器" class="headerlink" title="2.4.8、ZGC 收集器"></a>2.4.8、ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><h1 id="三、类加载过程"><a href="#三、类加载过程" class="headerlink" title="三、类加载过程"></a>三、类加载过程</h1><h2 id="3-1、类的生命周期"><a href="#3-1、类的生命周期" class="headerlink" title="3.1、类的生命周期"></a>3.1、类的生命周期</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" alt="类的生命周期"></p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690785011/2F1143CD0902210BA8783DBC8CB76D0A" alt="类加载过程"></p><h2 id="3-2、类加载过程"><a href="#3-2、类加载过程" class="headerlink" title="3.2、类加载过程"></a>3.2、类加载过程</h2><p>加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="加载Class文件的过程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java内存区域&quot;&gt;&lt;a href=&quot;#一、Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;一、Java内存区域&quot;&gt;&lt;/a&gt;一、Java内存区域&lt;/h1&gt;&lt;h2 id=&quot;1-1、运行时数据区&quot;&gt;&lt;a href=&quot;#1-1、运行时数据区&quot;</summary>
      
    
    
    
    <category term="java面试" scheme="https://eliseo.top/categories/java%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="java面试" scheme="https://eliseo.top/tags/java%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="https://eliseo.top/2022/07/07/java%E9%9B%86%E5%90%88/"/>
    <id>https://eliseo.top/2022/07/07/java%E9%9B%86%E5%90%88/</id>
    <published>2022-07-07T12:41:24.000Z</published>
    <updated>2022-07-07T13:34:47.979Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全的集合：vector，hashtable，剩下的集合都不安全</p><h1 id="说说-List-Set-Queue-Map-四者的区别？"><a href="#说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="说说 List, Set, Queue, Map 四者的区别？"></a>说说 List, Set, Queue, Map 四者的区别？</h1><p><code>list:</code>有序的可重复的，一般对付排序的问题</p><p><code>set:</code>(注重独一无二的性质): 无序的、不可重复的。</p><p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p><h1 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h1><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>在传入（add）第一个参数的时候，源码中会调用<code>ensureCapacityInternal()</code>方法，当传入的参数&lt;10的时候，<code>ensureCapacityInternal()</code>方法会默认ArrayList的大小为10；</p><p>当传入的参数大于10个之后，会进入<code>grow()</code>方法，进行扩容</p><h1 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h1><p><strong>使用场景：</strong></p><p><code>comparable接口</code>一般用在实体类，实体类实现这个接口，然后可以通过重写<code>compareTo方法</code>，对实体类的<code>Integer</code>类型的参数进行比较。</p><p><code>Comparator接口</code>在实体类被实现，用于自定义比较一些非 <code>Integer</code>类型的参数进行比较，用于自定义比较。也可以用在方法中 使用一个自定义比较器实现自定义比较。</p><h1 id="Queue-与-Deque"><a href="#Queue-与-Deque" class="headerlink" title="Queue 与 Deque"></a>Queue 与 Deque</h1><p>Queue是单端队列，从一端插入，从另一端删除，遵循**先进先出(FIFO)**原则。</p><p><img src="/2022/07/07/java%E9%9B%86%E5%90%88/image-20220707212625845.png"></p><p>Deque是双端队列，队列两端均可以插入与删除。</p><p><img src="/2022/07/07/java%E9%9B%86%E5%90%88/image-20220707212700993.png"></p><p>实际上还有 <code>push()</code>方法与<code>pop()</code>方法，用于模拟栈</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>hashMap</code>可以存储null的k-v，但是作为k只能有一个null，value则是可以存在多个null，</p><p><code>TreeMap</code>自己本身默认是按照key的升序进行排列的，但是也可以自定义比较器</p><p><strong>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h1 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h1><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h1 id="hashCode-与-equals-的相关规定："><a href="#hashCode-与-equals-的相关规定：" class="headerlink" title="hashCode()与 equals() 的相关规定："></a><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</h1><ol><li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li><li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li><li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li><li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li><li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><h1 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="==与 equals 的区别"></a>==与 equals 的区别</h1><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方)；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程安全的集合：vector，hashtable，剩下的集合都不安全&lt;/p&gt;
&lt;h1 id=&quot;说说-List-Set-Queue-Map-四者的区别？&quot;&gt;&lt;a href=&quot;#说说-List-Set-Queue-Map-四者的区别？&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="java面试" scheme="https://eliseo.top/categories/java%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="java面试" scheme="https://eliseo.top/tags/java%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://eliseo.top/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://eliseo.top/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-07-07T08:12:23.000Z</published>
    <updated>2022-07-08T02:33:21.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、使用线程池的好处："><a href="#一、使用线程池的好处：" class="headerlink" title="一、使用线程池的好处："></a>一、使用线程池的好处：</h1><p>1、降低资源消耗</p><p>2、提高响应速度</p><p>3、提高线程的客观理性</p><h1 id="二、Executor框架"><a href="#二、Executor框架" class="headerlink" title="二、Executor框架"></a>二、Executor框架</h1><h2 id="2-1、Executor-框架结构"><a href="#2-1、Executor-框架结构" class="headerlink" title="2.1、Executor 框架结构"></a>2.1、Executor 框架结构</h2><h3 id="1、任务-Runnable-callable"><a href="#1、任务-Runnable-callable" class="headerlink" title="1、任务(Runnable/callable)"></a>1、任务(Runnable/callable)</h3><h3 id="2、任务的执行-Executor"><a href="#2、任务的执行-Executor" class="headerlink" title="2、任务的执行(Executor)"></a>2、任务的执行(Executor)</h3><p><strong>需要更多关注的是 <code>ThreadPoolExecutor</code>这个类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractExecutorService实现了ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ScheduledExecutorService继承ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScheduledExecutorService</span><br></code></pre></td></tr></table></figure><h3 id="3、异步计算的结果-Future"><a href="#3、异步计算的结果-Future" class="headerlink" title="3、异步计算的结果(Future)"></a>3、异步计算的结果(Future)</h3><p>将<code>runnable</code>与<code>callable</code>接口的实现类提交给<code>ThreadPoolExecutor</code> 执行，使用<code>submit()</code>方法会得到一个返回值</p><h2 id="2-2、执行流程"><a href="#2-2、执行流程" class="headerlink" title="2.2、执行流程"></a>2.2、执行流程</h2><p><img src="https://javaguide.cn/assets/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.36e59afa.png" alt="Executor 框架的使用示意图"></p><ol><li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li><li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable  task）</code>）。</li><li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li></ol><h1 id="三、ThreadPoolExecutor-类的简单介绍-重点"><a href="#三、ThreadPoolExecutor-类的简单介绍-重点" class="headerlink" title="三、ThreadPoolExecutor 类的简单介绍(重点)"></a>三、ThreadPoolExecutor 类的简单介绍<code>(重点)</code></h1><h2 id="1、类分析"><a href="#1、类分析" class="headerlink" title="1、类分析"></a>1、类分析</h2><p>ThreadPoolExecutor类 一共提供了四个构造方法</p><p>最长的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>其他的常见参数：</strong></p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程会一直等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ol><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220707162623783.png" alt="线程池中各个参数的关系"></p><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略：</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 此策略将丢弃最早的未处理的任务请求。</li></ul><p>当不指定<code>RejectedExecutionHandler</code>饱和策略的时候默认使用<code>ThreadPoolExecutor.AbortPolicy</code></p><h2 id="3-2、推荐使用ThreadPoolExecutor-创建线程池"><a href="#3-2、推荐使用ThreadPoolExecutor-创建线程池" class="headerlink" title="3.2、推荐使用ThreadPoolExecutor 创建线程池"></a>3.2、推荐使用<code>ThreadPoolExecutor</code> 创建线程池</h2><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</p><p><strong>使用<code>Executors</code> 创建线程池的弊端：</strong></p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li></ul><h3 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a><strong>创建方式：</strong></h3><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数实现（推荐）</strong><img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.d54a5992.png" alt="通过构造方法实现"></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</strong> 我们可以创建三种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li><code>FixedThreadPool</code></li><li><code>SingleThreadExecutor</code></li><li>CachedThreadPool</li></ul><p>对应 Executors 工具类中的方法如图所示：</p><p><img src="https://javaguide.cn/assets/Executors%E5%B7%A5%E5%85%B7%E7%B1%BB.4b0cbd16.png" alt="通过Executor 框架的工具类Executors来实现"></p><h1 id="四、ThreadPoolExecutor-使用-分析"><a href="#四、ThreadPoolExecutor-使用-分析" class="headerlink" title="四、ThreadPoolExecutor 使用+分析"></a>四、ThreadPoolExecutor 使用+分析</h1><h2 id="4-1、线程池原理分析"><a href="#4-1、线程池原理分析" class="headerlink" title="4.1、线程池原理分析"></a>4.1、线程池原理分析</h2><p><strong><code>excute</code>方法(提交一个任务到线程池中去)详解：</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p><p><strong><code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</strong></p><h2 id="4-2、常见对比"><a href="#4-2、常见对比" class="headerlink" title="4.2、常见对比"></a>4.2、常见对比</h2><h3 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h3><p><strong><code>Runnable</code>接口</strong>不会返回结果或抛出异常，但是 <strong><code>Callable</code>接口</strong>可以。</p><h3 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a><code>execute()</code> vs <code>submit()</code></h3><p><code>execute()</code>用于不会提交返回值的任务</p><p><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</p><p>示例1：使用 <code>get() </code>方法获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get();<br>System.out.println(s);<br>executorService.shutdown();<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">abc<br></code></pre></td></tr></table></figure><p>示例2：使用 <code>get（long timeout，TimeUnit unit） </code>方法获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">5000L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>System.out.println(s);<br>executorService.shutdown();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException<br>at java.util.concurrent.FutureTask.get(FutureTask.java:205)<br></code></pre></td></tr></table></figure><h3 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h1 id="五、几种常见的线程池"><a href="#五、几种常见的线程池" class="headerlink" title="五、几种常见的线程池"></a>五、几种常见的线程池</h1><h2 id="5-1、FixedThreadPool"><a href="#5-1、FixedThreadPool" class="headerlink" title="5.1、FixedThreadPool"></a>5.1、FixedThreadPool</h2><h3 id="5-1-1、简介"><a href="#5-1-1、简介" class="headerlink" title="5.1.1、简介"></a>5.1.1、简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 创建一个可重用固定数量线程的线程池</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                   <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                   threadFactory);<br> &#125;<br></code></pre></td></tr></table></figure><p>1.固定大小的线程池nThreads；<br>2.corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；<br>3.keepAliveTime为0，一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效(由于采用了无界队列)；<br>4.阻塞队列采用了LinkedBlockingQueue，一个无界队列；由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</p><p><strong>被称为 <code>可重用固定线程数</code>的线程池，新创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</strong></p><h3 id="5-1-2、执行任务过程介绍"><a href="#5-1-2、执行任务过程介绍" class="headerlink" title="5.1.2、执行任务过程介绍"></a>5.1.2、执行任务过程介绍</h3><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图</p><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708084630822.png" alt="excute()运行示意图"></p><p><strong>说明：</strong></p><p>1、当前运行数小于corePoolSize的时候，有新的任务时，就会创建新的线程中</p><p>2、当前运行数大于或等于corePoolSize的时候，有新的任务时，就会将任务加到 <code>LinkedBlockingQueue</code></p><p>3、当线程池中的线程结束了手里的任务时，就会去<code>LinkedBlockingQueue</code>中获取任务执行</p><h2 id="5-2、SingleThreadExecutor-会导致OOM"><a href="#5-2、SingleThreadExecutor-会导致OOM" class="headerlink" title="5.2、SingleThreadExecutor(会导致OOM)"></a>5.2、SingleThreadExecutor(会导致OOM)</h2><h3 id="5-2-1、简介"><a href="#5-2-1、简介" class="headerlink" title="5.2.1、简介"></a>5.2.1、简介</h3><p><strong>只有<code>一个线程</code>的线程池。</strong></p><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *返回只有一个线程的线程池</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>         (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                 <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                 threadFactory));<br> &#125;<br></code></pre></td></tr></table></figure><p>将<code>corePoolSize</code>与<code>maximumPoolSize</code>都设置成1，保证只有一个线程能运行，剩下的参数与 <code>FixedThreadPool</code>相同</p><h3 id="5-2-2、执行任务过程介绍"><a href="#5-2-2、执行任务过程介绍" class="headerlink" title="5.2.2、执行任务过程介绍"></a>5.2.2、执行任务过程介绍</h3><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708090951289.png"></p><ol><li>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</li><li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li><li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行</li></ol><h2 id="5-3、CachedThreadPool-详解"><a href="#5-3、CachedThreadPool-详解" class="headerlink" title="5.3、CachedThreadPool 详解"></a>5.3、CachedThreadPool 详解</h2><h3 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h3><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>将<code>corePoolSize</code>设置成0，<code>maximumPoolSize</code>设置成<code>Integer.MAX.VALUE</code>。如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程，极端情况下，会导致耗尽CPU和内存资源。</p><h3 id="5-3-2、执行任务过程介绍"><a href="#5-3-2、执行任务过程介绍" class="headerlink" title="5.3.2、执行任务过程介绍"></a>5.3.2、执行任务过程介绍</h3><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708091916023.png" alt="execute()执行流程"></p><p>当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</p><h2 id="5-4、线程使用场景"><a href="#5-4、线程使用场景" class="headerlink" title="5.4、线程使用场景"></a>5.4、线程使用场景</h2><p><code>CachedThreadPool</code>：执行很多短期异步的小程序或者负载较轻的服务器 </p><p><code>FixedThreadPool</code>：适合执行长期任务</p><p><code>SingleThreadExecutor</code>：适合一个任务一个任务执行的场景</p><h1 id="六、ScheduledThreadPoolExecutor-了解即可"><a href="#六、ScheduledThreadPoolExecutor-了解即可" class="headerlink" title="六、ScheduledThreadPoolExecutor(了解即可)"></a>六、ScheduledThreadPoolExecutor(了解即可)</h1><h2 id="6-1、简介"><a href="#6-1、简介" class="headerlink" title="6.1、简介"></a>6.1、简介</h2><p><strong>主要用来在给定的延迟后运行任务，或者定期执行任务</strong></p><p>使用的任务队列<code>DelayQueue</code>封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行，如果执行所需时间一样，那么谁先进来的谁先执行</p><h2 id="6-2、运行机制"><a href="#6-2、运行机制" class="headerlink" title="6.2、运行机制"></a>6.2、运行机制</h2><p><img src="/2022/07/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220708094216584.png" alt="image-20220708094216584"></p><ol><li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>scheduleAtFixedRate()</code></strong> 方法或者 <strong><code>scheduleWithFixedDelay()</code></strong> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>DelayQueue</code></strong> 添加一个实现了 <strong><code>RunnableScheduledFuture</code></strong> 接口的 <strong><code>ScheduledFutureTask</code></strong> 。</li><li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li></ol><p><strong>为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code>做了如下修改</strong></p><p>1、将消息队列改为了 <code>DelayQueue</code></p><p>2、获取任务的方不同</p><p>3、执行周期任务后，增加了额外的处理</p><h2 id="6-3、ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#6-3、ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="6.3、ScheduledThreadPoolExecutor 执行周期任务的步骤"></a>6.3、ScheduledThreadPoolExecutor 执行周期任务的步骤</h2><p><img src="https://javaguide.cn/assets/ScheduledThreadPoolExecutor%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E6%AD%A5%E9%AA%A4.5bd57dd0.png" alt="ScheduledThreadPoolExecutor执行周期任务的步骤"></p><ol><li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li><li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li></ol><h1 id="七、线程池大小确定"><a href="#七、线程池大小确定" class="headerlink" title="七、线程池大小确定"></a>七、线程池大小确定</h1><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong></p><p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>N是指CPU的核心数，一般<strong>CPU 密集型任务设置线程池大小为：(N+1)；I/O 密集型任务线程池大小设置为(2N)</strong></p><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h1 id="八、如何使用线程池"><a href="#八、如何使用线程池" class="headerlink" title="八、如何使用线程池"></a>八、如何使用线程池</h1><p>一般是通过 <code>ThreadPoolExecutor</code> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。</p><p><code>ThreadPoolExecutor</code>的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">KEEP_ALIVE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//使用阿里巴巴推荐的创建线程池的方式</span><br>        <span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_TIME,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;CurrentThread name:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;date：&quot;</span> + Instant.now());<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//终止线程池</span><br>        executor.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Finished all threads&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="九、线程池的注意事项"><a href="#九、线程池的注意事项" class="headerlink" title="九、线程池的注意事项"></a>九、线程池的注意事项</h1><h2 id="9-1、使用-ThreadPoolExecutor-的构造函数声明线程池"><a href="#9-1、使用-ThreadPoolExecutor-的构造函数声明线程池" class="headerlink" title="9.1、使用 ThreadPoolExecutor 的构造函数声明线程池"></a>9.1、使用 <code>ThreadPoolExecutor </code>的构造函数声明线程池</h2><p><strong>线程池必须手动通过 <code>ThreadPoolExecutor </code>的构造函数来声明，避免使用<code>Executors </code>类的 <code>newFixedThreadPool</code> 和 <code>newCachedThreadPool</code> ，因为可能会有 OOM 的风险。</strong>就是<strong>使用有界队列，控制线程创建数量。</strong></p><h2 id="9-2、监测线程池运行状态"><a href="#9-2、监测线程池运行状态" class="headerlink" title="9.2、监测线程池运行状态"></a>9.2、监测线程池运行状态</h2><p>使用SpringBoot 中的 Actuator 组件</p><p>每一秒打印一次线程状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 打印线程池的状态</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> threadPool 线程池对象</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printThreadPoolStatus</span><span class="hljs-params">(ThreadPoolExecutor threadPool)</span> &#123;<br>       <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, createThreadFactory(<span class="hljs-string">&quot;print-images/thread-pool-status&quot;</span>, <span class="hljs-literal">false</span>));<br>       scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;<br>           log.info(<span class="hljs-string">&quot;=========================&quot;</span>);<br>           log.info(<span class="hljs-string">&quot;ThreadPool Size: [&#123;&#125;]&quot;</span>, threadPool.getPoolSize());<br>           log.info(<span class="hljs-string">&quot;Active Threads: &#123;&#125;&quot;</span>, threadPool.getActiveCount());<br>           log.info(<span class="hljs-string">&quot;Number of Tasks : &#123;&#125;&quot;</span>, threadPool.getCompletedTaskCount());<br>           log.info(<span class="hljs-string">&quot;Number of Tasks in Queue: &#123;&#125;&quot;</span>, threadPool.getQueue().size());<br>           log.info(<span class="hljs-string">&quot;=========================&quot;</span>);<br>       &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="9-3、不同类别的业务使用不同的线程池"><a href="#9-3、不同类别的业务使用不同的线程池" class="headerlink" title="9.3、不同类别的业务使用不同的线程池"></a>9.3、不同类别的业务使用不同的线程池</h2><p>一个项目中有多个不同的业务，建议每一个业务都使用各自的线程池</p><p>如果多个业务使用一个线程池，那么可能会造成<code>死锁</code></p><p>假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 **”死锁”**。</p><p><img src="https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81.8ea83cdb.png" alt="线程池使用不当导致死锁"></p><h2 id="9-4、初始化线程池的时候别忘了给线程池命名"><a href="#9-4、初始化线程池的时候别忘了给线程池命名" class="headerlink" title="9.4、初始化线程池的时候别忘了给线程池命名"></a>9.4、初始化线程池的时候别忘了给线程池命名</h2><p><strong>好处：</strong>有助于定位问题。</p><h3 id="9-4-1、给线程池命名一般使用两种方法："><a href="#9-4-1、给线程池命名一般使用两种方法：" class="headerlink" title="9.4.1、给线程池命名一般使用两种方法："></a>9.4.1、给线程池命名一般使用两种方法：</h3><p>**1.利用 guava 的 <code>ThreadFactoryBuilder</code> **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                        .setNameFormat(threadNamePrefix + <span class="hljs-string">&quot;-%d&quot;</span>)<br>                        .setDaemon(<span class="hljs-literal">true</span>).build();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)<br></code></pre></td></tr></table></figure><p><strong>2.自己实现 <code>ThreadFactor</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、使用线程池的好处：&quot;&gt;&lt;a href=&quot;#一、使用线程池的好处：&quot; class=&quot;headerlink&quot; title=&quot;一、使用线程池的好处：&quot;&gt;&lt;/a&gt;一、使用线程池的好处：&lt;/h1&gt;&lt;p&gt;1、降低资源消耗&lt;/p&gt;
&lt;p&gt;2、提高响应速度&lt;/p&gt;
&lt;p&gt;3、</summary>
      
    
    
    
    <category term="java面试" scheme="https://eliseo.top/categories/java%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="java面试" scheme="https://eliseo.top/tags/java%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转图像</title>
    <link href="https://eliseo.top/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://eliseo.top/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2022-07-06T14:27:36.000Z</published>
    <updated>2022-07-06T14:31:10.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/image-20220706222939152.png" alt="旋转图像"></p><p><strong>方法一：加入一个二维数组存放数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[j][n - i - <span class="hljs-number">1</span>] = matrix[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[i][j] = res[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：直接原地交换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// 先上下交换 然后在沿着对角线交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 上下交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = matrix[i];<br>            matrix[i] = matrix[n - i - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>        <span class="hljs-comment">// 对角线交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/06/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/image-20220706222939152.png&quot; alt=&quot;旋转图像&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：加入一个二维数组存放数据&lt;/stro</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="https://eliseo.top/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://eliseo.top/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2022-07-06T14:26:28.000Z</published>
    <updated>2022-07-06T14:32:49.944Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/image-20220706223151247.png" alt="全排列"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        backtrace(<span class="hljs-number">0</span>, list, nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> index, List&lt;Integer&gt; list, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从第一位往后固定</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123; <span class="hljs-comment">// 要是这个位置没有元素</span><br>                list.add(nums[i]);<br>                used[i] = <span class="hljs-literal">true</span>;<br>                backtrace(index + <span class="hljs-number">1</span>, list, nums, used);<br>                <span class="hljs-comment">// 移除list数组最后一个值</span><br>                list.remove(list.size() - <span class="hljs-number">1</span>);<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/06/%E5%85%A8%E6%8E%92%E5%88%97/image-20220706223151247.png&quot; alt=&quot;全排列&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>接雨水</title>
    <link href="https://eliseo.top/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://eliseo.top/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2022-07-04T08:31:07.000Z</published>
    <updated>2022-07-04T08:33:49.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20220704163322027.png" alt="接雨水"></p><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 双指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 那边小那边就往里走</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            leftMax = Math.max(height[left], leftMax);<br>            rightMax = Math.max(height[right], rightMax);<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                <span class="hljs-comment">// 计算最高值和当前值之间的储水量</span><br>                ans += leftMax - height[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += rightMax - height[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/07/04/%E6%8E%A5%E9%9B%A8%E6%B0%B4/image-20220704163322027.png&quot; alt=&quot;接雨水&quot;&gt;&lt;/p&gt;
&lt;p&gt;双指针&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://eliseo.top/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://eliseo.top/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-06-13T02:12:35.000Z</published>
    <updated>2022-06-13T02:13:28.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/image-20220613101313587.png" alt="搜索旋转排序数组"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 数组找东西 优先想到二分法，虽然数组不有序，但是局部有序 所以我们现在有序的地方寻找，然后再在无序的地方寻找</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[r]) &#123; <span class="hljs-comment">// 有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/13/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/image-20220613101313587.png&quot; alt=&quot;搜索旋转排序数组</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>最长有效括号</title>
    <link href="https://eliseo.top/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>https://eliseo.top/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-06-13T01:10:53.000Z</published>
    <updated>2022-06-13T01:13:37.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/image-20220613091241176.png" alt="最长有效括号"></p><p><strong>解法：栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.push(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 如果加入的元素是(</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 将(的下标放入栈内</span><br>                stack.push(i);<br>            &#125;<br>            <span class="hljs-comment">// 如果加入的元素是 (，那么存在</span><br>            <span class="hljs-comment">// 1、)前面有(</span><br>            <span class="hljs-comment">// 2、前面没有左括号和它进行匹配，那么这个右括号就形成了新的边界。新的子串匹配时，起点必须在该边界右边</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123; <span class="hljs-comment">// 加入的元素不是(,是)</span><br>                stack.pop();<br>                <span class="hljs-comment">// 如果栈是空的</span><br>                <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 将这个右括号的下标作为最后一个没有被匹配的右括号</span><br>                    stack.push(i);<br>                &#125;<br>                <span class="hljs-comment">// 匹配到了。那么这个有括号的下标减去栈顶元素(也就是最后一个没有被匹配的括号)就是当前长度</span><br>                max =  Math.max(max, i - stack.peek());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/13/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/image-20220613091241176.png&quot; alt=&quot;最长有效括号&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>下一个排列</title>
    <link href="https://eliseo.top/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://eliseo.top/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2022-06-07T03:36:00.000Z</published>
    <updated>2022-06-07T03:39:17.697Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/image-20220607113633064.png" alt="下一个排列"></p><p><strong>题意分析：</strong></p><p>找到一个比nums刚好还大的一个数字，也就是用nums的所给数字组成一个比刚开始的nums大的数字中的最小的数字就是所要输出的数</p><p><strong>题解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">// [1,2,3,8,5,7,6,4]</span><br>    <span class="hljs-comment">// 先从后往前找 找到最靠右的第一个变小的值 然后找到这个值右边比这个值小的值</span><br>    <span class="hljs-comment">// 然后交换这两个值</span><br>    <span class="hljs-comment">// 然后将最小的最大值的右边的数字按从小到大排序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i--;<br>        &#125; <span class="hljs-comment">// 5</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j--;<br>            &#125; <span class="hljs-comment">// 6</span><br>            swap(nums, i, j);<br>        &#125;<br>        sort(nums, i+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/07/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/image-20220607113633064.png&quot; alt=&quot;下一个排列&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意分析：&lt;/stron</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="https://eliseo.top/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://eliseo.top/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-06-07T00:41:48.000Z</published>
    <updated>2022-06-07T00:45:01.128Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220607084424542.png" alt="合并K个升序链表"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 防止溢出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br><br>    <span class="hljs-comment">// 空指针</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dum;<br><br>        <span class="hljs-keyword">while</span>(a != <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(a.val &lt; b.val) &#123;<br>                cur.next = a;<br>                a = a.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur.next = b;<br>                b = b.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = a != <span class="hljs-literal">null</span> ? a : b;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/07/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220607084424542.png&quot; alt=&quot;合并K个升序链表&quot;&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>括号生成</title>
    <link href="https://eliseo.top/2022/06/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://eliseo.top/2022/06/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2022-06-04T01:47:20.000Z</published>
    <updated>2022-06-04T01:48:23.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/image-20220604094755038.png" alt="括号生产"></p><p><strong>解法一：（深度优先遍历。回溯）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, n, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// left 与 right指的是左右括号的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, String s, <span class="hljs-type">int</span> n, List&lt;String&gt; ans)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == n &amp;&amp; right == n) &#123;<br>            ans.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>            dfs(left + <span class="hljs-number">1</span>, right, s + <span class="hljs-string">&quot;(&quot;</span>, n, ans);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; n) &#123;<br>            dfs(left, right + <span class="hljs-number">1</span>, s + <span class="hljs-string">&quot;)&quot;</span>, n, ans);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/04/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/image-20220604094755038.png&quot; alt=&quot;括号生产&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法一：（深度优先遍历。回溯）&lt;/stron</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="https://eliseo.top/2022/06/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://eliseo.top/2022/06/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-06-04T01:16:55.000Z</published>
    <updated>2022-06-04T01:19:35.467Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220604091731709.png" alt="合并两个有序链表"></p><p><strong>解法一：（递归）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list1, list2.next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法二：（迭代）</strong></p><p>定义一个哨兵节点，然后将两个表中的节点一一对比，小的节点跟在哨兵节点之后。最后返回哨兵节点.next</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/04/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220604091731709.png&quot; alt=&quot;合并两个有序链表</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="https://eliseo.top/2022/06/03/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://eliseo.top/2022/06/03/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-06-03T07:27:08.000Z</published>
    <updated>2022-06-03T07:29:15.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/03/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/image-20220603152739672.png" alt="有效的括号"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            ch = s.charAt(i);<br>            <span class="hljs-comment">//碰到左括号，就把相应的右括号入栈</span><br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果是右括号判断是否和栈顶元素匹配</span><br>                deque.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后判断栈中元素是否匹配</span><br>        <span class="hljs-keyword">return</span> deque.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="解题过程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/03/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/image-20220603152739672.png&quot; alt=&quot;有效的括号&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法：&lt;/strong&gt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="https://eliseo.top/2022/06/03/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://eliseo.top/2022/06/03/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2022-06-03T02:21:50.000Z</published>
    <updated>2022-06-03T02:22:52.501Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/06/03/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220603102220574.png" alt="删除链表的倒数第N个节点"></p><p><strong>解法一：（双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br><br>        <span class="hljs-comment">//前面添加0节点以解决删除第一个的问题</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        fast = head;<br>        slow = res;<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//快指针先走n个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-comment">//当fast来到了末尾之后一个的时候，slow到达了倒数第n个的前一个，此时这个节点就是要删除的</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/06/03/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/image-20220603</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="https://eliseo.top/2022/05/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://eliseo.top/2022/05/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2022-05-29T03:02:07.000Z</published>
    <updated>2022-05-29T03:07:55.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/image-20220529110449581.png" alt="电话号码的字母组合"></p><p><strong>解法：(回溯)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">//设置全局列表存储最后的结果</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">//初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串&quot;&quot;</span><br>        String[] numString = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>        <span class="hljs-comment">//迭代处理</span><br>        backTracking(digits, numString, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br><br>    &#125;<br><br>    <span class="hljs-comment">//每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-comment">//比如digits如果为&quot;23&quot;,num 为0，则str表示2对应的 abc</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(String digits, String[] numString, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">//遍历全部一次记录一次得到的字符串</span><br>        <span class="hljs-comment">//用num记录每次遍历到字符串的位置，这样性能更好</span><br>        <span class="hljs-keyword">if</span> (num == digits.length()) &#123;<br>            list.add(temp.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//str 表示当前num对应的字符串 </span><br>        <span class="hljs-comment">//digits.charAt(num) 获取当前num位置的字符</span><br>        <span class="hljs-comment">//由于numString表是从0下标开始一直到9 所以 -&#x27;0&#x27;之后就可以得到对应的数组的下标位置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> numString[digits.charAt(num) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-comment">//遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            temp.append(str.charAt(i));<br>            <span class="hljs-comment">//回溯</span><br>            backTracking(digits, numString, num + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//剔除末尾的继续尝试</span><br>            temp.deleteCharAt(temp.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/29/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/image-20220529110449581.png&quot; alt=</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="https://eliseo.top/2022/05/28/Mysql/"/>
    <id>https://eliseo.top/2022/05/28/Mysql/</id>
    <published>2022-05-28T01:35:45.000Z</published>
    <updated>2022-06-03T07:30:19.302Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一些不怎么用过的mysql语句：</strong></p><p><strong>rank() over：</strong>排名相同的两名是并列，但是占两个名次，1 1 3 4 4 6这种</p><p><strong>dense_rank() over：</strong>排名相同的两名是并列，共占一个名词，1 1 2 3 3 4这种</p><p><strong>row_number() over：</strong>这个函数不需要考虑是否并列，哪怕根据条件查询出来的数值相同也会进行连续排名 1 2 3 4 5</p><p><strong>distance</strong> 去重</p><p><strong>ifnull</strong> 判断是否为空 自动去除空的数据 ifnull(( ***),null) 将表中的空数据输出为null</p><h1 id="一、逻辑架构"><a href="#一、逻辑架构" class="headerlink" title="一、逻辑架构"></a>一、逻辑架构</h1><h2 id="1、逻辑架构剖析"><a href="#1、逻辑架构剖析" class="headerlink" title="1、逻辑架构剖析"></a>1、逻辑架构剖析</h2><h3 id="1-1服务器处理客户端请求"><a href="#1-1服务器处理客户端请求" class="headerlink" title="1.1服务器处理客户端请求"></a>1.1服务器处理客户端请求</h3><p>mysql是c/s架构，即 <strong>Client/Server 架构</strong>，服务器端程序使用的 <strong>mysqld</strong></p><p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是： <strong>客户端进程向服务器进程发送一段文本(SQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)。</strong></p><p><img src="/2022/05/28/Mysql/image-20220530211722852.png" alt="查询请求"></p><p><img src="/2022/05/28/Mysql/image-20220530221410526.png" alt="mysql服务器的逻辑架构说明"></p><h3 id="1-2、Connectors"><a href="#1-2、Connectors" class="headerlink" title="1.2、Connectors"></a>1.2、Connectors</h3><p>Connectors，指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server<strong>建立TCP连接</strong>,之后按照其定义好的协议进行交互。或者比较方便的办法是调用SDK，比如Native c API、JDBC、PHP等各种语言MySQL Connector，或者通过ODBC。但<strong>通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互。</strong></p><h3 id="1-3、第1层：连接层"><a href="#1-3、第1层：连接层" class="headerlink" title="1.3、第1层：连接层"></a>1.3、第1层：连接层</h3><p>系统(客户端)访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p><p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p><ul><li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li><li><strong>用户名认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li></ul><p><strong>TCP</strong> 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>多个系统都可以和MySQL服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL服务器里有专门的<code>TCP连接池</code>限制连接数，采用<code>长连接模式</code>复用TCP连接。</p><p><img src="/2022/05/28/Mysql/image-20220530230605123.png" alt="image-20220530230605123"></p><p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>这些内容都归纳到<code>MySQL</code>的<strong>连接管理</strong>组件中。</p><p>所以<strong>连接管理</strong>的职责是负责认证、管理连接、获取权限信息。</p><h3 id="1-4、第2层：服务层"><a href="#1-4、第2层：服务层" class="headerlink" title="1.4、第2层：服务层"></a>1.4、第2层：服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成 <code>缓存的查询</code>，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现。</p><p>在该层，服务器会 <code>解析查询</code>并创建相应的内部 <code>解析树</code>，并对其完成相应的 <code>优化</code>：如确定查询表的顺序，是由利用索引等，最后生成相应的执行操作。</p><p>如果是SELECT语句，服务器还会 <code>查询内部的缓存</code>。如果缓存空间足够大，这样在解决大量读操作的环境中能后很好的提升系统的性能。</p><ul><li><p><strong>SQL Interface：SQL接口</strong></p><ul><li>接受用户的SQL命令，并且返回用户需要查询的结果。比如SELECT…FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。</li></ul></li><li><p><strong>Parser：解析器</strong></p><ul><li>在解析器中对SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是够具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>OpTimizer：查询优化器</strong></p><ul><li><p>SQL语句在语法解析之后，查询之前会使用查询优化器确定SQL语句的执行路径，生成一个<code>执行计划</code>。</p></li><li><p>这个执行计划表明应该 <code>使用哪些索引</code>进行查询(全表检索还是使用索引检索)，表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用<code>选取-投影-连接</code>策略进行查询。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id,name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是讲标全部查询出来以后再进行gender过滤。</p><p>这个SELECT查询现根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后在进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p></li></ul></li><li><p><strong>Caches &amp; Buffers：查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能后在其中找到对应的查询结果，那么就不再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓存等。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul></li></ul><h3 id="1-5、第3层：引擎层"><a href="#1-5、第3层：引擎层" class="headerlink" title="1.5、第3层：引擎层"></a>1.5、第3层：引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。</p><hr><p>和其它数据库相比，MysQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，<code>插件式的存储引擎</code>架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MySQL还允许<code>开发人员设置自己的存储引擎</code>。</p><p>这种高效的模块化架构为那些希望专门针对特定应用程序需求（例如数据仓库、事务处理或高可用性情况)的人提供了巨大的好处，同时享受使用一组独立于任何接口和服务的优势存储引擎。</p><p>插件式存储引擎层（Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p><p>MySQL8.0.25默认支持的存储引擎如下：</p><p><img src="/2022/05/28/Mysql/image-20220531002203728.png" alt="存储引擎"></p><h3 id="1-6、存储层"><a href="#1-6、存储层" class="headerlink" title="1.6、存储层"></a>1.6、存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在<strong>文件系统</strong>上，以<strong>文件</strong>的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统</p><p>使用 <strong>show variables like “%datadir%”</strong>可以查看存储文件所在的地方</p><p><img src="/2022/05/28/Mysql/image-20220531002543626.png"></p><h3 id="1-7、小结"><a href="#1-7、小结" class="headerlink" title="1.7、小结"></a>1.7、小结</h3><p>MySQL架构图简化如下：</p><p><img src="/2022/05/28/Mysql/image-20220531002348351.png"></p><p>简化为三层结构：</p><ol><li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li><li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li><li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li></ol><h2 id="2、SQL执行流程"><a href="#2、SQL执行流程" class="headerlink" title="2、SQL执行流程"></a>2、SQL执行流程</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一些不怎么用过的mysql语句：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rank() over：&lt;/strong&gt;排名相同的两名是并列，但是占两个名次，1 1 3 4 4 6这种&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dense_rank() over：&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://eliseo.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://eliseo.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="https://eliseo.top/2022/05/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://eliseo.top/2022/05/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2022-05-27T07:01:31.000Z</published>
    <updated>2022-05-27T07:04:06.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/image-20220527150203332.png" alt="三数之和"></p><p><strong>解法：（排序+双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 先从小到大排序</span><br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 从第一位开始判断</span><br>        <span class="hljs-comment">// k &lt; nums.length - 2是为了保证后面还能存在两个数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; nums.length - <span class="hljs-number">2</span>; k++) &#123;<br>            <span class="hljs-comment">// 若nums[k]大于0，则后面的数字也是大于零（排序后是递增的）</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 判断该数字的下一个数字与最后一个数字</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>, j = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>                <span class="hljs-comment">// 如果该数字与数字下一个数字与最后一个数字之和为sum 那么输出</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[k] + nums[i] + nums[j];<br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 左指针向右并且去重</span><br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 右指针向左并且去重</span><br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/27/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/image-20220527150203332.png&quot; alt=&quot;三数之和&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法：（排序+双指针）&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="https://eliseo.top/2022/05/26/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://eliseo.top/2022/05/26/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2022-05-26T01:28:43.000Z</published>
    <updated>2022-05-26T01:29:54.877Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/26/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/image-20220526092922227.png" alt="盛最多水的容器"></p><p><strong>解法：（双指针）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || height == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nowRes</span> <span class="hljs-operator">=</span> (right - left) * Math.min(height[left], height[right]);<br>            res = Math.max(res, nowRes);<br>            <span class="hljs-keyword">if</span> (height[left] &gt; height[right]) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/26/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/image-20220526092922227.png&quot; alt=&quot;盛最多水的容器&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://eliseo.top/2022/05/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://eliseo.top/2022/05/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2022-05-25T02:15:06.000Z</published>
    <updated>2022-05-25T02:39:44.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20220525103931088.png" alt="最长回文子串"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                                        中心扩散</span><br><span class="hljs-comment">    思路：寻找一个字符 然后判断左右是否相等 相等则左右各自+1 如果左边等于 那么左边指针往左移动</span><br><span class="hljs-comment">    右边等于 那么右指针往右边 然后判断左右指针所指的字符是否相等</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxlen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            left = i - <span class="hljs-number">1</span>;<br>            right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nowlen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//当前值与左值相等 左减</span><br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; chars[i] == chars[left]) &#123;<br>                left--;<br>                nowlen++;<br>            &#125;<br>            <span class="hljs-comment">//当前值与右值相等 左加</span><br>            <span class="hljs-keyword">while</span> (right &lt; len &amp;&amp; chars[i] == chars[right]) &#123;<br>                right++;<br>                nowlen++;<br>            &#125;<br>            <span class="hljs-comment">//当左右相等时，左减右加</span><br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; chars[left] == chars[right]) &#123;<br>                left--;<br>                right++;<br>                nowlen += <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nowlen &gt; maxlen) &#123;<br>                maxlen = nowlen;<br>                start = left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">maxstr</span> <span class="hljs-operator">=</span> s.substring(start + <span class="hljs-number">1</span>,start + <span class="hljs-number">1</span> + maxlen);<br>        <span class="hljs-keyword">return</span> maxstr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/image-20220525103931088.png&quot; alt=&quot;最长回文子串&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>寻找两个正序数组的中位数</title>
    <link href="https://eliseo.top/2022/05/24/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://eliseo.top/2022/05/24/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2022-05-24T02:32:35.000Z</published>
    <updated>2022-05-25T02:43:05.920Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/24/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-20220524103718735.png" alt="寻找两个正序数组的中位数"></p><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     思路：</span><br><span class="hljs-comment">        1、假设我们要找第 k 小数，我们可以每次循环排除掉 k/2 个数，假如我们要找第7小的数字，我们比较两个数组的第 k/2 个数字，</span><br><span class="hljs-comment">        如果 k 是奇数，向下取整。也就是比较第3个数字，上边数组中的4和下边数组中的3，</span><br><span class="hljs-comment">        如果哪个小，就表明该数组的前 k/2 个数字都不是第 k 小数字，所以可以排除。</span><br><span class="hljs-comment">        然后我们寻找第k - 3 = 4小的数字就行</span><br><span class="hljs-comment">        2、我们可能遇见有一个数组小于 k/2的情况 然后将这个小于的数组直接全部排除 然后在另一个数组中寻找第 k-m个元素即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-comment">// m + n为奇数 那么a和b一样 如果 m + n为偶数 那么就是ab的平均数</span><br>        <span class="hljs-comment">// 由于要求的是如果为奇数 让左边的数字比右边多一个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 寻找ab在nums1与nums2中的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">resa</span> <span class="hljs-operator">=</span> rec(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resb</span> <span class="hljs-operator">=</span> rec(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, b);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) (resa + resb) / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//两个数组及其起始位置，k为要找的数字的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rec</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//如果i位置大于等于长度，说明nums1走完了，就去nums2里直接找</span><br>        <span class="hljs-keyword">if</span> (i &gt;= nums1.length) &#123;<br>            <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j &gt;= nums2.length) &#123;<br>            <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//如果要找第一个元素，那么就找这两个数组中最小的数,也就是他们起始位置中最小的</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>        &#125;<br><br>        <span class="hljs-comment">//确保还有第k/2个值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br><br>        <span class="hljs-comment">//如果两个数组中的第k/2相等  如果k是偶数，那么这个位置的数字就是要找的，无论舍弃哪个都会留下有正确答案的,如果是奇数，答案在某个数组的k/2的下一个，总之正确答案不会被舍弃掉</span><br>        <span class="hljs-keyword">if</span> (m1 == m2 &amp;&amp; k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> m1;<br>        &#125;<br>        <span class="hljs-comment">//两个数组中谁的第k/2个数小，就舍弃他的前k/2个数，k也小一半</span><br>        <span class="hljs-keyword">if</span> (m1 &lt; m2) &#123;<br>            i += k / <span class="hljs-number">2</span>;<br>            k -= k / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> rec(nums1, i, nums2, j, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j += k / <span class="hljs-number">2</span>;<br>            k -= k / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> rec(nums1, i, nums2, j, k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/24/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/image-</summary>
      
    
    
    
    <category term="力扣" scheme="https://eliseo.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣" scheme="https://eliseo.top/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
</feed>
